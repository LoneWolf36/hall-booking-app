
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * Tenant represents a logical customer (single hall now, multi-tenant later)
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model Venue
 * Venue with flexible payment configuration
 */
export type Venue = $Result.DefaultSelection<Prisma.$VenuePayload>
/**
 * Model User
 * Users include customers and admins (role-based)
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Booking
 * Enhanced booking with flexible payment support
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Blackout
 * Blackout periods where the venue is unavailable
 */
export type Blackout = $Result.DefaultSelection<Prisma.$BlackoutPayload>
/**
 * Model Payment
 * Online payments via Razorpay or other gateways
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model CashPayment
 * Cash payment tracking for offline transactions
 */
export type CashPayment = $Result.DefaultSelection<Prisma.$CashPaymentPayload>
/**
 * Model CommissionRecord
 * Platform commission tracking for all booking types
 */
export type CommissionRecord = $Result.DefaultSelection<Prisma.$CommissionRecordPayload>
/**
 * Model CustomerPaymentPreference
 * Customer payment behavior tracking
 */
export type CustomerPaymentPreference = $Result.DefaultSelection<Prisma.$CustomerPaymentPreferencePayload>
/**
 * Model VenueOnboardingResponse
 * Venue onboarding questionnaire responses
 */
export type VenueOnboardingResponse = $Result.DefaultSelection<Prisma.$VenueOnboardingResponsePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.venue`: Exposes CRUD operations for the **Venue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Venues
    * const venues = await prisma.venue.findMany()
    * ```
    */
  get venue(): Prisma.VenueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blackout`: Exposes CRUD operations for the **Blackout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blackouts
    * const blackouts = await prisma.blackout.findMany()
    * ```
    */
  get blackout(): Prisma.BlackoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashPayment`: Exposes CRUD operations for the **CashPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashPayments
    * const cashPayments = await prisma.cashPayment.findMany()
    * ```
    */
  get cashPayment(): Prisma.CashPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commissionRecord`: Exposes CRUD operations for the **CommissionRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommissionRecords
    * const commissionRecords = await prisma.commissionRecord.findMany()
    * ```
    */
  get commissionRecord(): Prisma.CommissionRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerPaymentPreference`: Exposes CRUD operations for the **CustomerPaymentPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerPaymentPreferences
    * const customerPaymentPreferences = await prisma.customerPaymentPreference.findMany()
    * ```
    */
  get customerPaymentPreference(): Prisma.CustomerPaymentPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.venueOnboardingResponse`: Exposes CRUD operations for the **VenueOnboardingResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VenueOnboardingResponses
    * const venueOnboardingResponses = await prisma.venueOnboardingResponse.findMany()
    * ```
    */
  get venueOnboardingResponse(): Prisma.VenueOnboardingResponseDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    Venue: 'Venue',
    User: 'User',
    Booking: 'Booking',
    Blackout: 'Blackout',
    Payment: 'Payment',
    CashPayment: 'CashPayment',
    CommissionRecord: 'CommissionRecord',
    CustomerPaymentPreference: 'CustomerPaymentPreference',
    VenueOnboardingResponse: 'VenueOnboardingResponse'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "venue" | "user" | "booking" | "blackout" | "payment" | "cashPayment" | "commissionRecord" | "customerPaymentPreference" | "venueOnboardingResponse"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      Venue: {
        payload: Prisma.$VenuePayload<ExtArgs>
        fields: Prisma.VenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findFirst: {
            args: Prisma.VenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findMany: {
            args: Prisma.VenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          create: {
            args: Prisma.VenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          createMany: {
            args: Prisma.VenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VenueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          delete: {
            args: Prisma.VenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          update: {
            args: Prisma.VenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          deleteMany: {
            args: Prisma.VenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VenueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          upsert: {
            args: Prisma.VenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          aggregate: {
            args: Prisma.VenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenue>
          }
          groupBy: {
            args: Prisma.VenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenueCountArgs<ExtArgs>
            result: $Utils.Optional<VenueCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Blackout: {
        payload: Prisma.$BlackoutPayload<ExtArgs>
        fields: Prisma.BlackoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlackoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlackoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlackoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlackoutPayload>
          }
          findFirst: {
            args: Prisma.BlackoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlackoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlackoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlackoutPayload>
          }
          findMany: {
            args: Prisma.BlackoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlackoutPayload>[]
          }
          create: {
            args: Prisma.BlackoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlackoutPayload>
          }
          createMany: {
            args: Prisma.BlackoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlackoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlackoutPayload>[]
          }
          delete: {
            args: Prisma.BlackoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlackoutPayload>
          }
          update: {
            args: Prisma.BlackoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlackoutPayload>
          }
          deleteMany: {
            args: Prisma.BlackoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlackoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlackoutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlackoutPayload>[]
          }
          upsert: {
            args: Prisma.BlackoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlackoutPayload>
          }
          aggregate: {
            args: Prisma.BlackoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlackout>
          }
          groupBy: {
            args: Prisma.BlackoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlackoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlackoutCountArgs<ExtArgs>
            result: $Utils.Optional<BlackoutCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      CashPayment: {
        payload: Prisma.$CashPaymentPayload<ExtArgs>
        fields: Prisma.CashPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashPaymentPayload>
          }
          findFirst: {
            args: Prisma.CashPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashPaymentPayload>
          }
          findMany: {
            args: Prisma.CashPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashPaymentPayload>[]
          }
          create: {
            args: Prisma.CashPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashPaymentPayload>
          }
          createMany: {
            args: Prisma.CashPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashPaymentPayload>[]
          }
          delete: {
            args: Prisma.CashPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashPaymentPayload>
          }
          update: {
            args: Prisma.CashPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashPaymentPayload>
          }
          deleteMany: {
            args: Prisma.CashPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashPaymentPayload>[]
          }
          upsert: {
            args: Prisma.CashPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashPaymentPayload>
          }
          aggregate: {
            args: Prisma.CashPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashPayment>
          }
          groupBy: {
            args: Prisma.CashPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<CashPaymentCountAggregateOutputType> | number
          }
        }
      }
      CommissionRecord: {
        payload: Prisma.$CommissionRecordPayload<ExtArgs>
        fields: Prisma.CommissionRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommissionRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommissionRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionRecordPayload>
          }
          findFirst: {
            args: Prisma.CommissionRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommissionRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionRecordPayload>
          }
          findMany: {
            args: Prisma.CommissionRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionRecordPayload>[]
          }
          create: {
            args: Prisma.CommissionRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionRecordPayload>
          }
          createMany: {
            args: Prisma.CommissionRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommissionRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionRecordPayload>[]
          }
          delete: {
            args: Prisma.CommissionRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionRecordPayload>
          }
          update: {
            args: Prisma.CommissionRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionRecordPayload>
          }
          deleteMany: {
            args: Prisma.CommissionRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommissionRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommissionRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionRecordPayload>[]
          }
          upsert: {
            args: Prisma.CommissionRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionRecordPayload>
          }
          aggregate: {
            args: Prisma.CommissionRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommissionRecord>
          }
          groupBy: {
            args: Prisma.CommissionRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommissionRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommissionRecordCountArgs<ExtArgs>
            result: $Utils.Optional<CommissionRecordCountAggregateOutputType> | number
          }
        }
      }
      CustomerPaymentPreference: {
        payload: Prisma.$CustomerPaymentPreferencePayload<ExtArgs>
        fields: Prisma.CustomerPaymentPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerPaymentPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerPaymentPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentPreferencePayload>
          }
          findFirst: {
            args: Prisma.CustomerPaymentPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerPaymentPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentPreferencePayload>
          }
          findMany: {
            args: Prisma.CustomerPaymentPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentPreferencePayload>[]
          }
          create: {
            args: Prisma.CustomerPaymentPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentPreferencePayload>
          }
          createMany: {
            args: Prisma.CustomerPaymentPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerPaymentPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentPreferencePayload>[]
          }
          delete: {
            args: Prisma.CustomerPaymentPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentPreferencePayload>
          }
          update: {
            args: Prisma.CustomerPaymentPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentPreferencePayload>
          }
          deleteMany: {
            args: Prisma.CustomerPaymentPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerPaymentPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerPaymentPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentPreferencePayload>[]
          }
          upsert: {
            args: Prisma.CustomerPaymentPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPaymentPreferencePayload>
          }
          aggregate: {
            args: Prisma.CustomerPaymentPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerPaymentPreference>
          }
          groupBy: {
            args: Prisma.CustomerPaymentPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerPaymentPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerPaymentPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerPaymentPreferenceCountAggregateOutputType> | number
          }
        }
      }
      VenueOnboardingResponse: {
        payload: Prisma.$VenueOnboardingResponsePayload<ExtArgs>
        fields: Prisma.VenueOnboardingResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenueOnboardingResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueOnboardingResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenueOnboardingResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueOnboardingResponsePayload>
          }
          findFirst: {
            args: Prisma.VenueOnboardingResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueOnboardingResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenueOnboardingResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueOnboardingResponsePayload>
          }
          findMany: {
            args: Prisma.VenueOnboardingResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueOnboardingResponsePayload>[]
          }
          create: {
            args: Prisma.VenueOnboardingResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueOnboardingResponsePayload>
          }
          createMany: {
            args: Prisma.VenueOnboardingResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VenueOnboardingResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueOnboardingResponsePayload>[]
          }
          delete: {
            args: Prisma.VenueOnboardingResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueOnboardingResponsePayload>
          }
          update: {
            args: Prisma.VenueOnboardingResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueOnboardingResponsePayload>
          }
          deleteMany: {
            args: Prisma.VenueOnboardingResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenueOnboardingResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VenueOnboardingResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueOnboardingResponsePayload>[]
          }
          upsert: {
            args: Prisma.VenueOnboardingResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueOnboardingResponsePayload>
          }
          aggregate: {
            args: Prisma.VenueOnboardingResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenueOnboardingResponse>
          }
          groupBy: {
            args: Prisma.VenueOnboardingResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenueOnboardingResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenueOnboardingResponseCountArgs<ExtArgs>
            result: $Utils.Optional<VenueOnboardingResponseCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    venue?: VenueOmit
    user?: UserOmit
    booking?: BookingOmit
    blackout?: BlackoutOmit
    payment?: PaymentOmit
    cashPayment?: CashPaymentOmit
    commissionRecord?: CommissionRecordOmit
    customerPaymentPreference?: CustomerPaymentPreferenceOmit
    venueOnboardingResponse?: VenueOnboardingResponseOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    venues: number
    users: number
    bookings: number
    payments: number
    blackouts: number
    cashPayments: number
    commissionRecords: number
    customerPaymentPreferences: number
    venueOnboardingResponses: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venues?: boolean | TenantCountOutputTypeCountVenuesArgs
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    bookings?: boolean | TenantCountOutputTypeCountBookingsArgs
    payments?: boolean | TenantCountOutputTypeCountPaymentsArgs
    blackouts?: boolean | TenantCountOutputTypeCountBlackoutsArgs
    cashPayments?: boolean | TenantCountOutputTypeCountCashPaymentsArgs
    commissionRecords?: boolean | TenantCountOutputTypeCountCommissionRecordsArgs
    customerPaymentPreferences?: boolean | TenantCountOutputTypeCountCustomerPaymentPreferencesArgs
    venueOnboardingResponses?: boolean | TenantCountOutputTypeCountVenueOnboardingResponsesArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountVenuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountBlackoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlackoutWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCashPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashPaymentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCommissionRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionRecordWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCustomerPaymentPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPaymentPreferenceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountVenueOnboardingResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueOnboardingResponseWhereInput
  }


  /**
   * Count Type VenueCountOutputType
   */

  export type VenueCountOutputType = {
    bookings: number
    blackouts: number
    commissionRecords: number
    venueOnboardingResponses: number
  }

  export type VenueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | VenueCountOutputTypeCountBookingsArgs
    blackouts?: boolean | VenueCountOutputTypeCountBlackoutsArgs
    commissionRecords?: boolean | VenueCountOutputTypeCountCommissionRecordsArgs
    venueOnboardingResponses?: boolean | VenueCountOutputTypeCountVenueOnboardingResponsesArgs
  }

  // Custom InputTypes
  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueCountOutputType
     */
    select?: VenueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountBlackoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlackoutWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountCommissionRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionRecordWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountVenueOnboardingResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueOnboardingResponseWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    bookings: number
    confirmedBookings: number
    cashPaymentsRecorded: number
    customerPaymentPreferences: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    confirmedBookings?: boolean | UserCountOutputTypeCountConfirmedBookingsArgs
    cashPaymentsRecorded?: boolean | UserCountOutputTypeCountCashPaymentsRecordedArgs
    customerPaymentPreferences?: boolean | UserCountOutputTypeCountCustomerPaymentPreferencesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConfirmedBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCashPaymentsRecordedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashPaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomerPaymentPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPaymentPreferenceWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    payments: number
    cashPayments: number
    commissionRecord: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | BookingCountOutputTypeCountPaymentsArgs
    cashPayments?: boolean | BookingCountOutputTypeCountCashPaymentsArgs
    commissionRecord?: boolean | BookingCountOutputTypeCountCommissionRecordArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountCashPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashPaymentWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountCommissionRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionRecordWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    slug: string
    settings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venues?: boolean | Tenant$venuesArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    bookings?: boolean | Tenant$bookingsArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    blackouts?: boolean | Tenant$blackoutsArgs<ExtArgs>
    cashPayments?: boolean | Tenant$cashPaymentsArgs<ExtArgs>
    commissionRecords?: boolean | Tenant$commissionRecordsArgs<ExtArgs>
    customerPaymentPreferences?: boolean | Tenant$customerPaymentPreferencesArgs<ExtArgs>
    venueOnboardingResponses?: boolean | Tenant$venueOnboardingResponsesArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "settings" | "createdAt" | "updatedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venues?: boolean | Tenant$venuesArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    bookings?: boolean | Tenant$bookingsArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    blackouts?: boolean | Tenant$blackoutsArgs<ExtArgs>
    cashPayments?: boolean | Tenant$cashPaymentsArgs<ExtArgs>
    commissionRecords?: boolean | Tenant$commissionRecordsArgs<ExtArgs>
    customerPaymentPreferences?: boolean | Tenant$customerPaymentPreferencesArgs<ExtArgs>
    venueOnboardingResponses?: boolean | Tenant$venueOnboardingResponsesArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      venues: Prisma.$VenuePayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      blackouts: Prisma.$BlackoutPayload<ExtArgs>[]
      cashPayments: Prisma.$CashPaymentPayload<ExtArgs>[]
      commissionRecords: Prisma.$CommissionRecordPayload<ExtArgs>[]
      customerPaymentPreferences: Prisma.$CustomerPaymentPreferencePayload<ExtArgs>[]
      venueOnboardingResponses: Prisma.$VenueOnboardingResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      settings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venues<T extends Tenant$venuesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$venuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends Tenant$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Tenant$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blackouts<T extends Tenant$blackoutsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$blackoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlackoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashPayments<T extends Tenant$cashPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$cashPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commissionRecords<T extends Tenant$commissionRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$commissionRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerPaymentPreferences<T extends Tenant$customerPaymentPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$customerPaymentPreferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPaymentPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    venueOnboardingResponses<T extends Tenant$venueOnboardingResponsesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$venueOnboardingResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenueOnboardingResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly slug: FieldRef<"Tenant", 'String'>
    readonly settings: FieldRef<"Tenant", 'Json'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.venues
   */
  export type Tenant$venuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    cursor?: VenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.bookings
   */
  export type Tenant$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Tenant.payments
   */
  export type Tenant$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Tenant.blackouts
   */
  export type Tenant$blackoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blackout
     */
    select?: BlackoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blackout
     */
    omit?: BlackoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlackoutInclude<ExtArgs> | null
    where?: BlackoutWhereInput
    orderBy?: BlackoutOrderByWithRelationInput | BlackoutOrderByWithRelationInput[]
    cursor?: BlackoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlackoutScalarFieldEnum | BlackoutScalarFieldEnum[]
  }

  /**
   * Tenant.cashPayments
   */
  export type Tenant$cashPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentInclude<ExtArgs> | null
    where?: CashPaymentWhereInput
    orderBy?: CashPaymentOrderByWithRelationInput | CashPaymentOrderByWithRelationInput[]
    cursor?: CashPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashPaymentScalarFieldEnum | CashPaymentScalarFieldEnum[]
  }

  /**
   * Tenant.commissionRecords
   */
  export type Tenant$commissionRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordInclude<ExtArgs> | null
    where?: CommissionRecordWhereInput
    orderBy?: CommissionRecordOrderByWithRelationInput | CommissionRecordOrderByWithRelationInput[]
    cursor?: CommissionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionRecordScalarFieldEnum | CommissionRecordScalarFieldEnum[]
  }

  /**
   * Tenant.customerPaymentPreferences
   */
  export type Tenant$customerPaymentPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentPreference
     */
    select?: CustomerPaymentPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentPreference
     */
    omit?: CustomerPaymentPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentPreferenceInclude<ExtArgs> | null
    where?: CustomerPaymentPreferenceWhereInput
    orderBy?: CustomerPaymentPreferenceOrderByWithRelationInput | CustomerPaymentPreferenceOrderByWithRelationInput[]
    cursor?: CustomerPaymentPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerPaymentPreferenceScalarFieldEnum | CustomerPaymentPreferenceScalarFieldEnum[]
  }

  /**
   * Tenant.venueOnboardingResponses
   */
  export type Tenant$venueOnboardingResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueOnboardingResponse
     */
    select?: VenueOnboardingResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueOnboardingResponse
     */
    omit?: VenueOnboardingResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueOnboardingResponseInclude<ExtArgs> | null
    where?: VenueOnboardingResponseWhereInput
    orderBy?: VenueOnboardingResponseOrderByWithRelationInput | VenueOnboardingResponseOrderByWithRelationInput[]
    cursor?: VenueOnboardingResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenueOnboardingResponseScalarFieldEnum | VenueOnboardingResponseScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model Venue
   */

  export type AggregateVenue = {
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  export type VenueAvgAggregateOutputType = {
    capacity: number | null
    basePriceCents: number | null
    cashDiscountPercentage: Decimal | null
    depositAmount: number | null
    platformCommissionPercentage: Decimal | null
    paymentDueDaysBeforeEvent: number | null
  }

  export type VenueSumAggregateOutputType = {
    capacity: number | null
    basePriceCents: number | null
    cashDiscountPercentage: Decimal | null
    depositAmount: number | null
    platformCommissionPercentage: Decimal | null
    paymentDueDaysBeforeEvent: number | null
  }

  export type VenueMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    address: string | null
    capacity: number | null
    basePriceCents: number | null
    currency: string | null
    timeZone: string | null
    isActive: boolean | null
    paymentProfile: string | null
    allowCashPayments: boolean | null
    cashDiscountPercentage: Decimal | null
    requiresOnlineDeposit: boolean | null
    depositType: string | null
    depositAmount: number | null
    hasRazorpayAccount: boolean | null
    razorpayKeyId: string | null
    razorpayKeySecretEncrypted: string | null
    platformHandlesPayments: boolean | null
    confirmationTrigger: string | null
    platformCommissionPercentage: Decimal | null
    paymentDueDaysBeforeEvent: number | null
    autoExpireUnpaidBookings: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenueMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    address: string | null
    capacity: number | null
    basePriceCents: number | null
    currency: string | null
    timeZone: string | null
    isActive: boolean | null
    paymentProfile: string | null
    allowCashPayments: boolean | null
    cashDiscountPercentage: Decimal | null
    requiresOnlineDeposit: boolean | null
    depositType: string | null
    depositAmount: number | null
    hasRazorpayAccount: boolean | null
    razorpayKeyId: string | null
    razorpayKeySecretEncrypted: string | null
    platformHandlesPayments: boolean | null
    confirmationTrigger: string | null
    platformCommissionPercentage: Decimal | null
    paymentDueDaysBeforeEvent: number | null
    autoExpireUnpaidBookings: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenueCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    address: number
    capacity: number
    basePriceCents: number
    currency: number
    timeZone: number
    settings: number
    isActive: number
    paymentProfile: number
    allowCashPayments: number
    cashDiscountPercentage: number
    requiresOnlineDeposit: number
    depositType: number
    depositAmount: number
    hasRazorpayAccount: number
    razorpayKeyId: number
    razorpayKeySecretEncrypted: number
    platformHandlesPayments: number
    confirmationTrigger: number
    platformCommissionPercentage: number
    paymentDueDaysBeforeEvent: number
    autoExpireUnpaidBookings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VenueAvgAggregateInputType = {
    capacity?: true
    basePriceCents?: true
    cashDiscountPercentage?: true
    depositAmount?: true
    platformCommissionPercentage?: true
    paymentDueDaysBeforeEvent?: true
  }

  export type VenueSumAggregateInputType = {
    capacity?: true
    basePriceCents?: true
    cashDiscountPercentage?: true
    depositAmount?: true
    platformCommissionPercentage?: true
    paymentDueDaysBeforeEvent?: true
  }

  export type VenueMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    address?: true
    capacity?: true
    basePriceCents?: true
    currency?: true
    timeZone?: true
    isActive?: true
    paymentProfile?: true
    allowCashPayments?: true
    cashDiscountPercentage?: true
    requiresOnlineDeposit?: true
    depositType?: true
    depositAmount?: true
    hasRazorpayAccount?: true
    razorpayKeyId?: true
    razorpayKeySecretEncrypted?: true
    platformHandlesPayments?: true
    confirmationTrigger?: true
    platformCommissionPercentage?: true
    paymentDueDaysBeforeEvent?: true
    autoExpireUnpaidBookings?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenueMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    address?: true
    capacity?: true
    basePriceCents?: true
    currency?: true
    timeZone?: true
    isActive?: true
    paymentProfile?: true
    allowCashPayments?: true
    cashDiscountPercentage?: true
    requiresOnlineDeposit?: true
    depositType?: true
    depositAmount?: true
    hasRazorpayAccount?: true
    razorpayKeyId?: true
    razorpayKeySecretEncrypted?: true
    platformHandlesPayments?: true
    confirmationTrigger?: true
    platformCommissionPercentage?: true
    paymentDueDaysBeforeEvent?: true
    autoExpireUnpaidBookings?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenueCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    address?: true
    capacity?: true
    basePriceCents?: true
    currency?: true
    timeZone?: true
    settings?: true
    isActive?: true
    paymentProfile?: true
    allowCashPayments?: true
    cashDiscountPercentage?: true
    requiresOnlineDeposit?: true
    depositType?: true
    depositAmount?: true
    hasRazorpayAccount?: true
    razorpayKeyId?: true
    razorpayKeySecretEncrypted?: true
    platformHandlesPayments?: true
    confirmationTrigger?: true
    platformCommissionPercentage?: true
    paymentDueDaysBeforeEvent?: true
    autoExpireUnpaidBookings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venue to aggregate.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Venues
    **/
    _count?: true | VenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenueMaxAggregateInputType
  }

  export type GetVenueAggregateType<T extends VenueAggregateArgs> = {
        [P in keyof T & keyof AggregateVenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenue[P]>
      : GetScalarType<T[P], AggregateVenue[P]>
  }




  export type VenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithAggregationInput | VenueOrderByWithAggregationInput[]
    by: VenueScalarFieldEnum[] | VenueScalarFieldEnum
    having?: VenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenueCountAggregateInputType | true
    _avg?: VenueAvgAggregateInputType
    _sum?: VenueSumAggregateInputType
    _min?: VenueMinAggregateInputType
    _max?: VenueMaxAggregateInputType
  }

  export type VenueGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    address: string | null
    capacity: number | null
    basePriceCents: number
    currency: string
    timeZone: string
    settings: JsonValue | null
    isActive: boolean
    paymentProfile: string
    allowCashPayments: boolean
    cashDiscountPercentage: Decimal | null
    requiresOnlineDeposit: boolean
    depositType: string
    depositAmount: number
    hasRazorpayAccount: boolean
    razorpayKeyId: string | null
    razorpayKeySecretEncrypted: string | null
    platformHandlesPayments: boolean
    confirmationTrigger: string
    platformCommissionPercentage: Decimal
    paymentDueDaysBeforeEvent: number
    autoExpireUnpaidBookings: boolean
    createdAt: Date
    updatedAt: Date
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  type GetVenueGroupByPayload<T extends VenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenueGroupByOutputType[P]>
            : GetScalarType<T[P], VenueGroupByOutputType[P]>
        }
      >
    >


  export type VenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    address?: boolean
    capacity?: boolean
    basePriceCents?: boolean
    currency?: boolean
    timeZone?: boolean
    settings?: boolean
    isActive?: boolean
    paymentProfile?: boolean
    allowCashPayments?: boolean
    cashDiscountPercentage?: boolean
    requiresOnlineDeposit?: boolean
    depositType?: boolean
    depositAmount?: boolean
    hasRazorpayAccount?: boolean
    razorpayKeyId?: boolean
    razorpayKeySecretEncrypted?: boolean
    platformHandlesPayments?: boolean
    confirmationTrigger?: boolean
    platformCommissionPercentage?: boolean
    paymentDueDaysBeforeEvent?: boolean
    autoExpireUnpaidBookings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    bookings?: boolean | Venue$bookingsArgs<ExtArgs>
    blackouts?: boolean | Venue$blackoutsArgs<ExtArgs>
    commissionRecords?: boolean | Venue$commissionRecordsArgs<ExtArgs>
    venueOnboardingResponses?: boolean | Venue$venueOnboardingResponsesArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    address?: boolean
    capacity?: boolean
    basePriceCents?: boolean
    currency?: boolean
    timeZone?: boolean
    settings?: boolean
    isActive?: boolean
    paymentProfile?: boolean
    allowCashPayments?: boolean
    cashDiscountPercentage?: boolean
    requiresOnlineDeposit?: boolean
    depositType?: boolean
    depositAmount?: boolean
    hasRazorpayAccount?: boolean
    razorpayKeyId?: boolean
    razorpayKeySecretEncrypted?: boolean
    platformHandlesPayments?: boolean
    confirmationTrigger?: boolean
    platformCommissionPercentage?: boolean
    paymentDueDaysBeforeEvent?: boolean
    autoExpireUnpaidBookings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    address?: boolean
    capacity?: boolean
    basePriceCents?: boolean
    currency?: boolean
    timeZone?: boolean
    settings?: boolean
    isActive?: boolean
    paymentProfile?: boolean
    allowCashPayments?: boolean
    cashDiscountPercentage?: boolean
    requiresOnlineDeposit?: boolean
    depositType?: boolean
    depositAmount?: boolean
    hasRazorpayAccount?: boolean
    razorpayKeyId?: boolean
    razorpayKeySecretEncrypted?: boolean
    platformHandlesPayments?: boolean
    confirmationTrigger?: boolean
    platformCommissionPercentage?: boolean
    paymentDueDaysBeforeEvent?: boolean
    autoExpireUnpaidBookings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    address?: boolean
    capacity?: boolean
    basePriceCents?: boolean
    currency?: boolean
    timeZone?: boolean
    settings?: boolean
    isActive?: boolean
    paymentProfile?: boolean
    allowCashPayments?: boolean
    cashDiscountPercentage?: boolean
    requiresOnlineDeposit?: boolean
    depositType?: boolean
    depositAmount?: boolean
    hasRazorpayAccount?: boolean
    razorpayKeyId?: boolean
    razorpayKeySecretEncrypted?: boolean
    platformHandlesPayments?: boolean
    confirmationTrigger?: boolean
    platformCommissionPercentage?: boolean
    paymentDueDaysBeforeEvent?: boolean
    autoExpireUnpaidBookings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VenueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "address" | "capacity" | "basePriceCents" | "currency" | "timeZone" | "settings" | "isActive" | "paymentProfile" | "allowCashPayments" | "cashDiscountPercentage" | "requiresOnlineDeposit" | "depositType" | "depositAmount" | "hasRazorpayAccount" | "razorpayKeyId" | "razorpayKeySecretEncrypted" | "platformHandlesPayments" | "confirmationTrigger" | "platformCommissionPercentage" | "paymentDueDaysBeforeEvent" | "autoExpireUnpaidBookings" | "createdAt" | "updatedAt", ExtArgs["result"]["venue"]>
  export type VenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    bookings?: boolean | Venue$bookingsArgs<ExtArgs>
    blackouts?: boolean | Venue$blackoutsArgs<ExtArgs>
    commissionRecords?: boolean | Venue$commissionRecordsArgs<ExtArgs>
    venueOnboardingResponses?: boolean | Venue$venueOnboardingResponsesArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VenueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type VenueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $VenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Venue"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      blackouts: Prisma.$BlackoutPayload<ExtArgs>[]
      commissionRecords: Prisma.$CommissionRecordPayload<ExtArgs>[]
      venueOnboardingResponses: Prisma.$VenueOnboardingResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      address: string | null
      capacity: number | null
      basePriceCents: number
      currency: string
      timeZone: string
      settings: Prisma.JsonValue | null
      isActive: boolean
      paymentProfile: string
      allowCashPayments: boolean
      cashDiscountPercentage: Prisma.Decimal | null
      requiresOnlineDeposit: boolean
      depositType: string
      depositAmount: number
      hasRazorpayAccount: boolean
      razorpayKeyId: string | null
      razorpayKeySecretEncrypted: string | null
      platformHandlesPayments: boolean
      confirmationTrigger: string
      platformCommissionPercentage: Prisma.Decimal
      paymentDueDaysBeforeEvent: number
      autoExpireUnpaidBookings: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["venue"]>
    composites: {}
  }

  type VenueGetPayload<S extends boolean | null | undefined | VenueDefaultArgs> = $Result.GetResult<Prisma.$VenuePayload, S>

  type VenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VenueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VenueCountAggregateInputType | true
    }

  export interface VenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Venue'], meta: { name: 'Venue' } }
    /**
     * Find zero or one Venue that matches the filter.
     * @param {VenueFindUniqueArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenueFindUniqueArgs>(args: SelectSubset<T, VenueFindUniqueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Venue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VenueFindUniqueOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenueFindUniqueOrThrowArgs>(args: SelectSubset<T, VenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Venue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenueFindFirstArgs>(args?: SelectSubset<T, VenueFindFirstArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Venue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenueFindFirstOrThrowArgs>(args?: SelectSubset<T, VenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Venues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Venues
     * const venues = await prisma.venue.findMany()
     * 
     * // Get first 10 Venues
     * const venues = await prisma.venue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venueWithIdOnly = await prisma.venue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VenueFindManyArgs>(args?: SelectSubset<T, VenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Venue.
     * @param {VenueCreateArgs} args - Arguments to create a Venue.
     * @example
     * // Create one Venue
     * const Venue = await prisma.venue.create({
     *   data: {
     *     // ... data to create a Venue
     *   }
     * })
     * 
     */
    create<T extends VenueCreateArgs>(args: SelectSubset<T, VenueCreateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Venues.
     * @param {VenueCreateManyArgs} args - Arguments to create many Venues.
     * @example
     * // Create many Venues
     * const venue = await prisma.venue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenueCreateManyArgs>(args?: SelectSubset<T, VenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Venues and returns the data saved in the database.
     * @param {VenueCreateManyAndReturnArgs} args - Arguments to create many Venues.
     * @example
     * // Create many Venues
     * const venue = await prisma.venue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Venues and only return the `id`
     * const venueWithIdOnly = await prisma.venue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VenueCreateManyAndReturnArgs>(args?: SelectSubset<T, VenueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Venue.
     * @param {VenueDeleteArgs} args - Arguments to delete one Venue.
     * @example
     * // Delete one Venue
     * const Venue = await prisma.venue.delete({
     *   where: {
     *     // ... filter to delete one Venue
     *   }
     * })
     * 
     */
    delete<T extends VenueDeleteArgs>(args: SelectSubset<T, VenueDeleteArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Venue.
     * @param {VenueUpdateArgs} args - Arguments to update one Venue.
     * @example
     * // Update one Venue
     * const venue = await prisma.venue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenueUpdateArgs>(args: SelectSubset<T, VenueUpdateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Venues.
     * @param {VenueDeleteManyArgs} args - Arguments to filter Venues to delete.
     * @example
     * // Delete a few Venues
     * const { count } = await prisma.venue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenueDeleteManyArgs>(args?: SelectSubset<T, VenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Venues
     * const venue = await prisma.venue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenueUpdateManyArgs>(args: SelectSubset<T, VenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venues and returns the data updated in the database.
     * @param {VenueUpdateManyAndReturnArgs} args - Arguments to update many Venues.
     * @example
     * // Update many Venues
     * const venue = await prisma.venue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Venues and only return the `id`
     * const venueWithIdOnly = await prisma.venue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VenueUpdateManyAndReturnArgs>(args: SelectSubset<T, VenueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Venue.
     * @param {VenueUpsertArgs} args - Arguments to update or create a Venue.
     * @example
     * // Update or create a Venue
     * const venue = await prisma.venue.upsert({
     *   create: {
     *     // ... data to create a Venue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Venue we want to update
     *   }
     * })
     */
    upsert<T extends VenueUpsertArgs>(args: SelectSubset<T, VenueUpsertArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueCountArgs} args - Arguments to filter Venues to count.
     * @example
     * // Count the number of Venues
     * const count = await prisma.venue.count({
     *   where: {
     *     // ... the filter for the Venues we want to count
     *   }
     * })
    **/
    count<T extends VenueCountArgs>(
      args?: Subset<T, VenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenueAggregateArgs>(args: Subset<T, VenueAggregateArgs>): Prisma.PrismaPromise<GetVenueAggregateType<T>>

    /**
     * Group by Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenueGroupByArgs['orderBy'] }
        : { orderBy?: VenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Venue model
   */
  readonly fields: VenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Venue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends Venue$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blackouts<T extends Venue$blackoutsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$blackoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlackoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commissionRecords<T extends Venue$commissionRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$commissionRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    venueOnboardingResponses<T extends Venue$venueOnboardingResponsesArgs<ExtArgs> = {}>(args?: Subset<T, Venue$venueOnboardingResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenueOnboardingResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Venue model
   */
  interface VenueFieldRefs {
    readonly id: FieldRef<"Venue", 'String'>
    readonly tenantId: FieldRef<"Venue", 'String'>
    readonly name: FieldRef<"Venue", 'String'>
    readonly address: FieldRef<"Venue", 'String'>
    readonly capacity: FieldRef<"Venue", 'Int'>
    readonly basePriceCents: FieldRef<"Venue", 'Int'>
    readonly currency: FieldRef<"Venue", 'String'>
    readonly timeZone: FieldRef<"Venue", 'String'>
    readonly settings: FieldRef<"Venue", 'Json'>
    readonly isActive: FieldRef<"Venue", 'Boolean'>
    readonly paymentProfile: FieldRef<"Venue", 'String'>
    readonly allowCashPayments: FieldRef<"Venue", 'Boolean'>
    readonly cashDiscountPercentage: FieldRef<"Venue", 'Decimal'>
    readonly requiresOnlineDeposit: FieldRef<"Venue", 'Boolean'>
    readonly depositType: FieldRef<"Venue", 'String'>
    readonly depositAmount: FieldRef<"Venue", 'Int'>
    readonly hasRazorpayAccount: FieldRef<"Venue", 'Boolean'>
    readonly razorpayKeyId: FieldRef<"Venue", 'String'>
    readonly razorpayKeySecretEncrypted: FieldRef<"Venue", 'String'>
    readonly platformHandlesPayments: FieldRef<"Venue", 'Boolean'>
    readonly confirmationTrigger: FieldRef<"Venue", 'String'>
    readonly platformCommissionPercentage: FieldRef<"Venue", 'Decimal'>
    readonly paymentDueDaysBeforeEvent: FieldRef<"Venue", 'Int'>
    readonly autoExpireUnpaidBookings: FieldRef<"Venue", 'Boolean'>
    readonly createdAt: FieldRef<"Venue", 'DateTime'>
    readonly updatedAt: FieldRef<"Venue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Venue findUnique
   */
  export type VenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findUniqueOrThrow
   */
  export type VenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findFirst
   */
  export type VenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findFirstOrThrow
   */
  export type VenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findMany
   */
  export type VenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venues to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue create
   */
  export type VenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to create a Venue.
     */
    data: XOR<VenueCreateInput, VenueUncheckedCreateInput>
  }

  /**
   * Venue createMany
   */
  export type VenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Venues.
     */
    data: VenueCreateManyInput | VenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Venue createManyAndReturn
   */
  export type VenueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * The data used to create many Venues.
     */
    data: VenueCreateManyInput | VenueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Venue update
   */
  export type VenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to update a Venue.
     */
    data: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
    /**
     * Choose, which Venue to update.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue updateMany
   */
  export type VenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Venues.
     */
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyInput>
    /**
     * Filter which Venues to update
     */
    where?: VenueWhereInput
    /**
     * Limit how many Venues to update.
     */
    limit?: number
  }

  /**
   * Venue updateManyAndReturn
   */
  export type VenueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * The data used to update Venues.
     */
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyInput>
    /**
     * Filter which Venues to update
     */
    where?: VenueWhereInput
    /**
     * Limit how many Venues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Venue upsert
   */
  export type VenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The filter to search for the Venue to update in case it exists.
     */
    where: VenueWhereUniqueInput
    /**
     * In case the Venue found by the `where` argument doesn't exist, create a new Venue with this data.
     */
    create: XOR<VenueCreateInput, VenueUncheckedCreateInput>
    /**
     * In case the Venue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
  }

  /**
   * Venue delete
   */
  export type VenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter which Venue to delete.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue deleteMany
   */
  export type VenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venues to delete
     */
    where?: VenueWhereInput
    /**
     * Limit how many Venues to delete.
     */
    limit?: number
  }

  /**
   * Venue.bookings
   */
  export type Venue$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Venue.blackouts
   */
  export type Venue$blackoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blackout
     */
    select?: BlackoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blackout
     */
    omit?: BlackoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlackoutInclude<ExtArgs> | null
    where?: BlackoutWhereInput
    orderBy?: BlackoutOrderByWithRelationInput | BlackoutOrderByWithRelationInput[]
    cursor?: BlackoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlackoutScalarFieldEnum | BlackoutScalarFieldEnum[]
  }

  /**
   * Venue.commissionRecords
   */
  export type Venue$commissionRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordInclude<ExtArgs> | null
    where?: CommissionRecordWhereInput
    orderBy?: CommissionRecordOrderByWithRelationInput | CommissionRecordOrderByWithRelationInput[]
    cursor?: CommissionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionRecordScalarFieldEnum | CommissionRecordScalarFieldEnum[]
  }

  /**
   * Venue.venueOnboardingResponses
   */
  export type Venue$venueOnboardingResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueOnboardingResponse
     */
    select?: VenueOnboardingResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueOnboardingResponse
     */
    omit?: VenueOnboardingResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueOnboardingResponseInclude<ExtArgs> | null
    where?: VenueOnboardingResponseWhereInput
    orderBy?: VenueOnboardingResponseOrderByWithRelationInput | VenueOnboardingResponseOrderByWithRelationInput[]
    cursor?: VenueOnboardingResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenueOnboardingResponseScalarFieldEnum | VenueOnboardingResponseScalarFieldEnum[]
  }

  /**
   * Venue without action
   */
  export type VenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    phone: string | null
    email: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    phone: string | null
    email: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    phone: number
    email: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    phone?: true
    email?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    phone?: true
    email?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    phone?: true
    email?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    phone: string
    email: string | null
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    confirmedBookings?: boolean | User$confirmedBookingsArgs<ExtArgs>
    cashPaymentsRecorded?: boolean | User$cashPaymentsRecordedArgs<ExtArgs>
    customerPaymentPreferences?: boolean | User$customerPaymentPreferencesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "phone" | "email" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    confirmedBookings?: boolean | User$confirmedBookingsArgs<ExtArgs>
    cashPaymentsRecorded?: boolean | User$cashPaymentsRecordedArgs<ExtArgs>
    customerPaymentPreferences?: boolean | User$customerPaymentPreferencesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      confirmedBookings: Prisma.$BookingPayload<ExtArgs>[]
      cashPaymentsRecorded: Prisma.$CashPaymentPayload<ExtArgs>[]
      customerPaymentPreferences: Prisma.$CustomerPaymentPreferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      phone: string
      email: string | null
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    confirmedBookings<T extends User$confirmedBookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$confirmedBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashPaymentsRecorded<T extends User$cashPaymentsRecordedArgs<ExtArgs> = {}>(args?: Subset<T, User$cashPaymentsRecordedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerPaymentPreferences<T extends User$customerPaymentPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$customerPaymentPreferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPaymentPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.confirmedBookings
   */
  export type User$confirmedBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.cashPaymentsRecorded
   */
  export type User$cashPaymentsRecordedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentInclude<ExtArgs> | null
    where?: CashPaymentWhereInput
    orderBy?: CashPaymentOrderByWithRelationInput | CashPaymentOrderByWithRelationInput[]
    cursor?: CashPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashPaymentScalarFieldEnum | CashPaymentScalarFieldEnum[]
  }

  /**
   * User.customerPaymentPreferences
   */
  export type User$customerPaymentPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentPreference
     */
    select?: CustomerPaymentPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentPreference
     */
    omit?: CustomerPaymentPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentPreferenceInclude<ExtArgs> | null
    where?: CustomerPaymentPreferenceWhereInput
    orderBy?: CustomerPaymentPreferenceOrderByWithRelationInput | CustomerPaymentPreferenceOrderByWithRelationInput[]
    cursor?: CustomerPaymentPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerPaymentPreferenceScalarFieldEnum | CustomerPaymentPreferenceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    totalAmountCents: number | null
    onlineAmountDue: number | null
    cashAmountDue: number | null
    cashDiscountApplied: number | null
    guestCount: number | null
  }

  export type BookingSumAggregateOutputType = {
    totalAmountCents: number | null
    onlineAmountDue: number | null
    cashAmountDue: number | null
    cashDiscountApplied: number | null
    guestCount: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    venueId: string | null
    userId: string | null
    bookingNumber: string | null
    startTs: Date | null
    endTs: Date | null
    status: string | null
    holdExpiresAt: Date | null
    totalAmountCents: number | null
    currency: string | null
    paymentStatus: string | null
    paymentMethod: string | null
    onlineAmountDue: number | null
    cashAmountDue: number | null
    cashDiscountApplied: number | null
    paymentDueDate: Date | null
    cashPaymentAcknowledged: boolean | null
    requiresManualConfirmation: boolean | null
    confirmedBy: string | null
    idempotencyKey: string | null
    eventType: string | null
    guestCount: number | null
    specialRequests: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    venueId: string | null
    userId: string | null
    bookingNumber: string | null
    startTs: Date | null
    endTs: Date | null
    status: string | null
    holdExpiresAt: Date | null
    totalAmountCents: number | null
    currency: string | null
    paymentStatus: string | null
    paymentMethod: string | null
    onlineAmountDue: number | null
    cashAmountDue: number | null
    cashDiscountApplied: number | null
    paymentDueDate: Date | null
    cashPaymentAcknowledged: boolean | null
    requiresManualConfirmation: boolean | null
    confirmedBy: string | null
    idempotencyKey: string | null
    eventType: string | null
    guestCount: number | null
    specialRequests: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    tenantId: number
    venueId: number
    userId: number
    bookingNumber: number
    startTs: number
    endTs: number
    status: number
    holdExpiresAt: number
    totalAmountCents: number
    currency: number
    paymentStatus: number
    paymentMethod: number
    onlineAmountDue: number
    cashAmountDue: number
    cashDiscountApplied: number
    paymentDueDate: number
    cashPaymentAcknowledged: number
    requiresManualConfirmation: number
    confirmedBy: number
    idempotencyKey: number
    eventType: number
    guestCount: number
    specialRequests: number
    meta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    totalAmountCents?: true
    onlineAmountDue?: true
    cashAmountDue?: true
    cashDiscountApplied?: true
    guestCount?: true
  }

  export type BookingSumAggregateInputType = {
    totalAmountCents?: true
    onlineAmountDue?: true
    cashAmountDue?: true
    cashDiscountApplied?: true
    guestCount?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    tenantId?: true
    venueId?: true
    userId?: true
    bookingNumber?: true
    startTs?: true
    endTs?: true
    status?: true
    holdExpiresAt?: true
    totalAmountCents?: true
    currency?: true
    paymentStatus?: true
    paymentMethod?: true
    onlineAmountDue?: true
    cashAmountDue?: true
    cashDiscountApplied?: true
    paymentDueDate?: true
    cashPaymentAcknowledged?: true
    requiresManualConfirmation?: true
    confirmedBy?: true
    idempotencyKey?: true
    eventType?: true
    guestCount?: true
    specialRequests?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    tenantId?: true
    venueId?: true
    userId?: true
    bookingNumber?: true
    startTs?: true
    endTs?: true
    status?: true
    holdExpiresAt?: true
    totalAmountCents?: true
    currency?: true
    paymentStatus?: true
    paymentMethod?: true
    onlineAmountDue?: true
    cashAmountDue?: true
    cashDiscountApplied?: true
    paymentDueDate?: true
    cashPaymentAcknowledged?: true
    requiresManualConfirmation?: true
    confirmedBy?: true
    idempotencyKey?: true
    eventType?: true
    guestCount?: true
    specialRequests?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    tenantId?: true
    venueId?: true
    userId?: true
    bookingNumber?: true
    startTs?: true
    endTs?: true
    status?: true
    holdExpiresAt?: true
    totalAmountCents?: true
    currency?: true
    paymentStatus?: true
    paymentMethod?: true
    onlineAmountDue?: true
    cashAmountDue?: true
    cashDiscountApplied?: true
    paymentDueDate?: true
    cashPaymentAcknowledged?: true
    requiresManualConfirmation?: true
    confirmedBy?: true
    idempotencyKey?: true
    eventType?: true
    guestCount?: true
    specialRequests?: true
    meta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    tenantId: string
    venueId: string
    userId: string
    bookingNumber: string
    startTs: Date
    endTs: Date
    status: string
    holdExpiresAt: Date | null
    totalAmountCents: number | null
    currency: string
    paymentStatus: string
    paymentMethod: string | null
    onlineAmountDue: number
    cashAmountDue: number
    cashDiscountApplied: number
    paymentDueDate: Date | null
    cashPaymentAcknowledged: boolean
    requiresManualConfirmation: boolean
    confirmedBy: string | null
    idempotencyKey: string | null
    eventType: string | null
    guestCount: number | null
    specialRequests: string | null
    meta: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    venueId?: boolean
    userId?: boolean
    bookingNumber?: boolean
    startTs?: boolean
    endTs?: boolean
    status?: boolean
    holdExpiresAt?: boolean
    totalAmountCents?: boolean
    currency?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    onlineAmountDue?: boolean
    cashAmountDue?: boolean
    cashDiscountApplied?: boolean
    paymentDueDate?: boolean
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: boolean
    idempotencyKey?: boolean
    eventType?: boolean
    guestCount?: boolean
    specialRequests?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    confirmedByUser?: boolean | Booking$confirmedByUserArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    cashPayments?: boolean | Booking$cashPaymentsArgs<ExtArgs>
    commissionRecord?: boolean | Booking$commissionRecordArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    venueId?: boolean
    userId?: boolean
    bookingNumber?: boolean
    startTs?: boolean
    endTs?: boolean
    status?: boolean
    holdExpiresAt?: boolean
    totalAmountCents?: boolean
    currency?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    onlineAmountDue?: boolean
    cashAmountDue?: boolean
    cashDiscountApplied?: boolean
    paymentDueDate?: boolean
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: boolean
    idempotencyKey?: boolean
    eventType?: boolean
    guestCount?: boolean
    specialRequests?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    confirmedByUser?: boolean | Booking$confirmedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    venueId?: boolean
    userId?: boolean
    bookingNumber?: boolean
    startTs?: boolean
    endTs?: boolean
    status?: boolean
    holdExpiresAt?: boolean
    totalAmountCents?: boolean
    currency?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    onlineAmountDue?: boolean
    cashAmountDue?: boolean
    cashDiscountApplied?: boolean
    paymentDueDate?: boolean
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: boolean
    idempotencyKey?: boolean
    eventType?: boolean
    guestCount?: boolean
    specialRequests?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    confirmedByUser?: boolean | Booking$confirmedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    tenantId?: boolean
    venueId?: boolean
    userId?: boolean
    bookingNumber?: boolean
    startTs?: boolean
    endTs?: boolean
    status?: boolean
    holdExpiresAt?: boolean
    totalAmountCents?: boolean
    currency?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    onlineAmountDue?: boolean
    cashAmountDue?: boolean
    cashDiscountApplied?: boolean
    paymentDueDate?: boolean
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: boolean
    idempotencyKey?: boolean
    eventType?: boolean
    guestCount?: boolean
    specialRequests?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "venueId" | "userId" | "bookingNumber" | "startTs" | "endTs" | "status" | "holdExpiresAt" | "totalAmountCents" | "currency" | "paymentStatus" | "paymentMethod" | "onlineAmountDue" | "cashAmountDue" | "cashDiscountApplied" | "paymentDueDate" | "cashPaymentAcknowledged" | "requiresManualConfirmation" | "confirmedBy" | "idempotencyKey" | "eventType" | "guestCount" | "specialRequests" | "meta" | "createdAt" | "updatedAt", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    confirmedByUser?: boolean | Booking$confirmedByUserArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    cashPayments?: boolean | Booking$cashPaymentsArgs<ExtArgs>
    commissionRecord?: boolean | Booking$commissionRecordArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    confirmedByUser?: boolean | Booking$confirmedByUserArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    confirmedByUser?: boolean | Booking$confirmedByUserArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      confirmedByUser: Prisma.$UserPayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      cashPayments: Prisma.$CashPaymentPayload<ExtArgs>[]
      commissionRecord: Prisma.$CommissionRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      venueId: string
      userId: string
      bookingNumber: string
      startTs: Date
      endTs: Date
      status: string
      holdExpiresAt: Date | null
      totalAmountCents: number | null
      currency: string
      paymentStatus: string
      paymentMethod: string | null
      onlineAmountDue: number
      cashAmountDue: number
      cashDiscountApplied: number
      paymentDueDate: Date | null
      cashPaymentAcknowledged: boolean
      requiresManualConfirmation: boolean
      confirmedBy: string | null
      idempotencyKey: string | null
      eventType: string | null
      guestCount: number | null
      specialRequests: string | null
      meta: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    confirmedByUser<T extends Booking$confirmedByUserArgs<ExtArgs> = {}>(args?: Subset<T, Booking$confirmedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends Booking$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashPayments<T extends Booking$cashPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$cashPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commissionRecord<T extends Booking$commissionRecordArgs<ExtArgs> = {}>(args?: Subset<T, Booking$commissionRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly tenantId: FieldRef<"Booking", 'String'>
    readonly venueId: FieldRef<"Booking", 'String'>
    readonly userId: FieldRef<"Booking", 'String'>
    readonly bookingNumber: FieldRef<"Booking", 'String'>
    readonly startTs: FieldRef<"Booking", 'DateTime'>
    readonly endTs: FieldRef<"Booking", 'DateTime'>
    readonly status: FieldRef<"Booking", 'String'>
    readonly holdExpiresAt: FieldRef<"Booking", 'DateTime'>
    readonly totalAmountCents: FieldRef<"Booking", 'Int'>
    readonly currency: FieldRef<"Booking", 'String'>
    readonly paymentStatus: FieldRef<"Booking", 'String'>
    readonly paymentMethod: FieldRef<"Booking", 'String'>
    readonly onlineAmountDue: FieldRef<"Booking", 'Int'>
    readonly cashAmountDue: FieldRef<"Booking", 'Int'>
    readonly cashDiscountApplied: FieldRef<"Booking", 'Int'>
    readonly paymentDueDate: FieldRef<"Booking", 'DateTime'>
    readonly cashPaymentAcknowledged: FieldRef<"Booking", 'Boolean'>
    readonly requiresManualConfirmation: FieldRef<"Booking", 'Boolean'>
    readonly confirmedBy: FieldRef<"Booking", 'String'>
    readonly idempotencyKey: FieldRef<"Booking", 'String'>
    readonly eventType: FieldRef<"Booking", 'String'>
    readonly guestCount: FieldRef<"Booking", 'Int'>
    readonly specialRequests: FieldRef<"Booking", 'String'>
    readonly meta: FieldRef<"Booking", 'Json'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.confirmedByUser
   */
  export type Booking$confirmedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Booking.payments
   */
  export type Booking$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Booking.cashPayments
   */
  export type Booking$cashPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentInclude<ExtArgs> | null
    where?: CashPaymentWhereInput
    orderBy?: CashPaymentOrderByWithRelationInput | CashPaymentOrderByWithRelationInput[]
    cursor?: CashPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashPaymentScalarFieldEnum | CashPaymentScalarFieldEnum[]
  }

  /**
   * Booking.commissionRecord
   */
  export type Booking$commissionRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordInclude<ExtArgs> | null
    where?: CommissionRecordWhereInput
    orderBy?: CommissionRecordOrderByWithRelationInput | CommissionRecordOrderByWithRelationInput[]
    cursor?: CommissionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionRecordScalarFieldEnum | CommissionRecordScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Blackout
   */

  export type AggregateBlackout = {
    _count: BlackoutCountAggregateOutputType | null
    _min: BlackoutMinAggregateOutputType | null
    _max: BlackoutMaxAggregateOutputType | null
  }

  export type BlackoutMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    venueId: string | null
    startTs: Date | null
    endTs: Date | null
    reason: string | null
    isMaintenance: boolean | null
    createdAt: Date | null
  }

  export type BlackoutMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    venueId: string | null
    startTs: Date | null
    endTs: Date | null
    reason: string | null
    isMaintenance: boolean | null
    createdAt: Date | null
  }

  export type BlackoutCountAggregateOutputType = {
    id: number
    tenantId: number
    venueId: number
    startTs: number
    endTs: number
    reason: number
    isMaintenance: number
    createdAt: number
    _all: number
  }


  export type BlackoutMinAggregateInputType = {
    id?: true
    tenantId?: true
    venueId?: true
    startTs?: true
    endTs?: true
    reason?: true
    isMaintenance?: true
    createdAt?: true
  }

  export type BlackoutMaxAggregateInputType = {
    id?: true
    tenantId?: true
    venueId?: true
    startTs?: true
    endTs?: true
    reason?: true
    isMaintenance?: true
    createdAt?: true
  }

  export type BlackoutCountAggregateInputType = {
    id?: true
    tenantId?: true
    venueId?: true
    startTs?: true
    endTs?: true
    reason?: true
    isMaintenance?: true
    createdAt?: true
    _all?: true
  }

  export type BlackoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blackout to aggregate.
     */
    where?: BlackoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blackouts to fetch.
     */
    orderBy?: BlackoutOrderByWithRelationInput | BlackoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlackoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blackouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blackouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blackouts
    **/
    _count?: true | BlackoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlackoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlackoutMaxAggregateInputType
  }

  export type GetBlackoutAggregateType<T extends BlackoutAggregateArgs> = {
        [P in keyof T & keyof AggregateBlackout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlackout[P]>
      : GetScalarType<T[P], AggregateBlackout[P]>
  }




  export type BlackoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlackoutWhereInput
    orderBy?: BlackoutOrderByWithAggregationInput | BlackoutOrderByWithAggregationInput[]
    by: BlackoutScalarFieldEnum[] | BlackoutScalarFieldEnum
    having?: BlackoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlackoutCountAggregateInputType | true
    _min?: BlackoutMinAggregateInputType
    _max?: BlackoutMaxAggregateInputType
  }

  export type BlackoutGroupByOutputType = {
    id: string
    tenantId: string
    venueId: string
    startTs: Date
    endTs: Date
    reason: string | null
    isMaintenance: boolean
    createdAt: Date
    _count: BlackoutCountAggregateOutputType | null
    _min: BlackoutMinAggregateOutputType | null
    _max: BlackoutMaxAggregateOutputType | null
  }

  type GetBlackoutGroupByPayload<T extends BlackoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlackoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlackoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlackoutGroupByOutputType[P]>
            : GetScalarType<T[P], BlackoutGroupByOutputType[P]>
        }
      >
    >


  export type BlackoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    venueId?: boolean
    startTs?: boolean
    endTs?: boolean
    reason?: boolean
    isMaintenance?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blackout"]>

  export type BlackoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    venueId?: boolean
    startTs?: boolean
    endTs?: boolean
    reason?: boolean
    isMaintenance?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blackout"]>

  export type BlackoutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    venueId?: boolean
    startTs?: boolean
    endTs?: boolean
    reason?: boolean
    isMaintenance?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blackout"]>

  export type BlackoutSelectScalar = {
    id?: boolean
    tenantId?: boolean
    venueId?: boolean
    startTs?: boolean
    endTs?: boolean
    reason?: boolean
    isMaintenance?: boolean
    createdAt?: boolean
  }

  export type BlackoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "venueId" | "startTs" | "endTs" | "reason" | "isMaintenance" | "createdAt", ExtArgs["result"]["blackout"]>
  export type BlackoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }
  export type BlackoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }
  export type BlackoutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $BlackoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Blackout"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      venueId: string
      startTs: Date
      endTs: Date
      reason: string | null
      isMaintenance: boolean
      createdAt: Date
    }, ExtArgs["result"]["blackout"]>
    composites: {}
  }

  type BlackoutGetPayload<S extends boolean | null | undefined | BlackoutDefaultArgs> = $Result.GetResult<Prisma.$BlackoutPayload, S>

  type BlackoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlackoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlackoutCountAggregateInputType | true
    }

  export interface BlackoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Blackout'], meta: { name: 'Blackout' } }
    /**
     * Find zero or one Blackout that matches the filter.
     * @param {BlackoutFindUniqueArgs} args - Arguments to find a Blackout
     * @example
     * // Get one Blackout
     * const blackout = await prisma.blackout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlackoutFindUniqueArgs>(args: SelectSubset<T, BlackoutFindUniqueArgs<ExtArgs>>): Prisma__BlackoutClient<$Result.GetResult<Prisma.$BlackoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blackout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlackoutFindUniqueOrThrowArgs} args - Arguments to find a Blackout
     * @example
     * // Get one Blackout
     * const blackout = await prisma.blackout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlackoutFindUniqueOrThrowArgs>(args: SelectSubset<T, BlackoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlackoutClient<$Result.GetResult<Prisma.$BlackoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blackout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlackoutFindFirstArgs} args - Arguments to find a Blackout
     * @example
     * // Get one Blackout
     * const blackout = await prisma.blackout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlackoutFindFirstArgs>(args?: SelectSubset<T, BlackoutFindFirstArgs<ExtArgs>>): Prisma__BlackoutClient<$Result.GetResult<Prisma.$BlackoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blackout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlackoutFindFirstOrThrowArgs} args - Arguments to find a Blackout
     * @example
     * // Get one Blackout
     * const blackout = await prisma.blackout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlackoutFindFirstOrThrowArgs>(args?: SelectSubset<T, BlackoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlackoutClient<$Result.GetResult<Prisma.$BlackoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blackouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlackoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blackouts
     * const blackouts = await prisma.blackout.findMany()
     * 
     * // Get first 10 Blackouts
     * const blackouts = await prisma.blackout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blackoutWithIdOnly = await prisma.blackout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlackoutFindManyArgs>(args?: SelectSubset<T, BlackoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlackoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blackout.
     * @param {BlackoutCreateArgs} args - Arguments to create a Blackout.
     * @example
     * // Create one Blackout
     * const Blackout = await prisma.blackout.create({
     *   data: {
     *     // ... data to create a Blackout
     *   }
     * })
     * 
     */
    create<T extends BlackoutCreateArgs>(args: SelectSubset<T, BlackoutCreateArgs<ExtArgs>>): Prisma__BlackoutClient<$Result.GetResult<Prisma.$BlackoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blackouts.
     * @param {BlackoutCreateManyArgs} args - Arguments to create many Blackouts.
     * @example
     * // Create many Blackouts
     * const blackout = await prisma.blackout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlackoutCreateManyArgs>(args?: SelectSubset<T, BlackoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blackouts and returns the data saved in the database.
     * @param {BlackoutCreateManyAndReturnArgs} args - Arguments to create many Blackouts.
     * @example
     * // Create many Blackouts
     * const blackout = await prisma.blackout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blackouts and only return the `id`
     * const blackoutWithIdOnly = await prisma.blackout.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlackoutCreateManyAndReturnArgs>(args?: SelectSubset<T, BlackoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlackoutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Blackout.
     * @param {BlackoutDeleteArgs} args - Arguments to delete one Blackout.
     * @example
     * // Delete one Blackout
     * const Blackout = await prisma.blackout.delete({
     *   where: {
     *     // ... filter to delete one Blackout
     *   }
     * })
     * 
     */
    delete<T extends BlackoutDeleteArgs>(args: SelectSubset<T, BlackoutDeleteArgs<ExtArgs>>): Prisma__BlackoutClient<$Result.GetResult<Prisma.$BlackoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blackout.
     * @param {BlackoutUpdateArgs} args - Arguments to update one Blackout.
     * @example
     * // Update one Blackout
     * const blackout = await prisma.blackout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlackoutUpdateArgs>(args: SelectSubset<T, BlackoutUpdateArgs<ExtArgs>>): Prisma__BlackoutClient<$Result.GetResult<Prisma.$BlackoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blackouts.
     * @param {BlackoutDeleteManyArgs} args - Arguments to filter Blackouts to delete.
     * @example
     * // Delete a few Blackouts
     * const { count } = await prisma.blackout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlackoutDeleteManyArgs>(args?: SelectSubset<T, BlackoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blackouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlackoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blackouts
     * const blackout = await prisma.blackout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlackoutUpdateManyArgs>(args: SelectSubset<T, BlackoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blackouts and returns the data updated in the database.
     * @param {BlackoutUpdateManyAndReturnArgs} args - Arguments to update many Blackouts.
     * @example
     * // Update many Blackouts
     * const blackout = await prisma.blackout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blackouts and only return the `id`
     * const blackoutWithIdOnly = await prisma.blackout.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlackoutUpdateManyAndReturnArgs>(args: SelectSubset<T, BlackoutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlackoutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Blackout.
     * @param {BlackoutUpsertArgs} args - Arguments to update or create a Blackout.
     * @example
     * // Update or create a Blackout
     * const blackout = await prisma.blackout.upsert({
     *   create: {
     *     // ... data to create a Blackout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blackout we want to update
     *   }
     * })
     */
    upsert<T extends BlackoutUpsertArgs>(args: SelectSubset<T, BlackoutUpsertArgs<ExtArgs>>): Prisma__BlackoutClient<$Result.GetResult<Prisma.$BlackoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blackouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlackoutCountArgs} args - Arguments to filter Blackouts to count.
     * @example
     * // Count the number of Blackouts
     * const count = await prisma.blackout.count({
     *   where: {
     *     // ... the filter for the Blackouts we want to count
     *   }
     * })
    **/
    count<T extends BlackoutCountArgs>(
      args?: Subset<T, BlackoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlackoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blackout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlackoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlackoutAggregateArgs>(args: Subset<T, BlackoutAggregateArgs>): Prisma.PrismaPromise<GetBlackoutAggregateType<T>>

    /**
     * Group by Blackout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlackoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlackoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlackoutGroupByArgs['orderBy'] }
        : { orderBy?: BlackoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlackoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlackoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Blackout model
   */
  readonly fields: BlackoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blackout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlackoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Blackout model
   */
  interface BlackoutFieldRefs {
    readonly id: FieldRef<"Blackout", 'String'>
    readonly tenantId: FieldRef<"Blackout", 'String'>
    readonly venueId: FieldRef<"Blackout", 'String'>
    readonly startTs: FieldRef<"Blackout", 'DateTime'>
    readonly endTs: FieldRef<"Blackout", 'DateTime'>
    readonly reason: FieldRef<"Blackout", 'String'>
    readonly isMaintenance: FieldRef<"Blackout", 'Boolean'>
    readonly createdAt: FieldRef<"Blackout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Blackout findUnique
   */
  export type BlackoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blackout
     */
    select?: BlackoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blackout
     */
    omit?: BlackoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlackoutInclude<ExtArgs> | null
    /**
     * Filter, which Blackout to fetch.
     */
    where: BlackoutWhereUniqueInput
  }

  /**
   * Blackout findUniqueOrThrow
   */
  export type BlackoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blackout
     */
    select?: BlackoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blackout
     */
    omit?: BlackoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlackoutInclude<ExtArgs> | null
    /**
     * Filter, which Blackout to fetch.
     */
    where: BlackoutWhereUniqueInput
  }

  /**
   * Blackout findFirst
   */
  export type BlackoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blackout
     */
    select?: BlackoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blackout
     */
    omit?: BlackoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlackoutInclude<ExtArgs> | null
    /**
     * Filter, which Blackout to fetch.
     */
    where?: BlackoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blackouts to fetch.
     */
    orderBy?: BlackoutOrderByWithRelationInput | BlackoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blackouts.
     */
    cursor?: BlackoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blackouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blackouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blackouts.
     */
    distinct?: BlackoutScalarFieldEnum | BlackoutScalarFieldEnum[]
  }

  /**
   * Blackout findFirstOrThrow
   */
  export type BlackoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blackout
     */
    select?: BlackoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blackout
     */
    omit?: BlackoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlackoutInclude<ExtArgs> | null
    /**
     * Filter, which Blackout to fetch.
     */
    where?: BlackoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blackouts to fetch.
     */
    orderBy?: BlackoutOrderByWithRelationInput | BlackoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blackouts.
     */
    cursor?: BlackoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blackouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blackouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blackouts.
     */
    distinct?: BlackoutScalarFieldEnum | BlackoutScalarFieldEnum[]
  }

  /**
   * Blackout findMany
   */
  export type BlackoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blackout
     */
    select?: BlackoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blackout
     */
    omit?: BlackoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlackoutInclude<ExtArgs> | null
    /**
     * Filter, which Blackouts to fetch.
     */
    where?: BlackoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blackouts to fetch.
     */
    orderBy?: BlackoutOrderByWithRelationInput | BlackoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blackouts.
     */
    cursor?: BlackoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blackouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blackouts.
     */
    skip?: number
    distinct?: BlackoutScalarFieldEnum | BlackoutScalarFieldEnum[]
  }

  /**
   * Blackout create
   */
  export type BlackoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blackout
     */
    select?: BlackoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blackout
     */
    omit?: BlackoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlackoutInclude<ExtArgs> | null
    /**
     * The data needed to create a Blackout.
     */
    data: XOR<BlackoutCreateInput, BlackoutUncheckedCreateInput>
  }

  /**
   * Blackout createMany
   */
  export type BlackoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blackouts.
     */
    data: BlackoutCreateManyInput | BlackoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Blackout createManyAndReturn
   */
  export type BlackoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blackout
     */
    select?: BlackoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blackout
     */
    omit?: BlackoutOmit<ExtArgs> | null
    /**
     * The data used to create many Blackouts.
     */
    data: BlackoutCreateManyInput | BlackoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlackoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Blackout update
   */
  export type BlackoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blackout
     */
    select?: BlackoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blackout
     */
    omit?: BlackoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlackoutInclude<ExtArgs> | null
    /**
     * The data needed to update a Blackout.
     */
    data: XOR<BlackoutUpdateInput, BlackoutUncheckedUpdateInput>
    /**
     * Choose, which Blackout to update.
     */
    where: BlackoutWhereUniqueInput
  }

  /**
   * Blackout updateMany
   */
  export type BlackoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blackouts.
     */
    data: XOR<BlackoutUpdateManyMutationInput, BlackoutUncheckedUpdateManyInput>
    /**
     * Filter which Blackouts to update
     */
    where?: BlackoutWhereInput
    /**
     * Limit how many Blackouts to update.
     */
    limit?: number
  }

  /**
   * Blackout updateManyAndReturn
   */
  export type BlackoutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blackout
     */
    select?: BlackoutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blackout
     */
    omit?: BlackoutOmit<ExtArgs> | null
    /**
     * The data used to update Blackouts.
     */
    data: XOR<BlackoutUpdateManyMutationInput, BlackoutUncheckedUpdateManyInput>
    /**
     * Filter which Blackouts to update
     */
    where?: BlackoutWhereInput
    /**
     * Limit how many Blackouts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlackoutIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Blackout upsert
   */
  export type BlackoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blackout
     */
    select?: BlackoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blackout
     */
    omit?: BlackoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlackoutInclude<ExtArgs> | null
    /**
     * The filter to search for the Blackout to update in case it exists.
     */
    where: BlackoutWhereUniqueInput
    /**
     * In case the Blackout found by the `where` argument doesn't exist, create a new Blackout with this data.
     */
    create: XOR<BlackoutCreateInput, BlackoutUncheckedCreateInput>
    /**
     * In case the Blackout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlackoutUpdateInput, BlackoutUncheckedUpdateInput>
  }

  /**
   * Blackout delete
   */
  export type BlackoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blackout
     */
    select?: BlackoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blackout
     */
    omit?: BlackoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlackoutInclude<ExtArgs> | null
    /**
     * Filter which Blackout to delete.
     */
    where: BlackoutWhereUniqueInput
  }

  /**
   * Blackout deleteMany
   */
  export type BlackoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blackouts to delete
     */
    where?: BlackoutWhereInput
    /**
     * Limit how many Blackouts to delete.
     */
    limit?: number
  }

  /**
   * Blackout without action
   */
  export type BlackoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blackout
     */
    select?: BlackoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blackout
     */
    omit?: BlackoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlackoutInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amountCents: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    bookingId: string | null
    provider: string | null
    providerPaymentId: string | null
    amountCents: number | null
    currency: string | null
    status: string | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    bookingId: string | null
    provider: string | null
    providerPaymentId: string | null
    amountCents: number | null
    currency: string | null
    status: string | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    tenantId: number
    bookingId: number
    provider: number
    providerPaymentId: number
    amountCents: number
    currency: number
    status: number
    gatewayResponse: number
    processedAt: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amountCents?: true
  }

  export type PaymentSumAggregateInputType = {
    amountCents?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    tenantId?: true
    bookingId?: true
    provider?: true
    providerPaymentId?: true
    amountCents?: true
    currency?: true
    status?: true
    processedAt?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    bookingId?: true
    provider?: true
    providerPaymentId?: true
    amountCents?: true
    currency?: true
    status?: true
    processedAt?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    tenantId?: true
    bookingId?: true
    provider?: true
    providerPaymentId?: true
    amountCents?: true
    currency?: true
    status?: true
    gatewayResponse?: true
    processedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    tenantId: string
    bookingId: string
    provider: string
    providerPaymentId: string | null
    amountCents: number
    currency: string
    status: string
    gatewayResponse: JsonValue | null
    processedAt: Date | null
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    bookingId?: boolean
    provider?: boolean
    providerPaymentId?: boolean
    amountCents?: boolean
    currency?: boolean
    status?: boolean
    gatewayResponse?: boolean
    processedAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    bookingId?: boolean
    provider?: boolean
    providerPaymentId?: boolean
    amountCents?: boolean
    currency?: boolean
    status?: boolean
    gatewayResponse?: boolean
    processedAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    bookingId?: boolean
    provider?: boolean
    providerPaymentId?: boolean
    amountCents?: boolean
    currency?: boolean
    status?: boolean
    gatewayResponse?: boolean
    processedAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    bookingId?: boolean
    provider?: boolean
    providerPaymentId?: boolean
    amountCents?: boolean
    currency?: boolean
    status?: boolean
    gatewayResponse?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "bookingId" | "provider" | "providerPaymentId" | "amountCents" | "currency" | "status" | "gatewayResponse" | "processedAt" | "createdAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      bookingId: string
      provider: string
      providerPaymentId: string | null
      amountCents: number
      currency: string
      status: string
      gatewayResponse: Prisma.JsonValue | null
      processedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly tenantId: FieldRef<"Payment", 'String'>
    readonly bookingId: FieldRef<"Payment", 'String'>
    readonly provider: FieldRef<"Payment", 'String'>
    readonly providerPaymentId: FieldRef<"Payment", 'String'>
    readonly amountCents: FieldRef<"Payment", 'Int'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly gatewayResponse: FieldRef<"Payment", 'Json'>
    readonly processedAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model CashPayment
   */

  export type AggregateCashPayment = {
    _count: CashPaymentCountAggregateOutputType | null
    _avg: CashPaymentAvgAggregateOutputType | null
    _sum: CashPaymentSumAggregateOutputType | null
    _min: CashPaymentMinAggregateOutputType | null
    _max: CashPaymentMaxAggregateOutputType | null
  }

  export type CashPaymentAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type CashPaymentSumAggregateOutputType = {
    amountCents: number | null
  }

  export type CashPaymentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    bookingId: string | null
    amountCents: number | null
    recordedBy: string | null
    recordedAt: Date | null
    paymentMethod: string | null
    notes: string | null
    receiptNumber: string | null
    verificationStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashPaymentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    bookingId: string | null
    amountCents: number | null
    recordedBy: string | null
    recordedAt: Date | null
    paymentMethod: string | null
    notes: string | null
    receiptNumber: string | null
    verificationStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashPaymentCountAggregateOutputType = {
    id: number
    tenantId: number
    bookingId: number
    amountCents: number
    recordedBy: number
    recordedAt: number
    paymentMethod: number
    notes: number
    receiptNumber: number
    verificationStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CashPaymentAvgAggregateInputType = {
    amountCents?: true
  }

  export type CashPaymentSumAggregateInputType = {
    amountCents?: true
  }

  export type CashPaymentMinAggregateInputType = {
    id?: true
    tenantId?: true
    bookingId?: true
    amountCents?: true
    recordedBy?: true
    recordedAt?: true
    paymentMethod?: true
    notes?: true
    receiptNumber?: true
    verificationStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashPaymentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    bookingId?: true
    amountCents?: true
    recordedBy?: true
    recordedAt?: true
    paymentMethod?: true
    notes?: true
    receiptNumber?: true
    verificationStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashPaymentCountAggregateInputType = {
    id?: true
    tenantId?: true
    bookingId?: true
    amountCents?: true
    recordedBy?: true
    recordedAt?: true
    paymentMethod?: true
    notes?: true
    receiptNumber?: true
    verificationStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CashPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashPayment to aggregate.
     */
    where?: CashPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashPayments to fetch.
     */
    orderBy?: CashPaymentOrderByWithRelationInput | CashPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashPayments
    **/
    _count?: true | CashPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashPaymentMaxAggregateInputType
  }

  export type GetCashPaymentAggregateType<T extends CashPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateCashPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashPayment[P]>
      : GetScalarType<T[P], AggregateCashPayment[P]>
  }




  export type CashPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashPaymentWhereInput
    orderBy?: CashPaymentOrderByWithAggregationInput | CashPaymentOrderByWithAggregationInput[]
    by: CashPaymentScalarFieldEnum[] | CashPaymentScalarFieldEnum
    having?: CashPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashPaymentCountAggregateInputType | true
    _avg?: CashPaymentAvgAggregateInputType
    _sum?: CashPaymentSumAggregateInputType
    _min?: CashPaymentMinAggregateInputType
    _max?: CashPaymentMaxAggregateInputType
  }

  export type CashPaymentGroupByOutputType = {
    id: string
    tenantId: string
    bookingId: string
    amountCents: number
    recordedBy: string | null
    recordedAt: Date
    paymentMethod: string
    notes: string | null
    receiptNumber: string | null
    verificationStatus: string
    createdAt: Date
    updatedAt: Date
    _count: CashPaymentCountAggregateOutputType | null
    _avg: CashPaymentAvgAggregateOutputType | null
    _sum: CashPaymentSumAggregateOutputType | null
    _min: CashPaymentMinAggregateOutputType | null
    _max: CashPaymentMaxAggregateOutputType | null
  }

  type GetCashPaymentGroupByPayload<T extends CashPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], CashPaymentGroupByOutputType[P]>
        }
      >
    >


  export type CashPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    bookingId?: boolean
    amountCents?: boolean
    recordedBy?: boolean
    recordedAt?: boolean
    paymentMethod?: boolean
    notes?: boolean
    receiptNumber?: boolean
    verificationStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    recordedByUser?: boolean | CashPayment$recordedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["cashPayment"]>

  export type CashPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    bookingId?: boolean
    amountCents?: boolean
    recordedBy?: boolean
    recordedAt?: boolean
    paymentMethod?: boolean
    notes?: boolean
    receiptNumber?: boolean
    verificationStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    recordedByUser?: boolean | CashPayment$recordedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["cashPayment"]>

  export type CashPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    bookingId?: boolean
    amountCents?: boolean
    recordedBy?: boolean
    recordedAt?: boolean
    paymentMethod?: boolean
    notes?: boolean
    receiptNumber?: boolean
    verificationStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    recordedByUser?: boolean | CashPayment$recordedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["cashPayment"]>

  export type CashPaymentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    bookingId?: boolean
    amountCents?: boolean
    recordedBy?: boolean
    recordedAt?: boolean
    paymentMethod?: boolean
    notes?: boolean
    receiptNumber?: boolean
    verificationStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CashPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "bookingId" | "amountCents" | "recordedBy" | "recordedAt" | "paymentMethod" | "notes" | "receiptNumber" | "verificationStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["cashPayment"]>
  export type CashPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    recordedByUser?: boolean | CashPayment$recordedByUserArgs<ExtArgs>
  }
  export type CashPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    recordedByUser?: boolean | CashPayment$recordedByUserArgs<ExtArgs>
  }
  export type CashPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    recordedByUser?: boolean | CashPayment$recordedByUserArgs<ExtArgs>
  }

  export type $CashPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashPayment"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs>
      recordedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      bookingId: string
      amountCents: number
      recordedBy: string | null
      recordedAt: Date
      paymentMethod: string
      notes: string | null
      receiptNumber: string | null
      verificationStatus: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cashPayment"]>
    composites: {}
  }

  type CashPaymentGetPayload<S extends boolean | null | undefined | CashPaymentDefaultArgs> = $Result.GetResult<Prisma.$CashPaymentPayload, S>

  type CashPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashPaymentCountAggregateInputType | true
    }

  export interface CashPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashPayment'], meta: { name: 'CashPayment' } }
    /**
     * Find zero or one CashPayment that matches the filter.
     * @param {CashPaymentFindUniqueArgs} args - Arguments to find a CashPayment
     * @example
     * // Get one CashPayment
     * const cashPayment = await prisma.cashPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashPaymentFindUniqueArgs>(args: SelectSubset<T, CashPaymentFindUniqueArgs<ExtArgs>>): Prisma__CashPaymentClient<$Result.GetResult<Prisma.$CashPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashPaymentFindUniqueOrThrowArgs} args - Arguments to find a CashPayment
     * @example
     * // Get one CashPayment
     * const cashPayment = await prisma.cashPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, CashPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashPaymentClient<$Result.GetResult<Prisma.$CashPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashPaymentFindFirstArgs} args - Arguments to find a CashPayment
     * @example
     * // Get one CashPayment
     * const cashPayment = await prisma.cashPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashPaymentFindFirstArgs>(args?: SelectSubset<T, CashPaymentFindFirstArgs<ExtArgs>>): Prisma__CashPaymentClient<$Result.GetResult<Prisma.$CashPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashPaymentFindFirstOrThrowArgs} args - Arguments to find a CashPayment
     * @example
     * // Get one CashPayment
     * const cashPayment = await prisma.cashPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, CashPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashPaymentClient<$Result.GetResult<Prisma.$CashPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashPayments
     * const cashPayments = await prisma.cashPayment.findMany()
     * 
     * // Get first 10 CashPayments
     * const cashPayments = await prisma.cashPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashPaymentWithIdOnly = await prisma.cashPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashPaymentFindManyArgs>(args?: SelectSubset<T, CashPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashPayment.
     * @param {CashPaymentCreateArgs} args - Arguments to create a CashPayment.
     * @example
     * // Create one CashPayment
     * const CashPayment = await prisma.cashPayment.create({
     *   data: {
     *     // ... data to create a CashPayment
     *   }
     * })
     * 
     */
    create<T extends CashPaymentCreateArgs>(args: SelectSubset<T, CashPaymentCreateArgs<ExtArgs>>): Prisma__CashPaymentClient<$Result.GetResult<Prisma.$CashPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashPayments.
     * @param {CashPaymentCreateManyArgs} args - Arguments to create many CashPayments.
     * @example
     * // Create many CashPayments
     * const cashPayment = await prisma.cashPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashPaymentCreateManyArgs>(args?: SelectSubset<T, CashPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashPayments and returns the data saved in the database.
     * @param {CashPaymentCreateManyAndReturnArgs} args - Arguments to create many CashPayments.
     * @example
     * // Create many CashPayments
     * const cashPayment = await prisma.cashPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashPayments and only return the `id`
     * const cashPaymentWithIdOnly = await prisma.cashPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, CashPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashPayment.
     * @param {CashPaymentDeleteArgs} args - Arguments to delete one CashPayment.
     * @example
     * // Delete one CashPayment
     * const CashPayment = await prisma.cashPayment.delete({
     *   where: {
     *     // ... filter to delete one CashPayment
     *   }
     * })
     * 
     */
    delete<T extends CashPaymentDeleteArgs>(args: SelectSubset<T, CashPaymentDeleteArgs<ExtArgs>>): Prisma__CashPaymentClient<$Result.GetResult<Prisma.$CashPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashPayment.
     * @param {CashPaymentUpdateArgs} args - Arguments to update one CashPayment.
     * @example
     * // Update one CashPayment
     * const cashPayment = await prisma.cashPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashPaymentUpdateArgs>(args: SelectSubset<T, CashPaymentUpdateArgs<ExtArgs>>): Prisma__CashPaymentClient<$Result.GetResult<Prisma.$CashPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashPayments.
     * @param {CashPaymentDeleteManyArgs} args - Arguments to filter CashPayments to delete.
     * @example
     * // Delete a few CashPayments
     * const { count } = await prisma.cashPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashPaymentDeleteManyArgs>(args?: SelectSubset<T, CashPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashPayments
     * const cashPayment = await prisma.cashPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashPaymentUpdateManyArgs>(args: SelectSubset<T, CashPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashPayments and returns the data updated in the database.
     * @param {CashPaymentUpdateManyAndReturnArgs} args - Arguments to update many CashPayments.
     * @example
     * // Update many CashPayments
     * const cashPayment = await prisma.cashPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashPayments and only return the `id`
     * const cashPaymentWithIdOnly = await prisma.cashPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, CashPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashPayment.
     * @param {CashPaymentUpsertArgs} args - Arguments to update or create a CashPayment.
     * @example
     * // Update or create a CashPayment
     * const cashPayment = await prisma.cashPayment.upsert({
     *   create: {
     *     // ... data to create a CashPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashPayment we want to update
     *   }
     * })
     */
    upsert<T extends CashPaymentUpsertArgs>(args: SelectSubset<T, CashPaymentUpsertArgs<ExtArgs>>): Prisma__CashPaymentClient<$Result.GetResult<Prisma.$CashPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashPaymentCountArgs} args - Arguments to filter CashPayments to count.
     * @example
     * // Count the number of CashPayments
     * const count = await prisma.cashPayment.count({
     *   where: {
     *     // ... the filter for the CashPayments we want to count
     *   }
     * })
    **/
    count<T extends CashPaymentCountArgs>(
      args?: Subset<T, CashPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashPaymentAggregateArgs>(args: Subset<T, CashPaymentAggregateArgs>): Prisma.PrismaPromise<GetCashPaymentAggregateType<T>>

    /**
     * Group by CashPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashPaymentGroupByArgs['orderBy'] }
        : { orderBy?: CashPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashPayment model
   */
  readonly fields: CashPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recordedByUser<T extends CashPayment$recordedByUserArgs<ExtArgs> = {}>(args?: Subset<T, CashPayment$recordedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashPayment model
   */
  interface CashPaymentFieldRefs {
    readonly id: FieldRef<"CashPayment", 'String'>
    readonly tenantId: FieldRef<"CashPayment", 'String'>
    readonly bookingId: FieldRef<"CashPayment", 'String'>
    readonly amountCents: FieldRef<"CashPayment", 'Int'>
    readonly recordedBy: FieldRef<"CashPayment", 'String'>
    readonly recordedAt: FieldRef<"CashPayment", 'DateTime'>
    readonly paymentMethod: FieldRef<"CashPayment", 'String'>
    readonly notes: FieldRef<"CashPayment", 'String'>
    readonly receiptNumber: FieldRef<"CashPayment", 'String'>
    readonly verificationStatus: FieldRef<"CashPayment", 'String'>
    readonly createdAt: FieldRef<"CashPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"CashPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashPayment findUnique
   */
  export type CashPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CashPayment to fetch.
     */
    where: CashPaymentWhereUniqueInput
  }

  /**
   * CashPayment findUniqueOrThrow
   */
  export type CashPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CashPayment to fetch.
     */
    where: CashPaymentWhereUniqueInput
  }

  /**
   * CashPayment findFirst
   */
  export type CashPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CashPayment to fetch.
     */
    where?: CashPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashPayments to fetch.
     */
    orderBy?: CashPaymentOrderByWithRelationInput | CashPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashPayments.
     */
    cursor?: CashPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashPayments.
     */
    distinct?: CashPaymentScalarFieldEnum | CashPaymentScalarFieldEnum[]
  }

  /**
   * CashPayment findFirstOrThrow
   */
  export type CashPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CashPayment to fetch.
     */
    where?: CashPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashPayments to fetch.
     */
    orderBy?: CashPaymentOrderByWithRelationInput | CashPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashPayments.
     */
    cursor?: CashPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashPayments.
     */
    distinct?: CashPaymentScalarFieldEnum | CashPaymentScalarFieldEnum[]
  }

  /**
   * CashPayment findMany
   */
  export type CashPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CashPayments to fetch.
     */
    where?: CashPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashPayments to fetch.
     */
    orderBy?: CashPaymentOrderByWithRelationInput | CashPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashPayments.
     */
    cursor?: CashPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashPayments.
     */
    skip?: number
    distinct?: CashPaymentScalarFieldEnum | CashPaymentScalarFieldEnum[]
  }

  /**
   * CashPayment create
   */
  export type CashPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a CashPayment.
     */
    data: XOR<CashPaymentCreateInput, CashPaymentUncheckedCreateInput>
  }

  /**
   * CashPayment createMany
   */
  export type CashPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashPayments.
     */
    data: CashPaymentCreateManyInput | CashPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashPayment createManyAndReturn
   */
  export type CashPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many CashPayments.
     */
    data: CashPaymentCreateManyInput | CashPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashPayment update
   */
  export type CashPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a CashPayment.
     */
    data: XOR<CashPaymentUpdateInput, CashPaymentUncheckedUpdateInput>
    /**
     * Choose, which CashPayment to update.
     */
    where: CashPaymentWhereUniqueInput
  }

  /**
   * CashPayment updateMany
   */
  export type CashPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashPayments.
     */
    data: XOR<CashPaymentUpdateManyMutationInput, CashPaymentUncheckedUpdateManyInput>
    /**
     * Filter which CashPayments to update
     */
    where?: CashPaymentWhereInput
    /**
     * Limit how many CashPayments to update.
     */
    limit?: number
  }

  /**
   * CashPayment updateManyAndReturn
   */
  export type CashPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * The data used to update CashPayments.
     */
    data: XOR<CashPaymentUpdateManyMutationInput, CashPaymentUncheckedUpdateManyInput>
    /**
     * Filter which CashPayments to update
     */
    where?: CashPaymentWhereInput
    /**
     * Limit how many CashPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashPayment upsert
   */
  export type CashPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the CashPayment to update in case it exists.
     */
    where: CashPaymentWhereUniqueInput
    /**
     * In case the CashPayment found by the `where` argument doesn't exist, create a new CashPayment with this data.
     */
    create: XOR<CashPaymentCreateInput, CashPaymentUncheckedCreateInput>
    /**
     * In case the CashPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashPaymentUpdateInput, CashPaymentUncheckedUpdateInput>
  }

  /**
   * CashPayment delete
   */
  export type CashPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentInclude<ExtArgs> | null
    /**
     * Filter which CashPayment to delete.
     */
    where: CashPaymentWhereUniqueInput
  }

  /**
   * CashPayment deleteMany
   */
  export type CashPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashPayments to delete
     */
    where?: CashPaymentWhereInput
    /**
     * Limit how many CashPayments to delete.
     */
    limit?: number
  }

  /**
   * CashPayment.recordedByUser
   */
  export type CashPayment$recordedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CashPayment without action
   */
  export type CashPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashPayment
     */
    select?: CashPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashPayment
     */
    omit?: CashPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashPaymentInclude<ExtArgs> | null
  }


  /**
   * Model CommissionRecord
   */

  export type AggregateCommissionRecord = {
    _count: CommissionRecordCountAggregateOutputType | null
    _avg: CommissionRecordAvgAggregateOutputType | null
    _sum: CommissionRecordSumAggregateOutputType | null
    _min: CommissionRecordMinAggregateOutputType | null
    _max: CommissionRecordMaxAggregateOutputType | null
  }

  export type CommissionRecordAvgAggregateOutputType = {
    bookingAmountCents: number | null
    commissionPercentage: Decimal | null
    commissionAmountCents: number | null
  }

  export type CommissionRecordSumAggregateOutputType = {
    bookingAmountCents: number | null
    commissionPercentage: Decimal | null
    commissionAmountCents: number | null
  }

  export type CommissionRecordMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    bookingId: string | null
    venueId: string | null
    bookingAmountCents: number | null
    commissionPercentage: Decimal | null
    commissionAmountCents: number | null
    commissionStatus: string | null
    collectionMethod: string | null
    collectedAt: Date | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommissionRecordMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    bookingId: string | null
    venueId: string | null
    bookingAmountCents: number | null
    commissionPercentage: Decimal | null
    commissionAmountCents: number | null
    commissionStatus: string | null
    collectionMethod: string | null
    collectedAt: Date | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommissionRecordCountAggregateOutputType = {
    id: number
    tenantId: number
    bookingId: number
    venueId: number
    bookingAmountCents: number
    commissionPercentage: number
    commissionAmountCents: number
    commissionStatus: number
    collectionMethod: number
    collectedAt: number
    dueDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommissionRecordAvgAggregateInputType = {
    bookingAmountCents?: true
    commissionPercentage?: true
    commissionAmountCents?: true
  }

  export type CommissionRecordSumAggregateInputType = {
    bookingAmountCents?: true
    commissionPercentage?: true
    commissionAmountCents?: true
  }

  export type CommissionRecordMinAggregateInputType = {
    id?: true
    tenantId?: true
    bookingId?: true
    venueId?: true
    bookingAmountCents?: true
    commissionPercentage?: true
    commissionAmountCents?: true
    commissionStatus?: true
    collectionMethod?: true
    collectedAt?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommissionRecordMaxAggregateInputType = {
    id?: true
    tenantId?: true
    bookingId?: true
    venueId?: true
    bookingAmountCents?: true
    commissionPercentage?: true
    commissionAmountCents?: true
    commissionStatus?: true
    collectionMethod?: true
    collectedAt?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommissionRecordCountAggregateInputType = {
    id?: true
    tenantId?: true
    bookingId?: true
    venueId?: true
    bookingAmountCents?: true
    commissionPercentage?: true
    commissionAmountCents?: true
    commissionStatus?: true
    collectionMethod?: true
    collectedAt?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommissionRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommissionRecord to aggregate.
     */
    where?: CommissionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionRecords to fetch.
     */
    orderBy?: CommissionRecordOrderByWithRelationInput | CommissionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommissionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommissionRecords
    **/
    _count?: true | CommissionRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommissionRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommissionRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommissionRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommissionRecordMaxAggregateInputType
  }

  export type GetCommissionRecordAggregateType<T extends CommissionRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateCommissionRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommissionRecord[P]>
      : GetScalarType<T[P], AggregateCommissionRecord[P]>
  }




  export type CommissionRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionRecordWhereInput
    orderBy?: CommissionRecordOrderByWithAggregationInput | CommissionRecordOrderByWithAggregationInput[]
    by: CommissionRecordScalarFieldEnum[] | CommissionRecordScalarFieldEnum
    having?: CommissionRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommissionRecordCountAggregateInputType | true
    _avg?: CommissionRecordAvgAggregateInputType
    _sum?: CommissionRecordSumAggregateInputType
    _min?: CommissionRecordMinAggregateInputType
    _max?: CommissionRecordMaxAggregateInputType
  }

  export type CommissionRecordGroupByOutputType = {
    id: string
    tenantId: string
    bookingId: string
    venueId: string
    bookingAmountCents: number
    commissionPercentage: Decimal
    commissionAmountCents: number
    commissionStatus: string
    collectionMethod: string | null
    collectedAt: Date | null
    dueDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CommissionRecordCountAggregateOutputType | null
    _avg: CommissionRecordAvgAggregateOutputType | null
    _sum: CommissionRecordSumAggregateOutputType | null
    _min: CommissionRecordMinAggregateOutputType | null
    _max: CommissionRecordMaxAggregateOutputType | null
  }

  type GetCommissionRecordGroupByPayload<T extends CommissionRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommissionRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommissionRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommissionRecordGroupByOutputType[P]>
            : GetScalarType<T[P], CommissionRecordGroupByOutputType[P]>
        }
      >
    >


  export type CommissionRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    bookingId?: boolean
    venueId?: boolean
    bookingAmountCents?: boolean
    commissionPercentage?: boolean
    commissionAmountCents?: boolean
    commissionStatus?: boolean
    collectionMethod?: boolean
    collectedAt?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commissionRecord"]>

  export type CommissionRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    bookingId?: boolean
    venueId?: boolean
    bookingAmountCents?: boolean
    commissionPercentage?: boolean
    commissionAmountCents?: boolean
    commissionStatus?: boolean
    collectionMethod?: boolean
    collectedAt?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commissionRecord"]>

  export type CommissionRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    bookingId?: boolean
    venueId?: boolean
    bookingAmountCents?: boolean
    commissionPercentage?: boolean
    commissionAmountCents?: boolean
    commissionStatus?: boolean
    collectionMethod?: boolean
    collectedAt?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commissionRecord"]>

  export type CommissionRecordSelectScalar = {
    id?: boolean
    tenantId?: boolean
    bookingId?: boolean
    venueId?: boolean
    bookingAmountCents?: boolean
    commissionPercentage?: boolean
    commissionAmountCents?: boolean
    commissionStatus?: boolean
    collectionMethod?: boolean
    collectedAt?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommissionRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "bookingId" | "venueId" | "bookingAmountCents" | "commissionPercentage" | "commissionAmountCents" | "commissionStatus" | "collectionMethod" | "collectedAt" | "dueDate" | "createdAt" | "updatedAt", ExtArgs["result"]["commissionRecord"]>
  export type CommissionRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }
  export type CommissionRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }
  export type CommissionRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $CommissionRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommissionRecord"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      bookingId: string
      venueId: string
      bookingAmountCents: number
      commissionPercentage: Prisma.Decimal
      commissionAmountCents: number
      commissionStatus: string
      collectionMethod: string | null
      collectedAt: Date | null
      dueDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["commissionRecord"]>
    composites: {}
  }

  type CommissionRecordGetPayload<S extends boolean | null | undefined | CommissionRecordDefaultArgs> = $Result.GetResult<Prisma.$CommissionRecordPayload, S>

  type CommissionRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommissionRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommissionRecordCountAggregateInputType | true
    }

  export interface CommissionRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommissionRecord'], meta: { name: 'CommissionRecord' } }
    /**
     * Find zero or one CommissionRecord that matches the filter.
     * @param {CommissionRecordFindUniqueArgs} args - Arguments to find a CommissionRecord
     * @example
     * // Get one CommissionRecord
     * const commissionRecord = await prisma.commissionRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommissionRecordFindUniqueArgs>(args: SelectSubset<T, CommissionRecordFindUniqueArgs<ExtArgs>>): Prisma__CommissionRecordClient<$Result.GetResult<Prisma.$CommissionRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommissionRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommissionRecordFindUniqueOrThrowArgs} args - Arguments to find a CommissionRecord
     * @example
     * // Get one CommissionRecord
     * const commissionRecord = await prisma.commissionRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommissionRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, CommissionRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommissionRecordClient<$Result.GetResult<Prisma.$CommissionRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommissionRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionRecordFindFirstArgs} args - Arguments to find a CommissionRecord
     * @example
     * // Get one CommissionRecord
     * const commissionRecord = await prisma.commissionRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommissionRecordFindFirstArgs>(args?: SelectSubset<T, CommissionRecordFindFirstArgs<ExtArgs>>): Prisma__CommissionRecordClient<$Result.GetResult<Prisma.$CommissionRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommissionRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionRecordFindFirstOrThrowArgs} args - Arguments to find a CommissionRecord
     * @example
     * // Get one CommissionRecord
     * const commissionRecord = await prisma.commissionRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommissionRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, CommissionRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommissionRecordClient<$Result.GetResult<Prisma.$CommissionRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommissionRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommissionRecords
     * const commissionRecords = await prisma.commissionRecord.findMany()
     * 
     * // Get first 10 CommissionRecords
     * const commissionRecords = await prisma.commissionRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commissionRecordWithIdOnly = await prisma.commissionRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommissionRecordFindManyArgs>(args?: SelectSubset<T, CommissionRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommissionRecord.
     * @param {CommissionRecordCreateArgs} args - Arguments to create a CommissionRecord.
     * @example
     * // Create one CommissionRecord
     * const CommissionRecord = await prisma.commissionRecord.create({
     *   data: {
     *     // ... data to create a CommissionRecord
     *   }
     * })
     * 
     */
    create<T extends CommissionRecordCreateArgs>(args: SelectSubset<T, CommissionRecordCreateArgs<ExtArgs>>): Prisma__CommissionRecordClient<$Result.GetResult<Prisma.$CommissionRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommissionRecords.
     * @param {CommissionRecordCreateManyArgs} args - Arguments to create many CommissionRecords.
     * @example
     * // Create many CommissionRecords
     * const commissionRecord = await prisma.commissionRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommissionRecordCreateManyArgs>(args?: SelectSubset<T, CommissionRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommissionRecords and returns the data saved in the database.
     * @param {CommissionRecordCreateManyAndReturnArgs} args - Arguments to create many CommissionRecords.
     * @example
     * // Create many CommissionRecords
     * const commissionRecord = await prisma.commissionRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommissionRecords and only return the `id`
     * const commissionRecordWithIdOnly = await prisma.commissionRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommissionRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, CommissionRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommissionRecord.
     * @param {CommissionRecordDeleteArgs} args - Arguments to delete one CommissionRecord.
     * @example
     * // Delete one CommissionRecord
     * const CommissionRecord = await prisma.commissionRecord.delete({
     *   where: {
     *     // ... filter to delete one CommissionRecord
     *   }
     * })
     * 
     */
    delete<T extends CommissionRecordDeleteArgs>(args: SelectSubset<T, CommissionRecordDeleteArgs<ExtArgs>>): Prisma__CommissionRecordClient<$Result.GetResult<Prisma.$CommissionRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommissionRecord.
     * @param {CommissionRecordUpdateArgs} args - Arguments to update one CommissionRecord.
     * @example
     * // Update one CommissionRecord
     * const commissionRecord = await prisma.commissionRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommissionRecordUpdateArgs>(args: SelectSubset<T, CommissionRecordUpdateArgs<ExtArgs>>): Prisma__CommissionRecordClient<$Result.GetResult<Prisma.$CommissionRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommissionRecords.
     * @param {CommissionRecordDeleteManyArgs} args - Arguments to filter CommissionRecords to delete.
     * @example
     * // Delete a few CommissionRecords
     * const { count } = await prisma.commissionRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommissionRecordDeleteManyArgs>(args?: SelectSubset<T, CommissionRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommissionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommissionRecords
     * const commissionRecord = await prisma.commissionRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommissionRecordUpdateManyArgs>(args: SelectSubset<T, CommissionRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommissionRecords and returns the data updated in the database.
     * @param {CommissionRecordUpdateManyAndReturnArgs} args - Arguments to update many CommissionRecords.
     * @example
     * // Update many CommissionRecords
     * const commissionRecord = await prisma.commissionRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommissionRecords and only return the `id`
     * const commissionRecordWithIdOnly = await prisma.commissionRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommissionRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, CommissionRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommissionRecord.
     * @param {CommissionRecordUpsertArgs} args - Arguments to update or create a CommissionRecord.
     * @example
     * // Update or create a CommissionRecord
     * const commissionRecord = await prisma.commissionRecord.upsert({
     *   create: {
     *     // ... data to create a CommissionRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommissionRecord we want to update
     *   }
     * })
     */
    upsert<T extends CommissionRecordUpsertArgs>(args: SelectSubset<T, CommissionRecordUpsertArgs<ExtArgs>>): Prisma__CommissionRecordClient<$Result.GetResult<Prisma.$CommissionRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommissionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionRecordCountArgs} args - Arguments to filter CommissionRecords to count.
     * @example
     * // Count the number of CommissionRecords
     * const count = await prisma.commissionRecord.count({
     *   where: {
     *     // ... the filter for the CommissionRecords we want to count
     *   }
     * })
    **/
    count<T extends CommissionRecordCountArgs>(
      args?: Subset<T, CommissionRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommissionRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommissionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommissionRecordAggregateArgs>(args: Subset<T, CommissionRecordAggregateArgs>): Prisma.PrismaPromise<GetCommissionRecordAggregateType<T>>

    /**
     * Group by CommissionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommissionRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommissionRecordGroupByArgs['orderBy'] }
        : { orderBy?: CommissionRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommissionRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommissionRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommissionRecord model
   */
  readonly fields: CommissionRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommissionRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommissionRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommissionRecord model
   */
  interface CommissionRecordFieldRefs {
    readonly id: FieldRef<"CommissionRecord", 'String'>
    readonly tenantId: FieldRef<"CommissionRecord", 'String'>
    readonly bookingId: FieldRef<"CommissionRecord", 'String'>
    readonly venueId: FieldRef<"CommissionRecord", 'String'>
    readonly bookingAmountCents: FieldRef<"CommissionRecord", 'Int'>
    readonly commissionPercentage: FieldRef<"CommissionRecord", 'Decimal'>
    readonly commissionAmountCents: FieldRef<"CommissionRecord", 'Int'>
    readonly commissionStatus: FieldRef<"CommissionRecord", 'String'>
    readonly collectionMethod: FieldRef<"CommissionRecord", 'String'>
    readonly collectedAt: FieldRef<"CommissionRecord", 'DateTime'>
    readonly dueDate: FieldRef<"CommissionRecord", 'DateTime'>
    readonly createdAt: FieldRef<"CommissionRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"CommissionRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommissionRecord findUnique
   */
  export type CommissionRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordInclude<ExtArgs> | null
    /**
     * Filter, which CommissionRecord to fetch.
     */
    where: CommissionRecordWhereUniqueInput
  }

  /**
   * CommissionRecord findUniqueOrThrow
   */
  export type CommissionRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordInclude<ExtArgs> | null
    /**
     * Filter, which CommissionRecord to fetch.
     */
    where: CommissionRecordWhereUniqueInput
  }

  /**
   * CommissionRecord findFirst
   */
  export type CommissionRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordInclude<ExtArgs> | null
    /**
     * Filter, which CommissionRecord to fetch.
     */
    where?: CommissionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionRecords to fetch.
     */
    orderBy?: CommissionRecordOrderByWithRelationInput | CommissionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommissionRecords.
     */
    cursor?: CommissionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommissionRecords.
     */
    distinct?: CommissionRecordScalarFieldEnum | CommissionRecordScalarFieldEnum[]
  }

  /**
   * CommissionRecord findFirstOrThrow
   */
  export type CommissionRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordInclude<ExtArgs> | null
    /**
     * Filter, which CommissionRecord to fetch.
     */
    where?: CommissionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionRecords to fetch.
     */
    orderBy?: CommissionRecordOrderByWithRelationInput | CommissionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommissionRecords.
     */
    cursor?: CommissionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommissionRecords.
     */
    distinct?: CommissionRecordScalarFieldEnum | CommissionRecordScalarFieldEnum[]
  }

  /**
   * CommissionRecord findMany
   */
  export type CommissionRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordInclude<ExtArgs> | null
    /**
     * Filter, which CommissionRecords to fetch.
     */
    where?: CommissionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionRecords to fetch.
     */
    orderBy?: CommissionRecordOrderByWithRelationInput | CommissionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommissionRecords.
     */
    cursor?: CommissionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionRecords.
     */
    skip?: number
    distinct?: CommissionRecordScalarFieldEnum | CommissionRecordScalarFieldEnum[]
  }

  /**
   * CommissionRecord create
   */
  export type CommissionRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a CommissionRecord.
     */
    data: XOR<CommissionRecordCreateInput, CommissionRecordUncheckedCreateInput>
  }

  /**
   * CommissionRecord createMany
   */
  export type CommissionRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommissionRecords.
     */
    data: CommissionRecordCreateManyInput | CommissionRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommissionRecord createManyAndReturn
   */
  export type CommissionRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * The data used to create many CommissionRecords.
     */
    data: CommissionRecordCreateManyInput | CommissionRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommissionRecord update
   */
  export type CommissionRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a CommissionRecord.
     */
    data: XOR<CommissionRecordUpdateInput, CommissionRecordUncheckedUpdateInput>
    /**
     * Choose, which CommissionRecord to update.
     */
    where: CommissionRecordWhereUniqueInput
  }

  /**
   * CommissionRecord updateMany
   */
  export type CommissionRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommissionRecords.
     */
    data: XOR<CommissionRecordUpdateManyMutationInput, CommissionRecordUncheckedUpdateManyInput>
    /**
     * Filter which CommissionRecords to update
     */
    where?: CommissionRecordWhereInput
    /**
     * Limit how many CommissionRecords to update.
     */
    limit?: number
  }

  /**
   * CommissionRecord updateManyAndReturn
   */
  export type CommissionRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * The data used to update CommissionRecords.
     */
    data: XOR<CommissionRecordUpdateManyMutationInput, CommissionRecordUncheckedUpdateManyInput>
    /**
     * Filter which CommissionRecords to update
     */
    where?: CommissionRecordWhereInput
    /**
     * Limit how many CommissionRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommissionRecord upsert
   */
  export type CommissionRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the CommissionRecord to update in case it exists.
     */
    where: CommissionRecordWhereUniqueInput
    /**
     * In case the CommissionRecord found by the `where` argument doesn't exist, create a new CommissionRecord with this data.
     */
    create: XOR<CommissionRecordCreateInput, CommissionRecordUncheckedCreateInput>
    /**
     * In case the CommissionRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommissionRecordUpdateInput, CommissionRecordUncheckedUpdateInput>
  }

  /**
   * CommissionRecord delete
   */
  export type CommissionRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordInclude<ExtArgs> | null
    /**
     * Filter which CommissionRecord to delete.
     */
    where: CommissionRecordWhereUniqueInput
  }

  /**
   * CommissionRecord deleteMany
   */
  export type CommissionRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommissionRecords to delete
     */
    where?: CommissionRecordWhereInput
    /**
     * Limit how many CommissionRecords to delete.
     */
    limit?: number
  }

  /**
   * CommissionRecord without action
   */
  export type CommissionRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionRecord
     */
    select?: CommissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommissionRecord
     */
    omit?: CommissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionRecordInclude<ExtArgs> | null
  }


  /**
   * Model CustomerPaymentPreference
   */

  export type AggregateCustomerPaymentPreference = {
    _count: CustomerPaymentPreferenceCountAggregateOutputType | null
    _avg: CustomerPaymentPreferenceAvgAggregateOutputType | null
    _sum: CustomerPaymentPreferenceSumAggregateOutputType | null
    _min: CustomerPaymentPreferenceMinAggregateOutputType | null
    _max: CustomerPaymentPreferenceMaxAggregateOutputType | null
  }

  export type CustomerPaymentPreferenceAvgAggregateOutputType = {
    totalBookings: number | null
    totalOnlinePayments: number | null
  }

  export type CustomerPaymentPreferenceSumAggregateOutputType = {
    totalBookings: number | null
    totalOnlinePayments: number | null
  }

  export type CustomerPaymentPreferenceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    preferredMethod: string | null
    cityTier: string | null
    lastPaymentMethod: string | null
    totalBookings: number | null
    totalOnlinePayments: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerPaymentPreferenceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    preferredMethod: string | null
    cityTier: string | null
    lastPaymentMethod: string | null
    totalBookings: number | null
    totalOnlinePayments: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerPaymentPreferenceCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    preferredMethod: number
    cityTier: number
    lastPaymentMethod: number
    totalBookings: number
    totalOnlinePayments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerPaymentPreferenceAvgAggregateInputType = {
    totalBookings?: true
    totalOnlinePayments?: true
  }

  export type CustomerPaymentPreferenceSumAggregateInputType = {
    totalBookings?: true
    totalOnlinePayments?: true
  }

  export type CustomerPaymentPreferenceMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    preferredMethod?: true
    cityTier?: true
    lastPaymentMethod?: true
    totalBookings?: true
    totalOnlinePayments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerPaymentPreferenceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    preferredMethod?: true
    cityTier?: true
    lastPaymentMethod?: true
    totalBookings?: true
    totalOnlinePayments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerPaymentPreferenceCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    preferredMethod?: true
    cityTier?: true
    lastPaymentMethod?: true
    totalBookings?: true
    totalOnlinePayments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerPaymentPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPaymentPreference to aggregate.
     */
    where?: CustomerPaymentPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPaymentPreferences to fetch.
     */
    orderBy?: CustomerPaymentPreferenceOrderByWithRelationInput | CustomerPaymentPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerPaymentPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPaymentPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPaymentPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerPaymentPreferences
    **/
    _count?: true | CustomerPaymentPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerPaymentPreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerPaymentPreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerPaymentPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerPaymentPreferenceMaxAggregateInputType
  }

  export type GetCustomerPaymentPreferenceAggregateType<T extends CustomerPaymentPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerPaymentPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerPaymentPreference[P]>
      : GetScalarType<T[P], AggregateCustomerPaymentPreference[P]>
  }




  export type CustomerPaymentPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPaymentPreferenceWhereInput
    orderBy?: CustomerPaymentPreferenceOrderByWithAggregationInput | CustomerPaymentPreferenceOrderByWithAggregationInput[]
    by: CustomerPaymentPreferenceScalarFieldEnum[] | CustomerPaymentPreferenceScalarFieldEnum
    having?: CustomerPaymentPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerPaymentPreferenceCountAggregateInputType | true
    _avg?: CustomerPaymentPreferenceAvgAggregateInputType
    _sum?: CustomerPaymentPreferenceSumAggregateInputType
    _min?: CustomerPaymentPreferenceMinAggregateInputType
    _max?: CustomerPaymentPreferenceMaxAggregateInputType
  }

  export type CustomerPaymentPreferenceGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    preferredMethod: string
    cityTier: string | null
    lastPaymentMethod: string | null
    totalBookings: number
    totalOnlinePayments: number
    createdAt: Date
    updatedAt: Date
    _count: CustomerPaymentPreferenceCountAggregateOutputType | null
    _avg: CustomerPaymentPreferenceAvgAggregateOutputType | null
    _sum: CustomerPaymentPreferenceSumAggregateOutputType | null
    _min: CustomerPaymentPreferenceMinAggregateOutputType | null
    _max: CustomerPaymentPreferenceMaxAggregateOutputType | null
  }

  type GetCustomerPaymentPreferenceGroupByPayload<T extends CustomerPaymentPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerPaymentPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerPaymentPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerPaymentPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerPaymentPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type CustomerPaymentPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    preferredMethod?: boolean
    cityTier?: boolean
    lastPaymentMethod?: boolean
    totalBookings?: boolean
    totalOnlinePayments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPaymentPreference"]>

  export type CustomerPaymentPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    preferredMethod?: boolean
    cityTier?: boolean
    lastPaymentMethod?: boolean
    totalBookings?: boolean
    totalOnlinePayments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPaymentPreference"]>

  export type CustomerPaymentPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    preferredMethod?: boolean
    cityTier?: boolean
    lastPaymentMethod?: boolean
    totalBookings?: boolean
    totalOnlinePayments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPaymentPreference"]>

  export type CustomerPaymentPreferenceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    preferredMethod?: boolean
    cityTier?: boolean
    lastPaymentMethod?: boolean
    totalBookings?: boolean
    totalOnlinePayments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerPaymentPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "preferredMethod" | "cityTier" | "lastPaymentMethod" | "totalBookings" | "totalOnlinePayments" | "createdAt" | "updatedAt", ExtArgs["result"]["customerPaymentPreference"]>
  export type CustomerPaymentPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CustomerPaymentPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CustomerPaymentPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CustomerPaymentPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerPaymentPreference"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      preferredMethod: string
      cityTier: string | null
      lastPaymentMethod: string | null
      totalBookings: number
      totalOnlinePayments: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerPaymentPreference"]>
    composites: {}
  }

  type CustomerPaymentPreferenceGetPayload<S extends boolean | null | undefined | CustomerPaymentPreferenceDefaultArgs> = $Result.GetResult<Prisma.$CustomerPaymentPreferencePayload, S>

  type CustomerPaymentPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerPaymentPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerPaymentPreferenceCountAggregateInputType | true
    }

  export interface CustomerPaymentPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerPaymentPreference'], meta: { name: 'CustomerPaymentPreference' } }
    /**
     * Find zero or one CustomerPaymentPreference that matches the filter.
     * @param {CustomerPaymentPreferenceFindUniqueArgs} args - Arguments to find a CustomerPaymentPreference
     * @example
     * // Get one CustomerPaymentPreference
     * const customerPaymentPreference = await prisma.customerPaymentPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerPaymentPreferenceFindUniqueArgs>(args: SelectSubset<T, CustomerPaymentPreferenceFindUniqueArgs<ExtArgs>>): Prisma__CustomerPaymentPreferenceClient<$Result.GetResult<Prisma.$CustomerPaymentPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerPaymentPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerPaymentPreferenceFindUniqueOrThrowArgs} args - Arguments to find a CustomerPaymentPreference
     * @example
     * // Get one CustomerPaymentPreference
     * const customerPaymentPreference = await prisma.customerPaymentPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerPaymentPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerPaymentPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerPaymentPreferenceClient<$Result.GetResult<Prisma.$CustomerPaymentPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPaymentPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPaymentPreferenceFindFirstArgs} args - Arguments to find a CustomerPaymentPreference
     * @example
     * // Get one CustomerPaymentPreference
     * const customerPaymentPreference = await prisma.customerPaymentPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerPaymentPreferenceFindFirstArgs>(args?: SelectSubset<T, CustomerPaymentPreferenceFindFirstArgs<ExtArgs>>): Prisma__CustomerPaymentPreferenceClient<$Result.GetResult<Prisma.$CustomerPaymentPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPaymentPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPaymentPreferenceFindFirstOrThrowArgs} args - Arguments to find a CustomerPaymentPreference
     * @example
     * // Get one CustomerPaymentPreference
     * const customerPaymentPreference = await prisma.customerPaymentPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerPaymentPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerPaymentPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerPaymentPreferenceClient<$Result.GetResult<Prisma.$CustomerPaymentPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerPaymentPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPaymentPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerPaymentPreferences
     * const customerPaymentPreferences = await prisma.customerPaymentPreference.findMany()
     * 
     * // Get first 10 CustomerPaymentPreferences
     * const customerPaymentPreferences = await prisma.customerPaymentPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerPaymentPreferenceWithIdOnly = await prisma.customerPaymentPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerPaymentPreferenceFindManyArgs>(args?: SelectSubset<T, CustomerPaymentPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPaymentPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerPaymentPreference.
     * @param {CustomerPaymentPreferenceCreateArgs} args - Arguments to create a CustomerPaymentPreference.
     * @example
     * // Create one CustomerPaymentPreference
     * const CustomerPaymentPreference = await prisma.customerPaymentPreference.create({
     *   data: {
     *     // ... data to create a CustomerPaymentPreference
     *   }
     * })
     * 
     */
    create<T extends CustomerPaymentPreferenceCreateArgs>(args: SelectSubset<T, CustomerPaymentPreferenceCreateArgs<ExtArgs>>): Prisma__CustomerPaymentPreferenceClient<$Result.GetResult<Prisma.$CustomerPaymentPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerPaymentPreferences.
     * @param {CustomerPaymentPreferenceCreateManyArgs} args - Arguments to create many CustomerPaymentPreferences.
     * @example
     * // Create many CustomerPaymentPreferences
     * const customerPaymentPreference = await prisma.customerPaymentPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerPaymentPreferenceCreateManyArgs>(args?: SelectSubset<T, CustomerPaymentPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerPaymentPreferences and returns the data saved in the database.
     * @param {CustomerPaymentPreferenceCreateManyAndReturnArgs} args - Arguments to create many CustomerPaymentPreferences.
     * @example
     * // Create many CustomerPaymentPreferences
     * const customerPaymentPreference = await prisma.customerPaymentPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerPaymentPreferences and only return the `id`
     * const customerPaymentPreferenceWithIdOnly = await prisma.customerPaymentPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerPaymentPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerPaymentPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPaymentPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerPaymentPreference.
     * @param {CustomerPaymentPreferenceDeleteArgs} args - Arguments to delete one CustomerPaymentPreference.
     * @example
     * // Delete one CustomerPaymentPreference
     * const CustomerPaymentPreference = await prisma.customerPaymentPreference.delete({
     *   where: {
     *     // ... filter to delete one CustomerPaymentPreference
     *   }
     * })
     * 
     */
    delete<T extends CustomerPaymentPreferenceDeleteArgs>(args: SelectSubset<T, CustomerPaymentPreferenceDeleteArgs<ExtArgs>>): Prisma__CustomerPaymentPreferenceClient<$Result.GetResult<Prisma.$CustomerPaymentPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerPaymentPreference.
     * @param {CustomerPaymentPreferenceUpdateArgs} args - Arguments to update one CustomerPaymentPreference.
     * @example
     * // Update one CustomerPaymentPreference
     * const customerPaymentPreference = await prisma.customerPaymentPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerPaymentPreferenceUpdateArgs>(args: SelectSubset<T, CustomerPaymentPreferenceUpdateArgs<ExtArgs>>): Prisma__CustomerPaymentPreferenceClient<$Result.GetResult<Prisma.$CustomerPaymentPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerPaymentPreferences.
     * @param {CustomerPaymentPreferenceDeleteManyArgs} args - Arguments to filter CustomerPaymentPreferences to delete.
     * @example
     * // Delete a few CustomerPaymentPreferences
     * const { count } = await prisma.customerPaymentPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerPaymentPreferenceDeleteManyArgs>(args?: SelectSubset<T, CustomerPaymentPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPaymentPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPaymentPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerPaymentPreferences
     * const customerPaymentPreference = await prisma.customerPaymentPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerPaymentPreferenceUpdateManyArgs>(args: SelectSubset<T, CustomerPaymentPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPaymentPreferences and returns the data updated in the database.
     * @param {CustomerPaymentPreferenceUpdateManyAndReturnArgs} args - Arguments to update many CustomerPaymentPreferences.
     * @example
     * // Update many CustomerPaymentPreferences
     * const customerPaymentPreference = await prisma.customerPaymentPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerPaymentPreferences and only return the `id`
     * const customerPaymentPreferenceWithIdOnly = await prisma.customerPaymentPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerPaymentPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerPaymentPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPaymentPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerPaymentPreference.
     * @param {CustomerPaymentPreferenceUpsertArgs} args - Arguments to update or create a CustomerPaymentPreference.
     * @example
     * // Update or create a CustomerPaymentPreference
     * const customerPaymentPreference = await prisma.customerPaymentPreference.upsert({
     *   create: {
     *     // ... data to create a CustomerPaymentPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerPaymentPreference we want to update
     *   }
     * })
     */
    upsert<T extends CustomerPaymentPreferenceUpsertArgs>(args: SelectSubset<T, CustomerPaymentPreferenceUpsertArgs<ExtArgs>>): Prisma__CustomerPaymentPreferenceClient<$Result.GetResult<Prisma.$CustomerPaymentPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerPaymentPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPaymentPreferenceCountArgs} args - Arguments to filter CustomerPaymentPreferences to count.
     * @example
     * // Count the number of CustomerPaymentPreferences
     * const count = await prisma.customerPaymentPreference.count({
     *   where: {
     *     // ... the filter for the CustomerPaymentPreferences we want to count
     *   }
     * })
    **/
    count<T extends CustomerPaymentPreferenceCountArgs>(
      args?: Subset<T, CustomerPaymentPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerPaymentPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerPaymentPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPaymentPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerPaymentPreferenceAggregateArgs>(args: Subset<T, CustomerPaymentPreferenceAggregateArgs>): Prisma.PrismaPromise<GetCustomerPaymentPreferenceAggregateType<T>>

    /**
     * Group by CustomerPaymentPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPaymentPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerPaymentPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerPaymentPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: CustomerPaymentPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerPaymentPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerPaymentPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerPaymentPreference model
   */
  readonly fields: CustomerPaymentPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerPaymentPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerPaymentPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerPaymentPreference model
   */
  interface CustomerPaymentPreferenceFieldRefs {
    readonly id: FieldRef<"CustomerPaymentPreference", 'String'>
    readonly tenantId: FieldRef<"CustomerPaymentPreference", 'String'>
    readonly userId: FieldRef<"CustomerPaymentPreference", 'String'>
    readonly preferredMethod: FieldRef<"CustomerPaymentPreference", 'String'>
    readonly cityTier: FieldRef<"CustomerPaymentPreference", 'String'>
    readonly lastPaymentMethod: FieldRef<"CustomerPaymentPreference", 'String'>
    readonly totalBookings: FieldRef<"CustomerPaymentPreference", 'Int'>
    readonly totalOnlinePayments: FieldRef<"CustomerPaymentPreference", 'Int'>
    readonly createdAt: FieldRef<"CustomerPaymentPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerPaymentPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerPaymentPreference findUnique
   */
  export type CustomerPaymentPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentPreference
     */
    select?: CustomerPaymentPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentPreference
     */
    omit?: CustomerPaymentPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPaymentPreference to fetch.
     */
    where: CustomerPaymentPreferenceWhereUniqueInput
  }

  /**
   * CustomerPaymentPreference findUniqueOrThrow
   */
  export type CustomerPaymentPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentPreference
     */
    select?: CustomerPaymentPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentPreference
     */
    omit?: CustomerPaymentPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPaymentPreference to fetch.
     */
    where: CustomerPaymentPreferenceWhereUniqueInput
  }

  /**
   * CustomerPaymentPreference findFirst
   */
  export type CustomerPaymentPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentPreference
     */
    select?: CustomerPaymentPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentPreference
     */
    omit?: CustomerPaymentPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPaymentPreference to fetch.
     */
    where?: CustomerPaymentPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPaymentPreferences to fetch.
     */
    orderBy?: CustomerPaymentPreferenceOrderByWithRelationInput | CustomerPaymentPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPaymentPreferences.
     */
    cursor?: CustomerPaymentPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPaymentPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPaymentPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPaymentPreferences.
     */
    distinct?: CustomerPaymentPreferenceScalarFieldEnum | CustomerPaymentPreferenceScalarFieldEnum[]
  }

  /**
   * CustomerPaymentPreference findFirstOrThrow
   */
  export type CustomerPaymentPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentPreference
     */
    select?: CustomerPaymentPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentPreference
     */
    omit?: CustomerPaymentPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPaymentPreference to fetch.
     */
    where?: CustomerPaymentPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPaymentPreferences to fetch.
     */
    orderBy?: CustomerPaymentPreferenceOrderByWithRelationInput | CustomerPaymentPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPaymentPreferences.
     */
    cursor?: CustomerPaymentPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPaymentPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPaymentPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPaymentPreferences.
     */
    distinct?: CustomerPaymentPreferenceScalarFieldEnum | CustomerPaymentPreferenceScalarFieldEnum[]
  }

  /**
   * CustomerPaymentPreference findMany
   */
  export type CustomerPaymentPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentPreference
     */
    select?: CustomerPaymentPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentPreference
     */
    omit?: CustomerPaymentPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPaymentPreferences to fetch.
     */
    where?: CustomerPaymentPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPaymentPreferences to fetch.
     */
    orderBy?: CustomerPaymentPreferenceOrderByWithRelationInput | CustomerPaymentPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerPaymentPreferences.
     */
    cursor?: CustomerPaymentPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPaymentPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPaymentPreferences.
     */
    skip?: number
    distinct?: CustomerPaymentPreferenceScalarFieldEnum | CustomerPaymentPreferenceScalarFieldEnum[]
  }

  /**
   * CustomerPaymentPreference create
   */
  export type CustomerPaymentPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentPreference
     */
    select?: CustomerPaymentPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentPreference
     */
    omit?: CustomerPaymentPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerPaymentPreference.
     */
    data: XOR<CustomerPaymentPreferenceCreateInput, CustomerPaymentPreferenceUncheckedCreateInput>
  }

  /**
   * CustomerPaymentPreference createMany
   */
  export type CustomerPaymentPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerPaymentPreferences.
     */
    data: CustomerPaymentPreferenceCreateManyInput | CustomerPaymentPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerPaymentPreference createManyAndReturn
   */
  export type CustomerPaymentPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentPreference
     */
    select?: CustomerPaymentPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentPreference
     */
    omit?: CustomerPaymentPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerPaymentPreferences.
     */
    data: CustomerPaymentPreferenceCreateManyInput | CustomerPaymentPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPaymentPreference update
   */
  export type CustomerPaymentPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentPreference
     */
    select?: CustomerPaymentPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentPreference
     */
    omit?: CustomerPaymentPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerPaymentPreference.
     */
    data: XOR<CustomerPaymentPreferenceUpdateInput, CustomerPaymentPreferenceUncheckedUpdateInput>
    /**
     * Choose, which CustomerPaymentPreference to update.
     */
    where: CustomerPaymentPreferenceWhereUniqueInput
  }

  /**
   * CustomerPaymentPreference updateMany
   */
  export type CustomerPaymentPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerPaymentPreferences.
     */
    data: XOR<CustomerPaymentPreferenceUpdateManyMutationInput, CustomerPaymentPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPaymentPreferences to update
     */
    where?: CustomerPaymentPreferenceWhereInput
    /**
     * Limit how many CustomerPaymentPreferences to update.
     */
    limit?: number
  }

  /**
   * CustomerPaymentPreference updateManyAndReturn
   */
  export type CustomerPaymentPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentPreference
     */
    select?: CustomerPaymentPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentPreference
     */
    omit?: CustomerPaymentPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update CustomerPaymentPreferences.
     */
    data: XOR<CustomerPaymentPreferenceUpdateManyMutationInput, CustomerPaymentPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPaymentPreferences to update
     */
    where?: CustomerPaymentPreferenceWhereInput
    /**
     * Limit how many CustomerPaymentPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPaymentPreference upsert
   */
  export type CustomerPaymentPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentPreference
     */
    select?: CustomerPaymentPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentPreference
     */
    omit?: CustomerPaymentPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerPaymentPreference to update in case it exists.
     */
    where: CustomerPaymentPreferenceWhereUniqueInput
    /**
     * In case the CustomerPaymentPreference found by the `where` argument doesn't exist, create a new CustomerPaymentPreference with this data.
     */
    create: XOR<CustomerPaymentPreferenceCreateInput, CustomerPaymentPreferenceUncheckedCreateInput>
    /**
     * In case the CustomerPaymentPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerPaymentPreferenceUpdateInput, CustomerPaymentPreferenceUncheckedUpdateInput>
  }

  /**
   * CustomerPaymentPreference delete
   */
  export type CustomerPaymentPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentPreference
     */
    select?: CustomerPaymentPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentPreference
     */
    omit?: CustomerPaymentPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentPreferenceInclude<ExtArgs> | null
    /**
     * Filter which CustomerPaymentPreference to delete.
     */
    where: CustomerPaymentPreferenceWhereUniqueInput
  }

  /**
   * CustomerPaymentPreference deleteMany
   */
  export type CustomerPaymentPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPaymentPreferences to delete
     */
    where?: CustomerPaymentPreferenceWhereInput
    /**
     * Limit how many CustomerPaymentPreferences to delete.
     */
    limit?: number
  }

  /**
   * CustomerPaymentPreference without action
   */
  export type CustomerPaymentPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPaymentPreference
     */
    select?: CustomerPaymentPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPaymentPreference
     */
    omit?: CustomerPaymentPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPaymentPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model VenueOnboardingResponse
   */

  export type AggregateVenueOnboardingResponse = {
    _count: VenueOnboardingResponseCountAggregateOutputType | null
    _avg: VenueOnboardingResponseAvgAggregateOutputType | null
    _sum: VenueOnboardingResponseSumAggregateOutputType | null
    _min: VenueOnboardingResponseMinAggregateOutputType | null
    _max: VenueOnboardingResponseMaxAggregateOutputType | null
  }

  export type VenueOnboardingResponseAvgAggregateOutputType = {
    monthlyBookingVolume: number | null
    averageBookingValueCents: number | null
  }

  export type VenueOnboardingResponseSumAggregateOutputType = {
    monthlyBookingVolume: number | null
    averageBookingValueCents: number | null
  }

  export type VenueOnboardingResponseMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    venueId: string | null
    paymentPreference: string | null
    techComfortLevel: string | null
    monthlyBookingVolume: number | null
    averageBookingValueCents: number | null
    createdAt: Date | null
  }

  export type VenueOnboardingResponseMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    venueId: string | null
    paymentPreference: string | null
    techComfortLevel: string | null
    monthlyBookingVolume: number | null
    averageBookingValueCents: number | null
    createdAt: Date | null
  }

  export type VenueOnboardingResponseCountAggregateOutputType = {
    id: number
    tenantId: number
    venueId: number
    paymentPreference: number
    techComfortLevel: number
    currentPaymentMethods: number
    monthlyBookingVolume: number
    averageBookingValueCents: number
    responses: number
    createdAt: number
    _all: number
  }


  export type VenueOnboardingResponseAvgAggregateInputType = {
    monthlyBookingVolume?: true
    averageBookingValueCents?: true
  }

  export type VenueOnboardingResponseSumAggregateInputType = {
    monthlyBookingVolume?: true
    averageBookingValueCents?: true
  }

  export type VenueOnboardingResponseMinAggregateInputType = {
    id?: true
    tenantId?: true
    venueId?: true
    paymentPreference?: true
    techComfortLevel?: true
    monthlyBookingVolume?: true
    averageBookingValueCents?: true
    createdAt?: true
  }

  export type VenueOnboardingResponseMaxAggregateInputType = {
    id?: true
    tenantId?: true
    venueId?: true
    paymentPreference?: true
    techComfortLevel?: true
    monthlyBookingVolume?: true
    averageBookingValueCents?: true
    createdAt?: true
  }

  export type VenueOnboardingResponseCountAggregateInputType = {
    id?: true
    tenantId?: true
    venueId?: true
    paymentPreference?: true
    techComfortLevel?: true
    currentPaymentMethods?: true
    monthlyBookingVolume?: true
    averageBookingValueCents?: true
    responses?: true
    createdAt?: true
    _all?: true
  }

  export type VenueOnboardingResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VenueOnboardingResponse to aggregate.
     */
    where?: VenueOnboardingResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueOnboardingResponses to fetch.
     */
    orderBy?: VenueOnboardingResponseOrderByWithRelationInput | VenueOnboardingResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenueOnboardingResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueOnboardingResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueOnboardingResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VenueOnboardingResponses
    **/
    _count?: true | VenueOnboardingResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenueOnboardingResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenueOnboardingResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenueOnboardingResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenueOnboardingResponseMaxAggregateInputType
  }

  export type GetVenueOnboardingResponseAggregateType<T extends VenueOnboardingResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateVenueOnboardingResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenueOnboardingResponse[P]>
      : GetScalarType<T[P], AggregateVenueOnboardingResponse[P]>
  }




  export type VenueOnboardingResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueOnboardingResponseWhereInput
    orderBy?: VenueOnboardingResponseOrderByWithAggregationInput | VenueOnboardingResponseOrderByWithAggregationInput[]
    by: VenueOnboardingResponseScalarFieldEnum[] | VenueOnboardingResponseScalarFieldEnum
    having?: VenueOnboardingResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenueOnboardingResponseCountAggregateInputType | true
    _avg?: VenueOnboardingResponseAvgAggregateInputType
    _sum?: VenueOnboardingResponseSumAggregateInputType
    _min?: VenueOnboardingResponseMinAggregateInputType
    _max?: VenueOnboardingResponseMaxAggregateInputType
  }

  export type VenueOnboardingResponseGroupByOutputType = {
    id: string
    tenantId: string
    venueId: string
    paymentPreference: string | null
    techComfortLevel: string | null
    currentPaymentMethods: JsonValue | null
    monthlyBookingVolume: number | null
    averageBookingValueCents: number | null
    responses: JsonValue | null
    createdAt: Date
    _count: VenueOnboardingResponseCountAggregateOutputType | null
    _avg: VenueOnboardingResponseAvgAggregateOutputType | null
    _sum: VenueOnboardingResponseSumAggregateOutputType | null
    _min: VenueOnboardingResponseMinAggregateOutputType | null
    _max: VenueOnboardingResponseMaxAggregateOutputType | null
  }

  type GetVenueOnboardingResponseGroupByPayload<T extends VenueOnboardingResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenueOnboardingResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenueOnboardingResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenueOnboardingResponseGroupByOutputType[P]>
            : GetScalarType<T[P], VenueOnboardingResponseGroupByOutputType[P]>
        }
      >
    >


  export type VenueOnboardingResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    venueId?: boolean
    paymentPreference?: boolean
    techComfortLevel?: boolean
    currentPaymentMethods?: boolean
    monthlyBookingVolume?: boolean
    averageBookingValueCents?: boolean
    responses?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venueOnboardingResponse"]>

  export type VenueOnboardingResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    venueId?: boolean
    paymentPreference?: boolean
    techComfortLevel?: boolean
    currentPaymentMethods?: boolean
    monthlyBookingVolume?: boolean
    averageBookingValueCents?: boolean
    responses?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venueOnboardingResponse"]>

  export type VenueOnboardingResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    venueId?: boolean
    paymentPreference?: boolean
    techComfortLevel?: boolean
    currentPaymentMethods?: boolean
    monthlyBookingVolume?: boolean
    averageBookingValueCents?: boolean
    responses?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venueOnboardingResponse"]>

  export type VenueOnboardingResponseSelectScalar = {
    id?: boolean
    tenantId?: boolean
    venueId?: boolean
    paymentPreference?: boolean
    techComfortLevel?: boolean
    currentPaymentMethods?: boolean
    monthlyBookingVolume?: boolean
    averageBookingValueCents?: boolean
    responses?: boolean
    createdAt?: boolean
  }

  export type VenueOnboardingResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "venueId" | "paymentPreference" | "techComfortLevel" | "currentPaymentMethods" | "monthlyBookingVolume" | "averageBookingValueCents" | "responses" | "createdAt", ExtArgs["result"]["venueOnboardingResponse"]>
  export type VenueOnboardingResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }
  export type VenueOnboardingResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }
  export type VenueOnboardingResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $VenueOnboardingResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VenueOnboardingResponse"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      venueId: string
      paymentPreference: string | null
      techComfortLevel: string | null
      currentPaymentMethods: Prisma.JsonValue | null
      monthlyBookingVolume: number | null
      averageBookingValueCents: number | null
      responses: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["venueOnboardingResponse"]>
    composites: {}
  }

  type VenueOnboardingResponseGetPayload<S extends boolean | null | undefined | VenueOnboardingResponseDefaultArgs> = $Result.GetResult<Prisma.$VenueOnboardingResponsePayload, S>

  type VenueOnboardingResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VenueOnboardingResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VenueOnboardingResponseCountAggregateInputType | true
    }

  export interface VenueOnboardingResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VenueOnboardingResponse'], meta: { name: 'VenueOnboardingResponse' } }
    /**
     * Find zero or one VenueOnboardingResponse that matches the filter.
     * @param {VenueOnboardingResponseFindUniqueArgs} args - Arguments to find a VenueOnboardingResponse
     * @example
     * // Get one VenueOnboardingResponse
     * const venueOnboardingResponse = await prisma.venueOnboardingResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenueOnboardingResponseFindUniqueArgs>(args: SelectSubset<T, VenueOnboardingResponseFindUniqueArgs<ExtArgs>>): Prisma__VenueOnboardingResponseClient<$Result.GetResult<Prisma.$VenueOnboardingResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VenueOnboardingResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VenueOnboardingResponseFindUniqueOrThrowArgs} args - Arguments to find a VenueOnboardingResponse
     * @example
     * // Get one VenueOnboardingResponse
     * const venueOnboardingResponse = await prisma.venueOnboardingResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenueOnboardingResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, VenueOnboardingResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenueOnboardingResponseClient<$Result.GetResult<Prisma.$VenueOnboardingResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VenueOnboardingResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueOnboardingResponseFindFirstArgs} args - Arguments to find a VenueOnboardingResponse
     * @example
     * // Get one VenueOnboardingResponse
     * const venueOnboardingResponse = await prisma.venueOnboardingResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenueOnboardingResponseFindFirstArgs>(args?: SelectSubset<T, VenueOnboardingResponseFindFirstArgs<ExtArgs>>): Prisma__VenueOnboardingResponseClient<$Result.GetResult<Prisma.$VenueOnboardingResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VenueOnboardingResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueOnboardingResponseFindFirstOrThrowArgs} args - Arguments to find a VenueOnboardingResponse
     * @example
     * // Get one VenueOnboardingResponse
     * const venueOnboardingResponse = await prisma.venueOnboardingResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenueOnboardingResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, VenueOnboardingResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenueOnboardingResponseClient<$Result.GetResult<Prisma.$VenueOnboardingResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VenueOnboardingResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueOnboardingResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VenueOnboardingResponses
     * const venueOnboardingResponses = await prisma.venueOnboardingResponse.findMany()
     * 
     * // Get first 10 VenueOnboardingResponses
     * const venueOnboardingResponses = await prisma.venueOnboardingResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venueOnboardingResponseWithIdOnly = await prisma.venueOnboardingResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VenueOnboardingResponseFindManyArgs>(args?: SelectSubset<T, VenueOnboardingResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenueOnboardingResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VenueOnboardingResponse.
     * @param {VenueOnboardingResponseCreateArgs} args - Arguments to create a VenueOnboardingResponse.
     * @example
     * // Create one VenueOnboardingResponse
     * const VenueOnboardingResponse = await prisma.venueOnboardingResponse.create({
     *   data: {
     *     // ... data to create a VenueOnboardingResponse
     *   }
     * })
     * 
     */
    create<T extends VenueOnboardingResponseCreateArgs>(args: SelectSubset<T, VenueOnboardingResponseCreateArgs<ExtArgs>>): Prisma__VenueOnboardingResponseClient<$Result.GetResult<Prisma.$VenueOnboardingResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VenueOnboardingResponses.
     * @param {VenueOnboardingResponseCreateManyArgs} args - Arguments to create many VenueOnboardingResponses.
     * @example
     * // Create many VenueOnboardingResponses
     * const venueOnboardingResponse = await prisma.venueOnboardingResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenueOnboardingResponseCreateManyArgs>(args?: SelectSubset<T, VenueOnboardingResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VenueOnboardingResponses and returns the data saved in the database.
     * @param {VenueOnboardingResponseCreateManyAndReturnArgs} args - Arguments to create many VenueOnboardingResponses.
     * @example
     * // Create many VenueOnboardingResponses
     * const venueOnboardingResponse = await prisma.venueOnboardingResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VenueOnboardingResponses and only return the `id`
     * const venueOnboardingResponseWithIdOnly = await prisma.venueOnboardingResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VenueOnboardingResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, VenueOnboardingResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenueOnboardingResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VenueOnboardingResponse.
     * @param {VenueOnboardingResponseDeleteArgs} args - Arguments to delete one VenueOnboardingResponse.
     * @example
     * // Delete one VenueOnboardingResponse
     * const VenueOnboardingResponse = await prisma.venueOnboardingResponse.delete({
     *   where: {
     *     // ... filter to delete one VenueOnboardingResponse
     *   }
     * })
     * 
     */
    delete<T extends VenueOnboardingResponseDeleteArgs>(args: SelectSubset<T, VenueOnboardingResponseDeleteArgs<ExtArgs>>): Prisma__VenueOnboardingResponseClient<$Result.GetResult<Prisma.$VenueOnboardingResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VenueOnboardingResponse.
     * @param {VenueOnboardingResponseUpdateArgs} args - Arguments to update one VenueOnboardingResponse.
     * @example
     * // Update one VenueOnboardingResponse
     * const venueOnboardingResponse = await prisma.venueOnboardingResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenueOnboardingResponseUpdateArgs>(args: SelectSubset<T, VenueOnboardingResponseUpdateArgs<ExtArgs>>): Prisma__VenueOnboardingResponseClient<$Result.GetResult<Prisma.$VenueOnboardingResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VenueOnboardingResponses.
     * @param {VenueOnboardingResponseDeleteManyArgs} args - Arguments to filter VenueOnboardingResponses to delete.
     * @example
     * // Delete a few VenueOnboardingResponses
     * const { count } = await prisma.venueOnboardingResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenueOnboardingResponseDeleteManyArgs>(args?: SelectSubset<T, VenueOnboardingResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VenueOnboardingResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueOnboardingResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VenueOnboardingResponses
     * const venueOnboardingResponse = await prisma.venueOnboardingResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenueOnboardingResponseUpdateManyArgs>(args: SelectSubset<T, VenueOnboardingResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VenueOnboardingResponses and returns the data updated in the database.
     * @param {VenueOnboardingResponseUpdateManyAndReturnArgs} args - Arguments to update many VenueOnboardingResponses.
     * @example
     * // Update many VenueOnboardingResponses
     * const venueOnboardingResponse = await prisma.venueOnboardingResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VenueOnboardingResponses and only return the `id`
     * const venueOnboardingResponseWithIdOnly = await prisma.venueOnboardingResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VenueOnboardingResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, VenueOnboardingResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenueOnboardingResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VenueOnboardingResponse.
     * @param {VenueOnboardingResponseUpsertArgs} args - Arguments to update or create a VenueOnboardingResponse.
     * @example
     * // Update or create a VenueOnboardingResponse
     * const venueOnboardingResponse = await prisma.venueOnboardingResponse.upsert({
     *   create: {
     *     // ... data to create a VenueOnboardingResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VenueOnboardingResponse we want to update
     *   }
     * })
     */
    upsert<T extends VenueOnboardingResponseUpsertArgs>(args: SelectSubset<T, VenueOnboardingResponseUpsertArgs<ExtArgs>>): Prisma__VenueOnboardingResponseClient<$Result.GetResult<Prisma.$VenueOnboardingResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VenueOnboardingResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueOnboardingResponseCountArgs} args - Arguments to filter VenueOnboardingResponses to count.
     * @example
     * // Count the number of VenueOnboardingResponses
     * const count = await prisma.venueOnboardingResponse.count({
     *   where: {
     *     // ... the filter for the VenueOnboardingResponses we want to count
     *   }
     * })
    **/
    count<T extends VenueOnboardingResponseCountArgs>(
      args?: Subset<T, VenueOnboardingResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenueOnboardingResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VenueOnboardingResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueOnboardingResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenueOnboardingResponseAggregateArgs>(args: Subset<T, VenueOnboardingResponseAggregateArgs>): Prisma.PrismaPromise<GetVenueOnboardingResponseAggregateType<T>>

    /**
     * Group by VenueOnboardingResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueOnboardingResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenueOnboardingResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenueOnboardingResponseGroupByArgs['orderBy'] }
        : { orderBy?: VenueOnboardingResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenueOnboardingResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenueOnboardingResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VenueOnboardingResponse model
   */
  readonly fields: VenueOnboardingResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VenueOnboardingResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenueOnboardingResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VenueOnboardingResponse model
   */
  interface VenueOnboardingResponseFieldRefs {
    readonly id: FieldRef<"VenueOnboardingResponse", 'String'>
    readonly tenantId: FieldRef<"VenueOnboardingResponse", 'String'>
    readonly venueId: FieldRef<"VenueOnboardingResponse", 'String'>
    readonly paymentPreference: FieldRef<"VenueOnboardingResponse", 'String'>
    readonly techComfortLevel: FieldRef<"VenueOnboardingResponse", 'String'>
    readonly currentPaymentMethods: FieldRef<"VenueOnboardingResponse", 'Json'>
    readonly monthlyBookingVolume: FieldRef<"VenueOnboardingResponse", 'Int'>
    readonly averageBookingValueCents: FieldRef<"VenueOnboardingResponse", 'Int'>
    readonly responses: FieldRef<"VenueOnboardingResponse", 'Json'>
    readonly createdAt: FieldRef<"VenueOnboardingResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VenueOnboardingResponse findUnique
   */
  export type VenueOnboardingResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueOnboardingResponse
     */
    select?: VenueOnboardingResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueOnboardingResponse
     */
    omit?: VenueOnboardingResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueOnboardingResponseInclude<ExtArgs> | null
    /**
     * Filter, which VenueOnboardingResponse to fetch.
     */
    where: VenueOnboardingResponseWhereUniqueInput
  }

  /**
   * VenueOnboardingResponse findUniqueOrThrow
   */
  export type VenueOnboardingResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueOnboardingResponse
     */
    select?: VenueOnboardingResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueOnboardingResponse
     */
    omit?: VenueOnboardingResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueOnboardingResponseInclude<ExtArgs> | null
    /**
     * Filter, which VenueOnboardingResponse to fetch.
     */
    where: VenueOnboardingResponseWhereUniqueInput
  }

  /**
   * VenueOnboardingResponse findFirst
   */
  export type VenueOnboardingResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueOnboardingResponse
     */
    select?: VenueOnboardingResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueOnboardingResponse
     */
    omit?: VenueOnboardingResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueOnboardingResponseInclude<ExtArgs> | null
    /**
     * Filter, which VenueOnboardingResponse to fetch.
     */
    where?: VenueOnboardingResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueOnboardingResponses to fetch.
     */
    orderBy?: VenueOnboardingResponseOrderByWithRelationInput | VenueOnboardingResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VenueOnboardingResponses.
     */
    cursor?: VenueOnboardingResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueOnboardingResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueOnboardingResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VenueOnboardingResponses.
     */
    distinct?: VenueOnboardingResponseScalarFieldEnum | VenueOnboardingResponseScalarFieldEnum[]
  }

  /**
   * VenueOnboardingResponse findFirstOrThrow
   */
  export type VenueOnboardingResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueOnboardingResponse
     */
    select?: VenueOnboardingResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueOnboardingResponse
     */
    omit?: VenueOnboardingResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueOnboardingResponseInclude<ExtArgs> | null
    /**
     * Filter, which VenueOnboardingResponse to fetch.
     */
    where?: VenueOnboardingResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueOnboardingResponses to fetch.
     */
    orderBy?: VenueOnboardingResponseOrderByWithRelationInput | VenueOnboardingResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VenueOnboardingResponses.
     */
    cursor?: VenueOnboardingResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueOnboardingResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueOnboardingResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VenueOnboardingResponses.
     */
    distinct?: VenueOnboardingResponseScalarFieldEnum | VenueOnboardingResponseScalarFieldEnum[]
  }

  /**
   * VenueOnboardingResponse findMany
   */
  export type VenueOnboardingResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueOnboardingResponse
     */
    select?: VenueOnboardingResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueOnboardingResponse
     */
    omit?: VenueOnboardingResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueOnboardingResponseInclude<ExtArgs> | null
    /**
     * Filter, which VenueOnboardingResponses to fetch.
     */
    where?: VenueOnboardingResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueOnboardingResponses to fetch.
     */
    orderBy?: VenueOnboardingResponseOrderByWithRelationInput | VenueOnboardingResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VenueOnboardingResponses.
     */
    cursor?: VenueOnboardingResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueOnboardingResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueOnboardingResponses.
     */
    skip?: number
    distinct?: VenueOnboardingResponseScalarFieldEnum | VenueOnboardingResponseScalarFieldEnum[]
  }

  /**
   * VenueOnboardingResponse create
   */
  export type VenueOnboardingResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueOnboardingResponse
     */
    select?: VenueOnboardingResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueOnboardingResponse
     */
    omit?: VenueOnboardingResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueOnboardingResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a VenueOnboardingResponse.
     */
    data: XOR<VenueOnboardingResponseCreateInput, VenueOnboardingResponseUncheckedCreateInput>
  }

  /**
   * VenueOnboardingResponse createMany
   */
  export type VenueOnboardingResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VenueOnboardingResponses.
     */
    data: VenueOnboardingResponseCreateManyInput | VenueOnboardingResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VenueOnboardingResponse createManyAndReturn
   */
  export type VenueOnboardingResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueOnboardingResponse
     */
    select?: VenueOnboardingResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VenueOnboardingResponse
     */
    omit?: VenueOnboardingResponseOmit<ExtArgs> | null
    /**
     * The data used to create many VenueOnboardingResponses.
     */
    data: VenueOnboardingResponseCreateManyInput | VenueOnboardingResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueOnboardingResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VenueOnboardingResponse update
   */
  export type VenueOnboardingResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueOnboardingResponse
     */
    select?: VenueOnboardingResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueOnboardingResponse
     */
    omit?: VenueOnboardingResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueOnboardingResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a VenueOnboardingResponse.
     */
    data: XOR<VenueOnboardingResponseUpdateInput, VenueOnboardingResponseUncheckedUpdateInput>
    /**
     * Choose, which VenueOnboardingResponse to update.
     */
    where: VenueOnboardingResponseWhereUniqueInput
  }

  /**
   * VenueOnboardingResponse updateMany
   */
  export type VenueOnboardingResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VenueOnboardingResponses.
     */
    data: XOR<VenueOnboardingResponseUpdateManyMutationInput, VenueOnboardingResponseUncheckedUpdateManyInput>
    /**
     * Filter which VenueOnboardingResponses to update
     */
    where?: VenueOnboardingResponseWhereInput
    /**
     * Limit how many VenueOnboardingResponses to update.
     */
    limit?: number
  }

  /**
   * VenueOnboardingResponse updateManyAndReturn
   */
  export type VenueOnboardingResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueOnboardingResponse
     */
    select?: VenueOnboardingResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VenueOnboardingResponse
     */
    omit?: VenueOnboardingResponseOmit<ExtArgs> | null
    /**
     * The data used to update VenueOnboardingResponses.
     */
    data: XOR<VenueOnboardingResponseUpdateManyMutationInput, VenueOnboardingResponseUncheckedUpdateManyInput>
    /**
     * Filter which VenueOnboardingResponses to update
     */
    where?: VenueOnboardingResponseWhereInput
    /**
     * Limit how many VenueOnboardingResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueOnboardingResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VenueOnboardingResponse upsert
   */
  export type VenueOnboardingResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueOnboardingResponse
     */
    select?: VenueOnboardingResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueOnboardingResponse
     */
    omit?: VenueOnboardingResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueOnboardingResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the VenueOnboardingResponse to update in case it exists.
     */
    where: VenueOnboardingResponseWhereUniqueInput
    /**
     * In case the VenueOnboardingResponse found by the `where` argument doesn't exist, create a new VenueOnboardingResponse with this data.
     */
    create: XOR<VenueOnboardingResponseCreateInput, VenueOnboardingResponseUncheckedCreateInput>
    /**
     * In case the VenueOnboardingResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenueOnboardingResponseUpdateInput, VenueOnboardingResponseUncheckedUpdateInput>
  }

  /**
   * VenueOnboardingResponse delete
   */
  export type VenueOnboardingResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueOnboardingResponse
     */
    select?: VenueOnboardingResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueOnboardingResponse
     */
    omit?: VenueOnboardingResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueOnboardingResponseInclude<ExtArgs> | null
    /**
     * Filter which VenueOnboardingResponse to delete.
     */
    where: VenueOnboardingResponseWhereUniqueInput
  }

  /**
   * VenueOnboardingResponse deleteMany
   */
  export type VenueOnboardingResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VenueOnboardingResponses to delete
     */
    where?: VenueOnboardingResponseWhereInput
    /**
     * Limit how many VenueOnboardingResponses to delete.
     */
    limit?: number
  }

  /**
   * VenueOnboardingResponse without action
   */
  export type VenueOnboardingResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueOnboardingResponse
     */
    select?: VenueOnboardingResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueOnboardingResponse
     */
    omit?: VenueOnboardingResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueOnboardingResponseInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const VenueScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    address: 'address',
    capacity: 'capacity',
    basePriceCents: 'basePriceCents',
    currency: 'currency',
    timeZone: 'timeZone',
    settings: 'settings',
    isActive: 'isActive',
    paymentProfile: 'paymentProfile',
    allowCashPayments: 'allowCashPayments',
    cashDiscountPercentage: 'cashDiscountPercentage',
    requiresOnlineDeposit: 'requiresOnlineDeposit',
    depositType: 'depositType',
    depositAmount: 'depositAmount',
    hasRazorpayAccount: 'hasRazorpayAccount',
    razorpayKeyId: 'razorpayKeyId',
    razorpayKeySecretEncrypted: 'razorpayKeySecretEncrypted',
    platformHandlesPayments: 'platformHandlesPayments',
    confirmationTrigger: 'confirmationTrigger',
    platformCommissionPercentage: 'platformCommissionPercentage',
    paymentDueDaysBeforeEvent: 'paymentDueDaysBeforeEvent',
    autoExpireUnpaidBookings: 'autoExpireUnpaidBookings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VenueScalarFieldEnum = (typeof VenueScalarFieldEnum)[keyof typeof VenueScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    phone: 'phone',
    email: 'email',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    venueId: 'venueId',
    userId: 'userId',
    bookingNumber: 'bookingNumber',
    startTs: 'startTs',
    endTs: 'endTs',
    status: 'status',
    holdExpiresAt: 'holdExpiresAt',
    totalAmountCents: 'totalAmountCents',
    currency: 'currency',
    paymentStatus: 'paymentStatus',
    paymentMethod: 'paymentMethod',
    onlineAmountDue: 'onlineAmountDue',
    cashAmountDue: 'cashAmountDue',
    cashDiscountApplied: 'cashDiscountApplied',
    paymentDueDate: 'paymentDueDate',
    cashPaymentAcknowledged: 'cashPaymentAcknowledged',
    requiresManualConfirmation: 'requiresManualConfirmation',
    confirmedBy: 'confirmedBy',
    idempotencyKey: 'idempotencyKey',
    eventType: 'eventType',
    guestCount: 'guestCount',
    specialRequests: 'specialRequests',
    meta: 'meta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const BlackoutScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    venueId: 'venueId',
    startTs: 'startTs',
    endTs: 'endTs',
    reason: 'reason',
    isMaintenance: 'isMaintenance',
    createdAt: 'createdAt'
  };

  export type BlackoutScalarFieldEnum = (typeof BlackoutScalarFieldEnum)[keyof typeof BlackoutScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    bookingId: 'bookingId',
    provider: 'provider',
    providerPaymentId: 'providerPaymentId',
    amountCents: 'amountCents',
    currency: 'currency',
    status: 'status',
    gatewayResponse: 'gatewayResponse',
    processedAt: 'processedAt',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const CashPaymentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    bookingId: 'bookingId',
    amountCents: 'amountCents',
    recordedBy: 'recordedBy',
    recordedAt: 'recordedAt',
    paymentMethod: 'paymentMethod',
    notes: 'notes',
    receiptNumber: 'receiptNumber',
    verificationStatus: 'verificationStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CashPaymentScalarFieldEnum = (typeof CashPaymentScalarFieldEnum)[keyof typeof CashPaymentScalarFieldEnum]


  export const CommissionRecordScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    bookingId: 'bookingId',
    venueId: 'venueId',
    bookingAmountCents: 'bookingAmountCents',
    commissionPercentage: 'commissionPercentage',
    commissionAmountCents: 'commissionAmountCents',
    commissionStatus: 'commissionStatus',
    collectionMethod: 'collectionMethod',
    collectedAt: 'collectedAt',
    dueDate: 'dueDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommissionRecordScalarFieldEnum = (typeof CommissionRecordScalarFieldEnum)[keyof typeof CommissionRecordScalarFieldEnum]


  export const CustomerPaymentPreferenceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    preferredMethod: 'preferredMethod',
    cityTier: 'cityTier',
    lastPaymentMethod: 'lastPaymentMethod',
    totalBookings: 'totalBookings',
    totalOnlinePayments: 'totalOnlinePayments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerPaymentPreferenceScalarFieldEnum = (typeof CustomerPaymentPreferenceScalarFieldEnum)[keyof typeof CustomerPaymentPreferenceScalarFieldEnum]


  export const VenueOnboardingResponseScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    venueId: 'venueId',
    paymentPreference: 'paymentPreference',
    techComfortLevel: 'techComfortLevel',
    currentPaymentMethods: 'currentPaymentMethods',
    monthlyBookingVolume: 'monthlyBookingVolume',
    averageBookingValueCents: 'averageBookingValueCents',
    responses: 'responses',
    createdAt: 'createdAt'
  };

  export type VenueOnboardingResponseScalarFieldEnum = (typeof VenueOnboardingResponseScalarFieldEnum)[keyof typeof VenueOnboardingResponseScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: UuidFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    slug?: StringFilter<"Tenant"> | string
    settings?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    venues?: VenueListRelationFilter
    users?: UserListRelationFilter
    bookings?: BookingListRelationFilter
    payments?: PaymentListRelationFilter
    blackouts?: BlackoutListRelationFilter
    cashPayments?: CashPaymentListRelationFilter
    commissionRecords?: CommissionRecordListRelationFilter
    customerPaymentPreferences?: CustomerPaymentPreferenceListRelationFilter
    venueOnboardingResponses?: VenueOnboardingResponseListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venues?: VenueOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    blackouts?: BlackoutOrderByRelationAggregateInput
    cashPayments?: CashPaymentOrderByRelationAggregateInput
    commissionRecords?: CommissionRecordOrderByRelationAggregateInput
    customerPaymentPreferences?: CustomerPaymentPreferenceOrderByRelationAggregateInput
    venueOnboardingResponses?: VenueOnboardingResponseOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    settings?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    venues?: VenueListRelationFilter
    users?: UserListRelationFilter
    bookings?: BookingListRelationFilter
    payments?: PaymentListRelationFilter
    blackouts?: BlackoutListRelationFilter
    cashPayments?: CashPaymentListRelationFilter
    commissionRecords?: CommissionRecordListRelationFilter
    customerPaymentPreferences?: CustomerPaymentPreferenceListRelationFilter
    venueOnboardingResponses?: VenueOnboardingResponseListRelationFilter
  }, "id" | "slug">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    slug?: StringWithAggregatesFilter<"Tenant"> | string
    settings?: JsonNullableWithAggregatesFilter<"Tenant">
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type VenueWhereInput = {
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    id?: UuidFilter<"Venue"> | string
    tenantId?: UuidFilter<"Venue"> | string
    name?: StringFilter<"Venue"> | string
    address?: StringNullableFilter<"Venue"> | string | null
    capacity?: IntNullableFilter<"Venue"> | number | null
    basePriceCents?: IntFilter<"Venue"> | number
    currency?: StringFilter<"Venue"> | string
    timeZone?: StringFilter<"Venue"> | string
    settings?: JsonNullableFilter<"Venue">
    isActive?: BoolFilter<"Venue"> | boolean
    paymentProfile?: StringFilter<"Venue"> | string
    allowCashPayments?: BoolFilter<"Venue"> | boolean
    cashDiscountPercentage?: DecimalNullableFilter<"Venue"> | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFilter<"Venue"> | boolean
    depositType?: StringFilter<"Venue"> | string
    depositAmount?: IntFilter<"Venue"> | number
    hasRazorpayAccount?: BoolFilter<"Venue"> | boolean
    razorpayKeyId?: StringNullableFilter<"Venue"> | string | null
    razorpayKeySecretEncrypted?: StringNullableFilter<"Venue"> | string | null
    platformHandlesPayments?: BoolFilter<"Venue"> | boolean
    confirmationTrigger?: StringFilter<"Venue"> | string
    platformCommissionPercentage?: DecimalFilter<"Venue"> | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFilter<"Venue"> | number
    autoExpireUnpaidBookings?: BoolFilter<"Venue"> | boolean
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    updatedAt?: DateTimeFilter<"Venue"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    bookings?: BookingListRelationFilter
    blackouts?: BlackoutListRelationFilter
    commissionRecords?: CommissionRecordListRelationFilter
    venueOnboardingResponses?: VenueOnboardingResponseListRelationFilter
  }

  export type VenueOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    basePriceCents?: SortOrder
    currency?: SortOrder
    timeZone?: SortOrder
    settings?: SortOrderInput | SortOrder
    isActive?: SortOrder
    paymentProfile?: SortOrder
    allowCashPayments?: SortOrder
    cashDiscountPercentage?: SortOrderInput | SortOrder
    requiresOnlineDeposit?: SortOrder
    depositType?: SortOrder
    depositAmount?: SortOrder
    hasRazorpayAccount?: SortOrder
    razorpayKeyId?: SortOrderInput | SortOrder
    razorpayKeySecretEncrypted?: SortOrderInput | SortOrder
    platformHandlesPayments?: SortOrder
    confirmationTrigger?: SortOrder
    platformCommissionPercentage?: SortOrder
    paymentDueDaysBeforeEvent?: SortOrder
    autoExpireUnpaidBookings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    blackouts?: BlackoutOrderByRelationAggregateInput
    commissionRecords?: CommissionRecordOrderByRelationAggregateInput
    venueOnboardingResponses?: VenueOnboardingResponseOrderByRelationAggregateInput
  }

  export type VenueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_name?: VenueTenantIdNameCompoundUniqueInput
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    tenantId?: UuidFilter<"Venue"> | string
    name?: StringFilter<"Venue"> | string
    address?: StringNullableFilter<"Venue"> | string | null
    capacity?: IntNullableFilter<"Venue"> | number | null
    basePriceCents?: IntFilter<"Venue"> | number
    currency?: StringFilter<"Venue"> | string
    timeZone?: StringFilter<"Venue"> | string
    settings?: JsonNullableFilter<"Venue">
    isActive?: BoolFilter<"Venue"> | boolean
    paymentProfile?: StringFilter<"Venue"> | string
    allowCashPayments?: BoolFilter<"Venue"> | boolean
    cashDiscountPercentage?: DecimalNullableFilter<"Venue"> | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFilter<"Venue"> | boolean
    depositType?: StringFilter<"Venue"> | string
    depositAmount?: IntFilter<"Venue"> | number
    hasRazorpayAccount?: BoolFilter<"Venue"> | boolean
    razorpayKeyId?: StringNullableFilter<"Venue"> | string | null
    razorpayKeySecretEncrypted?: StringNullableFilter<"Venue"> | string | null
    platformHandlesPayments?: BoolFilter<"Venue"> | boolean
    confirmationTrigger?: StringFilter<"Venue"> | string
    platformCommissionPercentage?: DecimalFilter<"Venue"> | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFilter<"Venue"> | number
    autoExpireUnpaidBookings?: BoolFilter<"Venue"> | boolean
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    updatedAt?: DateTimeFilter<"Venue"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    bookings?: BookingListRelationFilter
    blackouts?: BlackoutListRelationFilter
    commissionRecords?: CommissionRecordListRelationFilter
    venueOnboardingResponses?: VenueOnboardingResponseListRelationFilter
  }, "id" | "tenantId_name">

  export type VenueOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    basePriceCents?: SortOrder
    currency?: SortOrder
    timeZone?: SortOrder
    settings?: SortOrderInput | SortOrder
    isActive?: SortOrder
    paymentProfile?: SortOrder
    allowCashPayments?: SortOrder
    cashDiscountPercentage?: SortOrderInput | SortOrder
    requiresOnlineDeposit?: SortOrder
    depositType?: SortOrder
    depositAmount?: SortOrder
    hasRazorpayAccount?: SortOrder
    razorpayKeyId?: SortOrderInput | SortOrder
    razorpayKeySecretEncrypted?: SortOrderInput | SortOrder
    platformHandlesPayments?: SortOrder
    confirmationTrigger?: SortOrder
    platformCommissionPercentage?: SortOrder
    paymentDueDaysBeforeEvent?: SortOrder
    autoExpireUnpaidBookings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VenueCountOrderByAggregateInput
    _avg?: VenueAvgOrderByAggregateInput
    _max?: VenueMaxOrderByAggregateInput
    _min?: VenueMinOrderByAggregateInput
    _sum?: VenueSumOrderByAggregateInput
  }

  export type VenueScalarWhereWithAggregatesInput = {
    AND?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    OR?: VenueScalarWhereWithAggregatesInput[]
    NOT?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Venue"> | string
    tenantId?: UuidWithAggregatesFilter<"Venue"> | string
    name?: StringWithAggregatesFilter<"Venue"> | string
    address?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    capacity?: IntNullableWithAggregatesFilter<"Venue"> | number | null
    basePriceCents?: IntWithAggregatesFilter<"Venue"> | number
    currency?: StringWithAggregatesFilter<"Venue"> | string
    timeZone?: StringWithAggregatesFilter<"Venue"> | string
    settings?: JsonNullableWithAggregatesFilter<"Venue">
    isActive?: BoolWithAggregatesFilter<"Venue"> | boolean
    paymentProfile?: StringWithAggregatesFilter<"Venue"> | string
    allowCashPayments?: BoolWithAggregatesFilter<"Venue"> | boolean
    cashDiscountPercentage?: DecimalNullableWithAggregatesFilter<"Venue"> | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolWithAggregatesFilter<"Venue"> | boolean
    depositType?: StringWithAggregatesFilter<"Venue"> | string
    depositAmount?: IntWithAggregatesFilter<"Venue"> | number
    hasRazorpayAccount?: BoolWithAggregatesFilter<"Venue"> | boolean
    razorpayKeyId?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    razorpayKeySecretEncrypted?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    platformHandlesPayments?: BoolWithAggregatesFilter<"Venue"> | boolean
    confirmationTrigger?: StringWithAggregatesFilter<"Venue"> | string
    platformCommissionPercentage?: DecimalWithAggregatesFilter<"Venue"> | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntWithAggregatesFilter<"Venue"> | number
    autoExpireUnpaidBookings?: BoolWithAggregatesFilter<"Venue"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Venue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Venue"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    tenantId?: UuidFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    bookings?: BookingListRelationFilter
    confirmedBookings?: BookingListRelationFilter
    cashPaymentsRecorded?: CashPaymentListRelationFilter
    customerPaymentPreferences?: CustomerPaymentPreferenceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    confirmedBookings?: BookingOrderByRelationAggregateInput
    cashPaymentsRecorded?: CashPaymentOrderByRelationAggregateInput
    customerPaymentPreferences?: CustomerPaymentPreferenceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_phone?: UserTenantIdPhoneCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: UuidFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    bookings?: BookingListRelationFilter
    confirmedBookings?: BookingListRelationFilter
    cashPaymentsRecorded?: CashPaymentListRelationFilter
    customerPaymentPreferences?: CustomerPaymentPreferenceListRelationFilter
  }, "id" | "tenantId_phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    tenantId?: UuidWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: UuidFilter<"Booking"> | string
    tenantId?: UuidFilter<"Booking"> | string
    venueId?: UuidFilter<"Booking"> | string
    userId?: UuidFilter<"Booking"> | string
    bookingNumber?: StringFilter<"Booking"> | string
    startTs?: DateTimeFilter<"Booking"> | Date | string
    endTs?: DateTimeFilter<"Booking"> | Date | string
    status?: StringFilter<"Booking"> | string
    holdExpiresAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    totalAmountCents?: IntNullableFilter<"Booking"> | number | null
    currency?: StringFilter<"Booking"> | string
    paymentStatus?: StringFilter<"Booking"> | string
    paymentMethod?: StringNullableFilter<"Booking"> | string | null
    onlineAmountDue?: IntFilter<"Booking"> | number
    cashAmountDue?: IntFilter<"Booking"> | number
    cashDiscountApplied?: IntFilter<"Booking"> | number
    paymentDueDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    cashPaymentAcknowledged?: BoolFilter<"Booking"> | boolean
    requiresManualConfirmation?: BoolFilter<"Booking"> | boolean
    confirmedBy?: UuidNullableFilter<"Booking"> | string | null
    idempotencyKey?: StringNullableFilter<"Booking"> | string | null
    eventType?: StringNullableFilter<"Booking"> | string | null
    guestCount?: IntNullableFilter<"Booking"> | number | null
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    meta?: JsonNullableFilter<"Booking">
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    confirmedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    payments?: PaymentListRelationFilter
    cashPayments?: CashPaymentListRelationFilter
    commissionRecord?: CommissionRecordListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    userId?: SortOrder
    bookingNumber?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrder
    status?: SortOrder
    holdExpiresAt?: SortOrderInput | SortOrder
    totalAmountCents?: SortOrderInput | SortOrder
    currency?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    onlineAmountDue?: SortOrder
    cashAmountDue?: SortOrder
    cashDiscountApplied?: SortOrder
    paymentDueDate?: SortOrderInput | SortOrder
    cashPaymentAcknowledged?: SortOrder
    requiresManualConfirmation?: SortOrder
    confirmedBy?: SortOrderInput | SortOrder
    idempotencyKey?: SortOrderInput | SortOrder
    eventType?: SortOrderInput | SortOrder
    guestCount?: SortOrderInput | SortOrder
    specialRequests?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    confirmedByUser?: UserOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    cashPayments?: CashPaymentOrderByRelationAggregateInput
    commissionRecord?: CommissionRecordOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_bookingNumber?: BookingTenantIdBookingNumberCompoundUniqueInput
    tenantId_idempotencyKey?: BookingTenantIdIdempotencyKeyCompoundUniqueInput
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    tenantId?: UuidFilter<"Booking"> | string
    venueId?: UuidFilter<"Booking"> | string
    userId?: UuidFilter<"Booking"> | string
    bookingNumber?: StringFilter<"Booking"> | string
    startTs?: DateTimeFilter<"Booking"> | Date | string
    endTs?: DateTimeFilter<"Booking"> | Date | string
    status?: StringFilter<"Booking"> | string
    holdExpiresAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    totalAmountCents?: IntNullableFilter<"Booking"> | number | null
    currency?: StringFilter<"Booking"> | string
    paymentStatus?: StringFilter<"Booking"> | string
    paymentMethod?: StringNullableFilter<"Booking"> | string | null
    onlineAmountDue?: IntFilter<"Booking"> | number
    cashAmountDue?: IntFilter<"Booking"> | number
    cashDiscountApplied?: IntFilter<"Booking"> | number
    paymentDueDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    cashPaymentAcknowledged?: BoolFilter<"Booking"> | boolean
    requiresManualConfirmation?: BoolFilter<"Booking"> | boolean
    confirmedBy?: UuidNullableFilter<"Booking"> | string | null
    idempotencyKey?: StringNullableFilter<"Booking"> | string | null
    eventType?: StringNullableFilter<"Booking"> | string | null
    guestCount?: IntNullableFilter<"Booking"> | number | null
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    meta?: JsonNullableFilter<"Booking">
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    confirmedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    payments?: PaymentListRelationFilter
    cashPayments?: CashPaymentListRelationFilter
    commissionRecord?: CommissionRecordListRelationFilter
  }, "id" | "tenantId_bookingNumber" | "tenantId_idempotencyKey">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    userId?: SortOrder
    bookingNumber?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrder
    status?: SortOrder
    holdExpiresAt?: SortOrderInput | SortOrder
    totalAmountCents?: SortOrderInput | SortOrder
    currency?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    onlineAmountDue?: SortOrder
    cashAmountDue?: SortOrder
    cashDiscountApplied?: SortOrder
    paymentDueDate?: SortOrderInput | SortOrder
    cashPaymentAcknowledged?: SortOrder
    requiresManualConfirmation?: SortOrder
    confirmedBy?: SortOrderInput | SortOrder
    idempotencyKey?: SortOrderInput | SortOrder
    eventType?: SortOrderInput | SortOrder
    guestCount?: SortOrderInput | SortOrder
    specialRequests?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Booking"> | string
    tenantId?: UuidWithAggregatesFilter<"Booking"> | string
    venueId?: UuidWithAggregatesFilter<"Booking"> | string
    userId?: UuidWithAggregatesFilter<"Booking"> | string
    bookingNumber?: StringWithAggregatesFilter<"Booking"> | string
    startTs?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    endTs?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    status?: StringWithAggregatesFilter<"Booking"> | string
    holdExpiresAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    totalAmountCents?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    currency?: StringWithAggregatesFilter<"Booking"> | string
    paymentStatus?: StringWithAggregatesFilter<"Booking"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    onlineAmountDue?: IntWithAggregatesFilter<"Booking"> | number
    cashAmountDue?: IntWithAggregatesFilter<"Booking"> | number
    cashDiscountApplied?: IntWithAggregatesFilter<"Booking"> | number
    paymentDueDate?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    cashPaymentAcknowledged?: BoolWithAggregatesFilter<"Booking"> | boolean
    requiresManualConfirmation?: BoolWithAggregatesFilter<"Booking"> | boolean
    confirmedBy?: UuidNullableWithAggregatesFilter<"Booking"> | string | null
    idempotencyKey?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    eventType?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    guestCount?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    specialRequests?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    meta?: JsonNullableWithAggregatesFilter<"Booking">
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type BlackoutWhereInput = {
    AND?: BlackoutWhereInput | BlackoutWhereInput[]
    OR?: BlackoutWhereInput[]
    NOT?: BlackoutWhereInput | BlackoutWhereInput[]
    id?: UuidFilter<"Blackout"> | string
    tenantId?: UuidFilter<"Blackout"> | string
    venueId?: UuidFilter<"Blackout"> | string
    startTs?: DateTimeFilter<"Blackout"> | Date | string
    endTs?: DateTimeFilter<"Blackout"> | Date | string
    reason?: StringNullableFilter<"Blackout"> | string | null
    isMaintenance?: BoolFilter<"Blackout"> | boolean
    createdAt?: DateTimeFilter<"Blackout"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
  }

  export type BlackoutOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrder
    reason?: SortOrderInput | SortOrder
    isMaintenance?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
  }

  export type BlackoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlackoutWhereInput | BlackoutWhereInput[]
    OR?: BlackoutWhereInput[]
    NOT?: BlackoutWhereInput | BlackoutWhereInput[]
    tenantId?: UuidFilter<"Blackout"> | string
    venueId?: UuidFilter<"Blackout"> | string
    startTs?: DateTimeFilter<"Blackout"> | Date | string
    endTs?: DateTimeFilter<"Blackout"> | Date | string
    reason?: StringNullableFilter<"Blackout"> | string | null
    isMaintenance?: BoolFilter<"Blackout"> | boolean
    createdAt?: DateTimeFilter<"Blackout"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
  }, "id">

  export type BlackoutOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrder
    reason?: SortOrderInput | SortOrder
    isMaintenance?: SortOrder
    createdAt?: SortOrder
    _count?: BlackoutCountOrderByAggregateInput
    _max?: BlackoutMaxOrderByAggregateInput
    _min?: BlackoutMinOrderByAggregateInput
  }

  export type BlackoutScalarWhereWithAggregatesInput = {
    AND?: BlackoutScalarWhereWithAggregatesInput | BlackoutScalarWhereWithAggregatesInput[]
    OR?: BlackoutScalarWhereWithAggregatesInput[]
    NOT?: BlackoutScalarWhereWithAggregatesInput | BlackoutScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Blackout"> | string
    tenantId?: UuidWithAggregatesFilter<"Blackout"> | string
    venueId?: UuidWithAggregatesFilter<"Blackout"> | string
    startTs?: DateTimeWithAggregatesFilter<"Blackout"> | Date | string
    endTs?: DateTimeWithAggregatesFilter<"Blackout"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"Blackout"> | string | null
    isMaintenance?: BoolWithAggregatesFilter<"Blackout"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Blackout"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: UuidFilter<"Payment"> | string
    tenantId?: UuidFilter<"Payment"> | string
    bookingId?: UuidFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    providerPaymentId?: StringNullableFilter<"Payment"> | string | null
    amountCents?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    gatewayResponse?: JsonNullableFilter<"Payment">
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    provider?: SortOrder
    providerPaymentId?: SortOrderInput | SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    tenantId?: UuidFilter<"Payment"> | string
    bookingId?: UuidFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    providerPaymentId?: StringNullableFilter<"Payment"> | string | null
    amountCents?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    gatewayResponse?: JsonNullableFilter<"Payment">
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    provider?: SortOrder
    providerPaymentId?: SortOrderInput | SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Payment"> | string
    tenantId?: UuidWithAggregatesFilter<"Payment"> | string
    bookingId?: UuidWithAggregatesFilter<"Payment"> | string
    provider?: StringWithAggregatesFilter<"Payment"> | string
    providerPaymentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amountCents?: IntWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    gatewayResponse?: JsonNullableWithAggregatesFilter<"Payment">
    processedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type CashPaymentWhereInput = {
    AND?: CashPaymentWhereInput | CashPaymentWhereInput[]
    OR?: CashPaymentWhereInput[]
    NOT?: CashPaymentWhereInput | CashPaymentWhereInput[]
    id?: UuidFilter<"CashPayment"> | string
    tenantId?: UuidFilter<"CashPayment"> | string
    bookingId?: UuidFilter<"CashPayment"> | string
    amountCents?: IntFilter<"CashPayment"> | number
    recordedBy?: UuidNullableFilter<"CashPayment"> | string | null
    recordedAt?: DateTimeFilter<"CashPayment"> | Date | string
    paymentMethod?: StringFilter<"CashPayment"> | string
    notes?: StringNullableFilter<"CashPayment"> | string | null
    receiptNumber?: StringNullableFilter<"CashPayment"> | string | null
    verificationStatus?: StringFilter<"CashPayment"> | string
    createdAt?: DateTimeFilter<"CashPayment"> | Date | string
    updatedAt?: DateTimeFilter<"CashPayment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    recordedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CashPaymentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    amountCents?: SortOrder
    recordedBy?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
    recordedByUser?: UserOrderByWithRelationInput
  }

  export type CashPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashPaymentWhereInput | CashPaymentWhereInput[]
    OR?: CashPaymentWhereInput[]
    NOT?: CashPaymentWhereInput | CashPaymentWhereInput[]
    tenantId?: UuidFilter<"CashPayment"> | string
    bookingId?: UuidFilter<"CashPayment"> | string
    amountCents?: IntFilter<"CashPayment"> | number
    recordedBy?: UuidNullableFilter<"CashPayment"> | string | null
    recordedAt?: DateTimeFilter<"CashPayment"> | Date | string
    paymentMethod?: StringFilter<"CashPayment"> | string
    notes?: StringNullableFilter<"CashPayment"> | string | null
    receiptNumber?: StringNullableFilter<"CashPayment"> | string | null
    verificationStatus?: StringFilter<"CashPayment"> | string
    createdAt?: DateTimeFilter<"CashPayment"> | Date | string
    updatedAt?: DateTimeFilter<"CashPayment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    recordedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type CashPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    amountCents?: SortOrder
    recordedBy?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CashPaymentCountOrderByAggregateInput
    _avg?: CashPaymentAvgOrderByAggregateInput
    _max?: CashPaymentMaxOrderByAggregateInput
    _min?: CashPaymentMinOrderByAggregateInput
    _sum?: CashPaymentSumOrderByAggregateInput
  }

  export type CashPaymentScalarWhereWithAggregatesInput = {
    AND?: CashPaymentScalarWhereWithAggregatesInput | CashPaymentScalarWhereWithAggregatesInput[]
    OR?: CashPaymentScalarWhereWithAggregatesInput[]
    NOT?: CashPaymentScalarWhereWithAggregatesInput | CashPaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CashPayment"> | string
    tenantId?: UuidWithAggregatesFilter<"CashPayment"> | string
    bookingId?: UuidWithAggregatesFilter<"CashPayment"> | string
    amountCents?: IntWithAggregatesFilter<"CashPayment"> | number
    recordedBy?: UuidNullableWithAggregatesFilter<"CashPayment"> | string | null
    recordedAt?: DateTimeWithAggregatesFilter<"CashPayment"> | Date | string
    paymentMethod?: StringWithAggregatesFilter<"CashPayment"> | string
    notes?: StringNullableWithAggregatesFilter<"CashPayment"> | string | null
    receiptNumber?: StringNullableWithAggregatesFilter<"CashPayment"> | string | null
    verificationStatus?: StringWithAggregatesFilter<"CashPayment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CashPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CashPayment"> | Date | string
  }

  export type CommissionRecordWhereInput = {
    AND?: CommissionRecordWhereInput | CommissionRecordWhereInput[]
    OR?: CommissionRecordWhereInput[]
    NOT?: CommissionRecordWhereInput | CommissionRecordWhereInput[]
    id?: UuidFilter<"CommissionRecord"> | string
    tenantId?: UuidFilter<"CommissionRecord"> | string
    bookingId?: UuidFilter<"CommissionRecord"> | string
    venueId?: UuidFilter<"CommissionRecord"> | string
    bookingAmountCents?: IntFilter<"CommissionRecord"> | number
    commissionPercentage?: DecimalFilter<"CommissionRecord"> | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFilter<"CommissionRecord"> | number
    commissionStatus?: StringFilter<"CommissionRecord"> | string
    collectionMethod?: StringNullableFilter<"CommissionRecord"> | string | null
    collectedAt?: DateTimeNullableFilter<"CommissionRecord"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"CommissionRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"CommissionRecord"> | Date | string
    updatedAt?: DateTimeFilter<"CommissionRecord"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
  }

  export type CommissionRecordOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    venueId?: SortOrder
    bookingAmountCents?: SortOrder
    commissionPercentage?: SortOrder
    commissionAmountCents?: SortOrder
    commissionStatus?: SortOrder
    collectionMethod?: SortOrderInput | SortOrder
    collectedAt?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
  }

  export type CommissionRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommissionRecordWhereInput | CommissionRecordWhereInput[]
    OR?: CommissionRecordWhereInput[]
    NOT?: CommissionRecordWhereInput | CommissionRecordWhereInput[]
    tenantId?: UuidFilter<"CommissionRecord"> | string
    bookingId?: UuidFilter<"CommissionRecord"> | string
    venueId?: UuidFilter<"CommissionRecord"> | string
    bookingAmountCents?: IntFilter<"CommissionRecord"> | number
    commissionPercentage?: DecimalFilter<"CommissionRecord"> | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFilter<"CommissionRecord"> | number
    commissionStatus?: StringFilter<"CommissionRecord"> | string
    collectionMethod?: StringNullableFilter<"CommissionRecord"> | string | null
    collectedAt?: DateTimeNullableFilter<"CommissionRecord"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"CommissionRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"CommissionRecord"> | Date | string
    updatedAt?: DateTimeFilter<"CommissionRecord"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
  }, "id">

  export type CommissionRecordOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    venueId?: SortOrder
    bookingAmountCents?: SortOrder
    commissionPercentage?: SortOrder
    commissionAmountCents?: SortOrder
    commissionStatus?: SortOrder
    collectionMethod?: SortOrderInput | SortOrder
    collectedAt?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommissionRecordCountOrderByAggregateInput
    _avg?: CommissionRecordAvgOrderByAggregateInput
    _max?: CommissionRecordMaxOrderByAggregateInput
    _min?: CommissionRecordMinOrderByAggregateInput
    _sum?: CommissionRecordSumOrderByAggregateInput
  }

  export type CommissionRecordScalarWhereWithAggregatesInput = {
    AND?: CommissionRecordScalarWhereWithAggregatesInput | CommissionRecordScalarWhereWithAggregatesInput[]
    OR?: CommissionRecordScalarWhereWithAggregatesInput[]
    NOT?: CommissionRecordScalarWhereWithAggregatesInput | CommissionRecordScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CommissionRecord"> | string
    tenantId?: UuidWithAggregatesFilter<"CommissionRecord"> | string
    bookingId?: UuidWithAggregatesFilter<"CommissionRecord"> | string
    venueId?: UuidWithAggregatesFilter<"CommissionRecord"> | string
    bookingAmountCents?: IntWithAggregatesFilter<"CommissionRecord"> | number
    commissionPercentage?: DecimalWithAggregatesFilter<"CommissionRecord"> | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntWithAggregatesFilter<"CommissionRecord"> | number
    commissionStatus?: StringWithAggregatesFilter<"CommissionRecord"> | string
    collectionMethod?: StringNullableWithAggregatesFilter<"CommissionRecord"> | string | null
    collectedAt?: DateTimeNullableWithAggregatesFilter<"CommissionRecord"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"CommissionRecord"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CommissionRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommissionRecord"> | Date | string
  }

  export type CustomerPaymentPreferenceWhereInput = {
    AND?: CustomerPaymentPreferenceWhereInput | CustomerPaymentPreferenceWhereInput[]
    OR?: CustomerPaymentPreferenceWhereInput[]
    NOT?: CustomerPaymentPreferenceWhereInput | CustomerPaymentPreferenceWhereInput[]
    id?: UuidFilter<"CustomerPaymentPreference"> | string
    tenantId?: UuidFilter<"CustomerPaymentPreference"> | string
    userId?: UuidFilter<"CustomerPaymentPreference"> | string
    preferredMethod?: StringFilter<"CustomerPaymentPreference"> | string
    cityTier?: StringNullableFilter<"CustomerPaymentPreference"> | string | null
    lastPaymentMethod?: StringNullableFilter<"CustomerPaymentPreference"> | string | null
    totalBookings?: IntFilter<"CustomerPaymentPreference"> | number
    totalOnlinePayments?: IntFilter<"CustomerPaymentPreference"> | number
    createdAt?: DateTimeFilter<"CustomerPaymentPreference"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPaymentPreference"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CustomerPaymentPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    preferredMethod?: SortOrder
    cityTier?: SortOrderInput | SortOrder
    lastPaymentMethod?: SortOrderInput | SortOrder
    totalBookings?: SortOrder
    totalOnlinePayments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CustomerPaymentPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_userId?: CustomerPaymentPreferenceTenantIdUserIdCompoundUniqueInput
    AND?: CustomerPaymentPreferenceWhereInput | CustomerPaymentPreferenceWhereInput[]
    OR?: CustomerPaymentPreferenceWhereInput[]
    NOT?: CustomerPaymentPreferenceWhereInput | CustomerPaymentPreferenceWhereInput[]
    tenantId?: UuidFilter<"CustomerPaymentPreference"> | string
    userId?: UuidFilter<"CustomerPaymentPreference"> | string
    preferredMethod?: StringFilter<"CustomerPaymentPreference"> | string
    cityTier?: StringNullableFilter<"CustomerPaymentPreference"> | string | null
    lastPaymentMethod?: StringNullableFilter<"CustomerPaymentPreference"> | string | null
    totalBookings?: IntFilter<"CustomerPaymentPreference"> | number
    totalOnlinePayments?: IntFilter<"CustomerPaymentPreference"> | number
    createdAt?: DateTimeFilter<"CustomerPaymentPreference"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPaymentPreference"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "tenantId_userId">

  export type CustomerPaymentPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    preferredMethod?: SortOrder
    cityTier?: SortOrderInput | SortOrder
    lastPaymentMethod?: SortOrderInput | SortOrder
    totalBookings?: SortOrder
    totalOnlinePayments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerPaymentPreferenceCountOrderByAggregateInput
    _avg?: CustomerPaymentPreferenceAvgOrderByAggregateInput
    _max?: CustomerPaymentPreferenceMaxOrderByAggregateInput
    _min?: CustomerPaymentPreferenceMinOrderByAggregateInput
    _sum?: CustomerPaymentPreferenceSumOrderByAggregateInput
  }

  export type CustomerPaymentPreferenceScalarWhereWithAggregatesInput = {
    AND?: CustomerPaymentPreferenceScalarWhereWithAggregatesInput | CustomerPaymentPreferenceScalarWhereWithAggregatesInput[]
    OR?: CustomerPaymentPreferenceScalarWhereWithAggregatesInput[]
    NOT?: CustomerPaymentPreferenceScalarWhereWithAggregatesInput | CustomerPaymentPreferenceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CustomerPaymentPreference"> | string
    tenantId?: UuidWithAggregatesFilter<"CustomerPaymentPreference"> | string
    userId?: UuidWithAggregatesFilter<"CustomerPaymentPreference"> | string
    preferredMethod?: StringWithAggregatesFilter<"CustomerPaymentPreference"> | string
    cityTier?: StringNullableWithAggregatesFilter<"CustomerPaymentPreference"> | string | null
    lastPaymentMethod?: StringNullableWithAggregatesFilter<"CustomerPaymentPreference"> | string | null
    totalBookings?: IntWithAggregatesFilter<"CustomerPaymentPreference"> | number
    totalOnlinePayments?: IntWithAggregatesFilter<"CustomerPaymentPreference"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CustomerPaymentPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerPaymentPreference"> | Date | string
  }

  export type VenueOnboardingResponseWhereInput = {
    AND?: VenueOnboardingResponseWhereInput | VenueOnboardingResponseWhereInput[]
    OR?: VenueOnboardingResponseWhereInput[]
    NOT?: VenueOnboardingResponseWhereInput | VenueOnboardingResponseWhereInput[]
    id?: UuidFilter<"VenueOnboardingResponse"> | string
    tenantId?: UuidFilter<"VenueOnboardingResponse"> | string
    venueId?: UuidFilter<"VenueOnboardingResponse"> | string
    paymentPreference?: StringNullableFilter<"VenueOnboardingResponse"> | string | null
    techComfortLevel?: StringNullableFilter<"VenueOnboardingResponse"> | string | null
    currentPaymentMethods?: JsonNullableFilter<"VenueOnboardingResponse">
    monthlyBookingVolume?: IntNullableFilter<"VenueOnboardingResponse"> | number | null
    averageBookingValueCents?: IntNullableFilter<"VenueOnboardingResponse"> | number | null
    responses?: JsonNullableFilter<"VenueOnboardingResponse">
    createdAt?: DateTimeFilter<"VenueOnboardingResponse"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
  }

  export type VenueOnboardingResponseOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    paymentPreference?: SortOrderInput | SortOrder
    techComfortLevel?: SortOrderInput | SortOrder
    currentPaymentMethods?: SortOrderInput | SortOrder
    monthlyBookingVolume?: SortOrderInput | SortOrder
    averageBookingValueCents?: SortOrderInput | SortOrder
    responses?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
  }

  export type VenueOnboardingResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VenueOnboardingResponseWhereInput | VenueOnboardingResponseWhereInput[]
    OR?: VenueOnboardingResponseWhereInput[]
    NOT?: VenueOnboardingResponseWhereInput | VenueOnboardingResponseWhereInput[]
    tenantId?: UuidFilter<"VenueOnboardingResponse"> | string
    venueId?: UuidFilter<"VenueOnboardingResponse"> | string
    paymentPreference?: StringNullableFilter<"VenueOnboardingResponse"> | string | null
    techComfortLevel?: StringNullableFilter<"VenueOnboardingResponse"> | string | null
    currentPaymentMethods?: JsonNullableFilter<"VenueOnboardingResponse">
    monthlyBookingVolume?: IntNullableFilter<"VenueOnboardingResponse"> | number | null
    averageBookingValueCents?: IntNullableFilter<"VenueOnboardingResponse"> | number | null
    responses?: JsonNullableFilter<"VenueOnboardingResponse">
    createdAt?: DateTimeFilter<"VenueOnboardingResponse"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
  }, "id">

  export type VenueOnboardingResponseOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    paymentPreference?: SortOrderInput | SortOrder
    techComfortLevel?: SortOrderInput | SortOrder
    currentPaymentMethods?: SortOrderInput | SortOrder
    monthlyBookingVolume?: SortOrderInput | SortOrder
    averageBookingValueCents?: SortOrderInput | SortOrder
    responses?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VenueOnboardingResponseCountOrderByAggregateInput
    _avg?: VenueOnboardingResponseAvgOrderByAggregateInput
    _max?: VenueOnboardingResponseMaxOrderByAggregateInput
    _min?: VenueOnboardingResponseMinOrderByAggregateInput
    _sum?: VenueOnboardingResponseSumOrderByAggregateInput
  }

  export type VenueOnboardingResponseScalarWhereWithAggregatesInput = {
    AND?: VenueOnboardingResponseScalarWhereWithAggregatesInput | VenueOnboardingResponseScalarWhereWithAggregatesInput[]
    OR?: VenueOnboardingResponseScalarWhereWithAggregatesInput[]
    NOT?: VenueOnboardingResponseScalarWhereWithAggregatesInput | VenueOnboardingResponseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"VenueOnboardingResponse"> | string
    tenantId?: UuidWithAggregatesFilter<"VenueOnboardingResponse"> | string
    venueId?: UuidWithAggregatesFilter<"VenueOnboardingResponse"> | string
    paymentPreference?: StringNullableWithAggregatesFilter<"VenueOnboardingResponse"> | string | null
    techComfortLevel?: StringNullableWithAggregatesFilter<"VenueOnboardingResponse"> | string | null
    currentPaymentMethods?: JsonNullableWithAggregatesFilter<"VenueOnboardingResponse">
    monthlyBookingVolume?: IntNullableWithAggregatesFilter<"VenueOnboardingResponse"> | number | null
    averageBookingValueCents?: IntNullableWithAggregatesFilter<"VenueOnboardingResponse"> | number | null
    responses?: JsonNullableWithAggregatesFilter<"VenueOnboardingResponse">
    createdAt?: DateTimeWithAggregatesFilter<"VenueOnboardingResponse"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutUncheckedCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordUncheckedCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUncheckedUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUncheckedUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueCreateInput = {
    id?: string
    name: string
    address?: string | null
    capacity?: number | null
    basePriceCents: number
    currency?: string
    timeZone?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    paymentProfile?: string
    allowCashPayments?: boolean
    cashDiscountPercentage?: Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: boolean
    depositType?: string
    depositAmount?: number
    hasRazorpayAccount?: boolean
    razorpayKeyId?: string | null
    razorpayKeySecretEncrypted?: string | null
    platformHandlesPayments?: boolean
    confirmationTrigger?: string
    platformCommissionPercentage?: Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: number
    autoExpireUnpaidBookings?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVenuesInput
    bookings?: BookingCreateNestedManyWithoutVenueInput
    blackouts?: BlackoutCreateNestedManyWithoutVenueInput
    commissionRecords?: CommissionRecordCreateNestedManyWithoutVenueInput
    venueOnboardingResponses?: VenueOnboardingResponseCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    capacity?: number | null
    basePriceCents: number
    currency?: string
    timeZone?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    paymentProfile?: string
    allowCashPayments?: boolean
    cashDiscountPercentage?: Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: boolean
    depositType?: string
    depositAmount?: number
    hasRazorpayAccount?: boolean
    razorpayKeyId?: string | null
    razorpayKeySecretEncrypted?: string | null
    platformHandlesPayments?: boolean
    confirmationTrigger?: string
    platformCommissionPercentage?: Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: number
    autoExpireUnpaidBookings?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVenueInput
    blackouts?: BlackoutUncheckedCreateNestedManyWithoutVenueInput
    commissionRecords?: CommissionRecordUncheckedCreateNestedManyWithoutVenueInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVenuesNestedInput
    bookings?: BookingUpdateManyWithoutVenueNestedInput
    blackouts?: BlackoutUpdateManyWithoutVenueNestedInput
    commissionRecords?: CommissionRecordUpdateManyWithoutVenueNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVenueNestedInput
    blackouts?: BlackoutUncheckedUpdateManyWithoutVenueNestedInput
    commissionRecords?: CommissionRecordUncheckedUpdateManyWithoutVenueNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    capacity?: number | null
    basePriceCents: number
    currency?: string
    timeZone?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    paymentProfile?: string
    allowCashPayments?: boolean
    cashDiscountPercentage?: Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: boolean
    depositType?: string
    depositAmount?: number
    hasRazorpayAccount?: boolean
    razorpayKeyId?: string | null
    razorpayKeySecretEncrypted?: string | null
    platformHandlesPayments?: boolean
    confirmationTrigger?: string
    platformCommissionPercentage?: Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: number
    autoExpireUnpaidBookings?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    confirmedBookings?: BookingCreateNestedManyWithoutConfirmedByUserInput
    cashPaymentsRecorded?: CashPaymentCreateNestedManyWithoutRecordedByUserInput
    customerPaymentPreferences?: CustomerPaymentPreferenceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    phone: string
    email?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    confirmedBookings?: BookingUncheckedCreateNestedManyWithoutConfirmedByUserInput
    cashPaymentsRecorded?: CashPaymentUncheckedCreateNestedManyWithoutRecordedByUserInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    confirmedBookings?: BookingUpdateManyWithoutConfirmedByUserNestedInput
    cashPaymentsRecorded?: CashPaymentUpdateManyWithoutRecordedByUserNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    confirmedBookings?: BookingUncheckedUpdateManyWithoutConfirmedByUserNestedInput
    cashPaymentsRecorded?: CashPaymentUncheckedUpdateManyWithoutRecordedByUserNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    phone: string
    email?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBookingsInput
    venue: VenueCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    confirmedByUser?: UserCreateNestedOneWithoutConfirmedBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    cashPayments?: CashPaymentCreateNestedManyWithoutBookingInput
    commissionRecord?: CommissionRecordCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    tenantId: string
    venueId: string
    userId: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: string | null
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutBookingInput
    commissionRecord?: CommissionRecordUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBookingsNestedInput
    venue?: VenueUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    confirmedByUser?: UserUpdateOneWithoutConfirmedBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutBookingNestedInput
    commissionRecord?: CommissionRecordUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutBookingNestedInput
    commissionRecord?: CommissionRecordUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    tenantId: string
    venueId: string
    userId: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: string | null
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlackoutCreateInput = {
    id?: string
    startTs: Date | string
    endTs: Date | string
    reason?: string | null
    isMaintenance?: boolean
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBlackoutsInput
    venue: VenueCreateNestedOneWithoutBlackoutsInput
  }

  export type BlackoutUncheckedCreateInput = {
    id?: string
    tenantId: string
    venueId: string
    startTs: Date | string
    endTs: Date | string
    reason?: string | null
    isMaintenance?: boolean
    createdAt?: Date | string
  }

  export type BlackoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isMaintenance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBlackoutsNestedInput
    venue?: VenueUpdateOneRequiredWithoutBlackoutsNestedInput
  }

  export type BlackoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isMaintenance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlackoutCreateManyInput = {
    id?: string
    tenantId: string
    venueId: string
    startTs: Date | string
    endTs: Date | string
    reason?: string | null
    isMaintenance?: boolean
    createdAt?: Date | string
  }

  export type BlackoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isMaintenance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlackoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isMaintenance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    provider: string
    providerPaymentId?: string | null
    amountCents: number
    currency?: string
    status?: string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
    booking: BookingCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    tenantId: string
    bookingId: string
    provider: string
    providerPaymentId?: string | null
    amountCents: number
    currency?: string
    status?: string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
    booking?: BookingUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    tenantId: string
    bookingId: string
    provider: string
    providerPaymentId?: string | null
    amountCents: number
    currency?: string
    status?: string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashPaymentCreateInput = {
    id?: string
    amountCents: number
    recordedAt?: Date | string
    paymentMethod?: string
    notes?: string | null
    receiptNumber?: string | null
    verificationStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCashPaymentsInput
    booking: BookingCreateNestedOneWithoutCashPaymentsInput
    recordedByUser?: UserCreateNestedOneWithoutCashPaymentsRecordedInput
  }

  export type CashPaymentUncheckedCreateInput = {
    id?: string
    tenantId: string
    bookingId: string
    amountCents: number
    recordedBy?: string | null
    recordedAt?: Date | string
    paymentMethod?: string
    notes?: string | null
    receiptNumber?: string | null
    verificationStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCashPaymentsNestedInput
    booking?: BookingUpdateOneRequiredWithoutCashPaymentsNestedInput
    recordedByUser?: UserUpdateOneWithoutCashPaymentsRecordedNestedInput
  }

  export type CashPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashPaymentCreateManyInput = {
    id?: string
    tenantId: string
    bookingId: string
    amountCents: number
    recordedBy?: string | null
    recordedAt?: Date | string
    paymentMethod?: string
    notes?: string | null
    receiptNumber?: string | null
    verificationStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionRecordCreateInput = {
    id?: string
    bookingAmountCents: number
    commissionPercentage: Decimal | DecimalJsLike | number | string
    commissionAmountCents: number
    commissionStatus?: string
    collectionMethod?: string | null
    collectedAt?: Date | string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCommissionRecordsInput
    booking: BookingCreateNestedOneWithoutCommissionRecordInput
    venue: VenueCreateNestedOneWithoutCommissionRecordsInput
  }

  export type CommissionRecordUncheckedCreateInput = {
    id?: string
    tenantId: string
    bookingId: string
    venueId: string
    bookingAmountCents: number
    commissionPercentage: Decimal | DecimalJsLike | number | string
    commissionAmountCents: number
    commissionStatus?: string
    collectionMethod?: string | null
    collectedAt?: Date | string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingAmountCents?: IntFieldUpdateOperationsInput | number
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFieldUpdateOperationsInput | number
    commissionStatus?: StringFieldUpdateOperationsInput | string
    collectionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCommissionRecordsNestedInput
    booking?: BookingUpdateOneRequiredWithoutCommissionRecordNestedInput
    venue?: VenueUpdateOneRequiredWithoutCommissionRecordsNestedInput
  }

  export type CommissionRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    bookingAmountCents?: IntFieldUpdateOperationsInput | number
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFieldUpdateOperationsInput | number
    commissionStatus?: StringFieldUpdateOperationsInput | string
    collectionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionRecordCreateManyInput = {
    id?: string
    tenantId: string
    bookingId: string
    venueId: string
    bookingAmountCents: number
    commissionPercentage: Decimal | DecimalJsLike | number | string
    commissionAmountCents: number
    commissionStatus?: string
    collectionMethod?: string | null
    collectedAt?: Date | string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingAmountCents?: IntFieldUpdateOperationsInput | number
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFieldUpdateOperationsInput | number
    commissionStatus?: StringFieldUpdateOperationsInput | string
    collectionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    bookingAmountCents?: IntFieldUpdateOperationsInput | number
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFieldUpdateOperationsInput | number
    commissionStatus?: StringFieldUpdateOperationsInput | string
    collectionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPaymentPreferenceCreateInput = {
    id?: string
    preferredMethod?: string
    cityTier?: string | null
    lastPaymentMethod?: string | null
    totalBookings?: number
    totalOnlinePayments?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCustomerPaymentPreferencesInput
    user: UserCreateNestedOneWithoutCustomerPaymentPreferencesInput
  }

  export type CustomerPaymentPreferenceUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    preferredMethod?: string
    cityTier?: string | null
    lastPaymentMethod?: string | null
    totalBookings?: number
    totalOnlinePayments?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPaymentPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferredMethod?: StringFieldUpdateOperationsInput | string
    cityTier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    totalBookings?: IntFieldUpdateOperationsInput | number
    totalOnlinePayments?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCustomerPaymentPreferencesNestedInput
    user?: UserUpdateOneRequiredWithoutCustomerPaymentPreferencesNestedInput
  }

  export type CustomerPaymentPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredMethod?: StringFieldUpdateOperationsInput | string
    cityTier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    totalBookings?: IntFieldUpdateOperationsInput | number
    totalOnlinePayments?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPaymentPreferenceCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    preferredMethod?: string
    cityTier?: string | null
    lastPaymentMethod?: string | null
    totalBookings?: number
    totalOnlinePayments?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPaymentPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferredMethod?: StringFieldUpdateOperationsInput | string
    cityTier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    totalBookings?: IntFieldUpdateOperationsInput | number
    totalOnlinePayments?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPaymentPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredMethod?: StringFieldUpdateOperationsInput | string
    cityTier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    totalBookings?: IntFieldUpdateOperationsInput | number
    totalOnlinePayments?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueOnboardingResponseCreateInput = {
    id?: string
    paymentPreference?: string | null
    techComfortLevel?: string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: number | null
    averageBookingValueCents?: number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVenueOnboardingResponsesInput
    venue: VenueCreateNestedOneWithoutVenueOnboardingResponsesInput
  }

  export type VenueOnboardingResponseUncheckedCreateInput = {
    id?: string
    tenantId: string
    venueId: string
    paymentPreference?: string | null
    techComfortLevel?: string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: number | null
    averageBookingValueCents?: number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VenueOnboardingResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentPreference?: NullableStringFieldUpdateOperationsInput | string | null
    techComfortLevel?: NullableStringFieldUpdateOperationsInput | string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: NullableIntFieldUpdateOperationsInput | number | null
    averageBookingValueCents?: NullableIntFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVenueOnboardingResponsesNestedInput
    venue?: VenueUpdateOneRequiredWithoutVenueOnboardingResponsesNestedInput
  }

  export type VenueOnboardingResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    paymentPreference?: NullableStringFieldUpdateOperationsInput | string | null
    techComfortLevel?: NullableStringFieldUpdateOperationsInput | string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: NullableIntFieldUpdateOperationsInput | number | null
    averageBookingValueCents?: NullableIntFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueOnboardingResponseCreateManyInput = {
    id?: string
    tenantId: string
    venueId: string
    paymentPreference?: string | null
    techComfortLevel?: string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: number | null
    averageBookingValueCents?: number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VenueOnboardingResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentPreference?: NullableStringFieldUpdateOperationsInput | string | null
    techComfortLevel?: NullableStringFieldUpdateOperationsInput | string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: NullableIntFieldUpdateOperationsInput | number | null
    averageBookingValueCents?: NullableIntFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueOnboardingResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    paymentPreference?: NullableStringFieldUpdateOperationsInput | string | null
    techComfortLevel?: NullableStringFieldUpdateOperationsInput | string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: NullableIntFieldUpdateOperationsInput | number | null
    averageBookingValueCents?: NullableIntFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type VenueListRelationFilter = {
    every?: VenueWhereInput
    some?: VenueWhereInput
    none?: VenueWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type BlackoutListRelationFilter = {
    every?: BlackoutWhereInput
    some?: BlackoutWhereInput
    none?: BlackoutWhereInput
  }

  export type CashPaymentListRelationFilter = {
    every?: CashPaymentWhereInput
    some?: CashPaymentWhereInput
    none?: CashPaymentWhereInput
  }

  export type CommissionRecordListRelationFilter = {
    every?: CommissionRecordWhereInput
    some?: CommissionRecordWhereInput
    none?: CommissionRecordWhereInput
  }

  export type CustomerPaymentPreferenceListRelationFilter = {
    every?: CustomerPaymentPreferenceWhereInput
    some?: CustomerPaymentPreferenceWhereInput
    none?: CustomerPaymentPreferenceWhereInput
  }

  export type VenueOnboardingResponseListRelationFilter = {
    every?: VenueOnboardingResponseWhereInput
    some?: VenueOnboardingResponseWhereInput
    none?: VenueOnboardingResponseWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type VenueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlackoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommissionRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerPaymentPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VenueOnboardingResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type VenueTenantIdNameCompoundUniqueInput = {
    tenantId: string
    name: string
  }

  export type VenueCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    capacity?: SortOrder
    basePriceCents?: SortOrder
    currency?: SortOrder
    timeZone?: SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    paymentProfile?: SortOrder
    allowCashPayments?: SortOrder
    cashDiscountPercentage?: SortOrder
    requiresOnlineDeposit?: SortOrder
    depositType?: SortOrder
    depositAmount?: SortOrder
    hasRazorpayAccount?: SortOrder
    razorpayKeyId?: SortOrder
    razorpayKeySecretEncrypted?: SortOrder
    platformHandlesPayments?: SortOrder
    confirmationTrigger?: SortOrder
    platformCommissionPercentage?: SortOrder
    paymentDueDaysBeforeEvent?: SortOrder
    autoExpireUnpaidBookings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueAvgOrderByAggregateInput = {
    capacity?: SortOrder
    basePriceCents?: SortOrder
    cashDiscountPercentage?: SortOrder
    depositAmount?: SortOrder
    platformCommissionPercentage?: SortOrder
    paymentDueDaysBeforeEvent?: SortOrder
  }

  export type VenueMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    capacity?: SortOrder
    basePriceCents?: SortOrder
    currency?: SortOrder
    timeZone?: SortOrder
    isActive?: SortOrder
    paymentProfile?: SortOrder
    allowCashPayments?: SortOrder
    cashDiscountPercentage?: SortOrder
    requiresOnlineDeposit?: SortOrder
    depositType?: SortOrder
    depositAmount?: SortOrder
    hasRazorpayAccount?: SortOrder
    razorpayKeyId?: SortOrder
    razorpayKeySecretEncrypted?: SortOrder
    platformHandlesPayments?: SortOrder
    confirmationTrigger?: SortOrder
    platformCommissionPercentage?: SortOrder
    paymentDueDaysBeforeEvent?: SortOrder
    autoExpireUnpaidBookings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    capacity?: SortOrder
    basePriceCents?: SortOrder
    currency?: SortOrder
    timeZone?: SortOrder
    isActive?: SortOrder
    paymentProfile?: SortOrder
    allowCashPayments?: SortOrder
    cashDiscountPercentage?: SortOrder
    requiresOnlineDeposit?: SortOrder
    depositType?: SortOrder
    depositAmount?: SortOrder
    hasRazorpayAccount?: SortOrder
    razorpayKeyId?: SortOrder
    razorpayKeySecretEncrypted?: SortOrder
    platformHandlesPayments?: SortOrder
    confirmationTrigger?: SortOrder
    platformCommissionPercentage?: SortOrder
    paymentDueDaysBeforeEvent?: SortOrder
    autoExpireUnpaidBookings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueSumOrderByAggregateInput = {
    capacity?: SortOrder
    basePriceCents?: SortOrder
    cashDiscountPercentage?: SortOrder
    depositAmount?: SortOrder
    platformCommissionPercentage?: SortOrder
    paymentDueDaysBeforeEvent?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type UserTenantIdPhoneCompoundUniqueInput = {
    tenantId: string
    phone: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type VenueScalarRelationFilter = {
    is?: VenueWhereInput
    isNot?: VenueWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BookingTenantIdBookingNumberCompoundUniqueInput = {
    tenantId: string
    bookingNumber: string
  }

  export type BookingTenantIdIdempotencyKeyCompoundUniqueInput = {
    tenantId: string
    idempotencyKey: string
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    userId?: SortOrder
    bookingNumber?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrder
    status?: SortOrder
    holdExpiresAt?: SortOrder
    totalAmountCents?: SortOrder
    currency?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    onlineAmountDue?: SortOrder
    cashAmountDue?: SortOrder
    cashDiscountApplied?: SortOrder
    paymentDueDate?: SortOrder
    cashPaymentAcknowledged?: SortOrder
    requiresManualConfirmation?: SortOrder
    confirmedBy?: SortOrder
    idempotencyKey?: SortOrder
    eventType?: SortOrder
    guestCount?: SortOrder
    specialRequests?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    totalAmountCents?: SortOrder
    onlineAmountDue?: SortOrder
    cashAmountDue?: SortOrder
    cashDiscountApplied?: SortOrder
    guestCount?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    userId?: SortOrder
    bookingNumber?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrder
    status?: SortOrder
    holdExpiresAt?: SortOrder
    totalAmountCents?: SortOrder
    currency?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    onlineAmountDue?: SortOrder
    cashAmountDue?: SortOrder
    cashDiscountApplied?: SortOrder
    paymentDueDate?: SortOrder
    cashPaymentAcknowledged?: SortOrder
    requiresManualConfirmation?: SortOrder
    confirmedBy?: SortOrder
    idempotencyKey?: SortOrder
    eventType?: SortOrder
    guestCount?: SortOrder
    specialRequests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    userId?: SortOrder
    bookingNumber?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrder
    status?: SortOrder
    holdExpiresAt?: SortOrder
    totalAmountCents?: SortOrder
    currency?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    onlineAmountDue?: SortOrder
    cashAmountDue?: SortOrder
    cashDiscountApplied?: SortOrder
    paymentDueDate?: SortOrder
    cashPaymentAcknowledged?: SortOrder
    requiresManualConfirmation?: SortOrder
    confirmedBy?: SortOrder
    idempotencyKey?: SortOrder
    eventType?: SortOrder
    guestCount?: SortOrder
    specialRequests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    totalAmountCents?: SortOrder
    onlineAmountDue?: SortOrder
    cashAmountDue?: SortOrder
    cashDiscountApplied?: SortOrder
    guestCount?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BlackoutCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrder
    reason?: SortOrder
    isMaintenance?: SortOrder
    createdAt?: SortOrder
  }

  export type BlackoutMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrder
    reason?: SortOrder
    isMaintenance?: SortOrder
    createdAt?: SortOrder
  }

  export type BlackoutMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    startTs?: SortOrder
    endTs?: SortOrder
    reason?: SortOrder
    isMaintenance?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    provider?: SortOrder
    providerPaymentId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    gatewayResponse?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    provider?: SortOrder
    providerPaymentId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    provider?: SortOrder
    providerPaymentId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type CashPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    amountCents?: SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    receiptNumber?: SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashPaymentAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type CashPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    amountCents?: SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    receiptNumber?: SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    amountCents?: SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    receiptNumber?: SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashPaymentSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type CommissionRecordCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    venueId?: SortOrder
    bookingAmountCents?: SortOrder
    commissionPercentage?: SortOrder
    commissionAmountCents?: SortOrder
    commissionStatus?: SortOrder
    collectionMethod?: SortOrder
    collectedAt?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommissionRecordAvgOrderByAggregateInput = {
    bookingAmountCents?: SortOrder
    commissionPercentage?: SortOrder
    commissionAmountCents?: SortOrder
  }

  export type CommissionRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    venueId?: SortOrder
    bookingAmountCents?: SortOrder
    commissionPercentage?: SortOrder
    commissionAmountCents?: SortOrder
    commissionStatus?: SortOrder
    collectionMethod?: SortOrder
    collectedAt?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommissionRecordMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    bookingId?: SortOrder
    venueId?: SortOrder
    bookingAmountCents?: SortOrder
    commissionPercentage?: SortOrder
    commissionAmountCents?: SortOrder
    commissionStatus?: SortOrder
    collectionMethod?: SortOrder
    collectedAt?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommissionRecordSumOrderByAggregateInput = {
    bookingAmountCents?: SortOrder
    commissionPercentage?: SortOrder
    commissionAmountCents?: SortOrder
  }

  export type CustomerPaymentPreferenceTenantIdUserIdCompoundUniqueInput = {
    tenantId: string
    userId: string
  }

  export type CustomerPaymentPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    preferredMethod?: SortOrder
    cityTier?: SortOrder
    lastPaymentMethod?: SortOrder
    totalBookings?: SortOrder
    totalOnlinePayments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPaymentPreferenceAvgOrderByAggregateInput = {
    totalBookings?: SortOrder
    totalOnlinePayments?: SortOrder
  }

  export type CustomerPaymentPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    preferredMethod?: SortOrder
    cityTier?: SortOrder
    lastPaymentMethod?: SortOrder
    totalBookings?: SortOrder
    totalOnlinePayments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPaymentPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    preferredMethod?: SortOrder
    cityTier?: SortOrder
    lastPaymentMethod?: SortOrder
    totalBookings?: SortOrder
    totalOnlinePayments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPaymentPreferenceSumOrderByAggregateInput = {
    totalBookings?: SortOrder
    totalOnlinePayments?: SortOrder
  }

  export type VenueOnboardingResponseCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    paymentPreference?: SortOrder
    techComfortLevel?: SortOrder
    currentPaymentMethods?: SortOrder
    monthlyBookingVolume?: SortOrder
    averageBookingValueCents?: SortOrder
    responses?: SortOrder
    createdAt?: SortOrder
  }

  export type VenueOnboardingResponseAvgOrderByAggregateInput = {
    monthlyBookingVolume?: SortOrder
    averageBookingValueCents?: SortOrder
  }

  export type VenueOnboardingResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    paymentPreference?: SortOrder
    techComfortLevel?: SortOrder
    monthlyBookingVolume?: SortOrder
    averageBookingValueCents?: SortOrder
    createdAt?: SortOrder
  }

  export type VenueOnboardingResponseMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    venueId?: SortOrder
    paymentPreference?: SortOrder
    techComfortLevel?: SortOrder
    monthlyBookingVolume?: SortOrder
    averageBookingValueCents?: SortOrder
    createdAt?: SortOrder
  }

  export type VenueOnboardingResponseSumOrderByAggregateInput = {
    monthlyBookingVolume?: SortOrder
    averageBookingValueCents?: SortOrder
  }

  export type VenueCreateNestedManyWithoutTenantInput = {
    create?: XOR<VenueCreateWithoutTenantInput, VenueUncheckedCreateWithoutTenantInput> | VenueCreateWithoutTenantInput[] | VenueUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutTenantInput | VenueCreateOrConnectWithoutTenantInput[]
    createMany?: VenueCreateManyTenantInputEnvelope
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutTenantInput = {
    create?: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput> | BookingCreateWithoutTenantInput[] | BookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTenantInput | BookingCreateOrConnectWithoutTenantInput[]
    createMany?: BookingCreateManyTenantInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type BlackoutCreateNestedManyWithoutTenantInput = {
    create?: XOR<BlackoutCreateWithoutTenantInput, BlackoutUncheckedCreateWithoutTenantInput> | BlackoutCreateWithoutTenantInput[] | BlackoutUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BlackoutCreateOrConnectWithoutTenantInput | BlackoutCreateOrConnectWithoutTenantInput[]
    createMany?: BlackoutCreateManyTenantInputEnvelope
    connect?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
  }

  export type CashPaymentCreateNestedManyWithoutTenantInput = {
    create?: XOR<CashPaymentCreateWithoutTenantInput, CashPaymentUncheckedCreateWithoutTenantInput> | CashPaymentCreateWithoutTenantInput[] | CashPaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashPaymentCreateOrConnectWithoutTenantInput | CashPaymentCreateOrConnectWithoutTenantInput[]
    createMany?: CashPaymentCreateManyTenantInputEnvelope
    connect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
  }

  export type CommissionRecordCreateNestedManyWithoutTenantInput = {
    create?: XOR<CommissionRecordCreateWithoutTenantInput, CommissionRecordUncheckedCreateWithoutTenantInput> | CommissionRecordCreateWithoutTenantInput[] | CommissionRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CommissionRecordCreateOrConnectWithoutTenantInput | CommissionRecordCreateOrConnectWithoutTenantInput[]
    createMany?: CommissionRecordCreateManyTenantInputEnvelope
    connect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
  }

  export type CustomerPaymentPreferenceCreateNestedManyWithoutTenantInput = {
    create?: XOR<CustomerPaymentPreferenceCreateWithoutTenantInput, CustomerPaymentPreferenceUncheckedCreateWithoutTenantInput> | CustomerPaymentPreferenceCreateWithoutTenantInput[] | CustomerPaymentPreferenceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerPaymentPreferenceCreateOrConnectWithoutTenantInput | CustomerPaymentPreferenceCreateOrConnectWithoutTenantInput[]
    createMany?: CustomerPaymentPreferenceCreateManyTenantInputEnvelope
    connect?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
  }

  export type VenueOnboardingResponseCreateNestedManyWithoutTenantInput = {
    create?: XOR<VenueOnboardingResponseCreateWithoutTenantInput, VenueOnboardingResponseUncheckedCreateWithoutTenantInput> | VenueOnboardingResponseCreateWithoutTenantInput[] | VenueOnboardingResponseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VenueOnboardingResponseCreateOrConnectWithoutTenantInput | VenueOnboardingResponseCreateOrConnectWithoutTenantInput[]
    createMany?: VenueOnboardingResponseCreateManyTenantInputEnvelope
    connect?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
  }

  export type VenueUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<VenueCreateWithoutTenantInput, VenueUncheckedCreateWithoutTenantInput> | VenueCreateWithoutTenantInput[] | VenueUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutTenantInput | VenueCreateOrConnectWithoutTenantInput[]
    createMany?: VenueCreateManyTenantInputEnvelope
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput> | BookingCreateWithoutTenantInput[] | BookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTenantInput | BookingCreateOrConnectWithoutTenantInput[]
    createMany?: BookingCreateManyTenantInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type BlackoutUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BlackoutCreateWithoutTenantInput, BlackoutUncheckedCreateWithoutTenantInput> | BlackoutCreateWithoutTenantInput[] | BlackoutUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BlackoutCreateOrConnectWithoutTenantInput | BlackoutCreateOrConnectWithoutTenantInput[]
    createMany?: BlackoutCreateManyTenantInputEnvelope
    connect?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
  }

  export type CashPaymentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CashPaymentCreateWithoutTenantInput, CashPaymentUncheckedCreateWithoutTenantInput> | CashPaymentCreateWithoutTenantInput[] | CashPaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashPaymentCreateOrConnectWithoutTenantInput | CashPaymentCreateOrConnectWithoutTenantInput[]
    createMany?: CashPaymentCreateManyTenantInputEnvelope
    connect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
  }

  export type CommissionRecordUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CommissionRecordCreateWithoutTenantInput, CommissionRecordUncheckedCreateWithoutTenantInput> | CommissionRecordCreateWithoutTenantInput[] | CommissionRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CommissionRecordCreateOrConnectWithoutTenantInput | CommissionRecordCreateOrConnectWithoutTenantInput[]
    createMany?: CommissionRecordCreateManyTenantInputEnvelope
    connect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
  }

  export type CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CustomerPaymentPreferenceCreateWithoutTenantInput, CustomerPaymentPreferenceUncheckedCreateWithoutTenantInput> | CustomerPaymentPreferenceCreateWithoutTenantInput[] | CustomerPaymentPreferenceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerPaymentPreferenceCreateOrConnectWithoutTenantInput | CustomerPaymentPreferenceCreateOrConnectWithoutTenantInput[]
    createMany?: CustomerPaymentPreferenceCreateManyTenantInputEnvelope
    connect?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
  }

  export type VenueOnboardingResponseUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<VenueOnboardingResponseCreateWithoutTenantInput, VenueOnboardingResponseUncheckedCreateWithoutTenantInput> | VenueOnboardingResponseCreateWithoutTenantInput[] | VenueOnboardingResponseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VenueOnboardingResponseCreateOrConnectWithoutTenantInput | VenueOnboardingResponseCreateOrConnectWithoutTenantInput[]
    createMany?: VenueOnboardingResponseCreateManyTenantInputEnvelope
    connect?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type VenueUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VenueCreateWithoutTenantInput, VenueUncheckedCreateWithoutTenantInput> | VenueCreateWithoutTenantInput[] | VenueUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutTenantInput | VenueCreateOrConnectWithoutTenantInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutTenantInput | VenueUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VenueCreateManyTenantInputEnvelope
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutTenantInput | VenueUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutTenantInput | VenueUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput> | BookingCreateWithoutTenantInput[] | BookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTenantInput | BookingCreateOrConnectWithoutTenantInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTenantInput | BookingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BookingCreateManyTenantInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTenantInput | BookingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTenantInput | BookingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTenantInput | PaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTenantInput | PaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTenantInput | PaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type BlackoutUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BlackoutCreateWithoutTenantInput, BlackoutUncheckedCreateWithoutTenantInput> | BlackoutCreateWithoutTenantInput[] | BlackoutUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BlackoutCreateOrConnectWithoutTenantInput | BlackoutCreateOrConnectWithoutTenantInput[]
    upsert?: BlackoutUpsertWithWhereUniqueWithoutTenantInput | BlackoutUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BlackoutCreateManyTenantInputEnvelope
    set?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    disconnect?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    delete?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    connect?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    update?: BlackoutUpdateWithWhereUniqueWithoutTenantInput | BlackoutUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BlackoutUpdateManyWithWhereWithoutTenantInput | BlackoutUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BlackoutScalarWhereInput | BlackoutScalarWhereInput[]
  }

  export type CashPaymentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CashPaymentCreateWithoutTenantInput, CashPaymentUncheckedCreateWithoutTenantInput> | CashPaymentCreateWithoutTenantInput[] | CashPaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashPaymentCreateOrConnectWithoutTenantInput | CashPaymentCreateOrConnectWithoutTenantInput[]
    upsert?: CashPaymentUpsertWithWhereUniqueWithoutTenantInput | CashPaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CashPaymentCreateManyTenantInputEnvelope
    set?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    disconnect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    delete?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    connect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    update?: CashPaymentUpdateWithWhereUniqueWithoutTenantInput | CashPaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CashPaymentUpdateManyWithWhereWithoutTenantInput | CashPaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CashPaymentScalarWhereInput | CashPaymentScalarWhereInput[]
  }

  export type CommissionRecordUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CommissionRecordCreateWithoutTenantInput, CommissionRecordUncheckedCreateWithoutTenantInput> | CommissionRecordCreateWithoutTenantInput[] | CommissionRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CommissionRecordCreateOrConnectWithoutTenantInput | CommissionRecordCreateOrConnectWithoutTenantInput[]
    upsert?: CommissionRecordUpsertWithWhereUniqueWithoutTenantInput | CommissionRecordUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CommissionRecordCreateManyTenantInputEnvelope
    set?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    disconnect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    delete?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    connect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    update?: CommissionRecordUpdateWithWhereUniqueWithoutTenantInput | CommissionRecordUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CommissionRecordUpdateManyWithWhereWithoutTenantInput | CommissionRecordUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CommissionRecordScalarWhereInput | CommissionRecordScalarWhereInput[]
  }

  export type CustomerPaymentPreferenceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CustomerPaymentPreferenceCreateWithoutTenantInput, CustomerPaymentPreferenceUncheckedCreateWithoutTenantInput> | CustomerPaymentPreferenceCreateWithoutTenantInput[] | CustomerPaymentPreferenceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerPaymentPreferenceCreateOrConnectWithoutTenantInput | CustomerPaymentPreferenceCreateOrConnectWithoutTenantInput[]
    upsert?: CustomerPaymentPreferenceUpsertWithWhereUniqueWithoutTenantInput | CustomerPaymentPreferenceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CustomerPaymentPreferenceCreateManyTenantInputEnvelope
    set?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    disconnect?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    delete?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    connect?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    update?: CustomerPaymentPreferenceUpdateWithWhereUniqueWithoutTenantInput | CustomerPaymentPreferenceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CustomerPaymentPreferenceUpdateManyWithWhereWithoutTenantInput | CustomerPaymentPreferenceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CustomerPaymentPreferenceScalarWhereInput | CustomerPaymentPreferenceScalarWhereInput[]
  }

  export type VenueOnboardingResponseUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VenueOnboardingResponseCreateWithoutTenantInput, VenueOnboardingResponseUncheckedCreateWithoutTenantInput> | VenueOnboardingResponseCreateWithoutTenantInput[] | VenueOnboardingResponseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VenueOnboardingResponseCreateOrConnectWithoutTenantInput | VenueOnboardingResponseCreateOrConnectWithoutTenantInput[]
    upsert?: VenueOnboardingResponseUpsertWithWhereUniqueWithoutTenantInput | VenueOnboardingResponseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VenueOnboardingResponseCreateManyTenantInputEnvelope
    set?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    disconnect?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    delete?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    connect?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    update?: VenueOnboardingResponseUpdateWithWhereUniqueWithoutTenantInput | VenueOnboardingResponseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VenueOnboardingResponseUpdateManyWithWhereWithoutTenantInput | VenueOnboardingResponseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VenueOnboardingResponseScalarWhereInput | VenueOnboardingResponseScalarWhereInput[]
  }

  export type VenueUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VenueCreateWithoutTenantInput, VenueUncheckedCreateWithoutTenantInput> | VenueCreateWithoutTenantInput[] | VenueUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutTenantInput | VenueCreateOrConnectWithoutTenantInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutTenantInput | VenueUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VenueCreateManyTenantInputEnvelope
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutTenantInput | VenueUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutTenantInput | VenueUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput> | BookingCreateWithoutTenantInput[] | BookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTenantInput | BookingCreateOrConnectWithoutTenantInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTenantInput | BookingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BookingCreateManyTenantInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTenantInput | BookingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTenantInput | BookingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTenantInput | PaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTenantInput | PaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTenantInput | PaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type BlackoutUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BlackoutCreateWithoutTenantInput, BlackoutUncheckedCreateWithoutTenantInput> | BlackoutCreateWithoutTenantInput[] | BlackoutUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BlackoutCreateOrConnectWithoutTenantInput | BlackoutCreateOrConnectWithoutTenantInput[]
    upsert?: BlackoutUpsertWithWhereUniqueWithoutTenantInput | BlackoutUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BlackoutCreateManyTenantInputEnvelope
    set?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    disconnect?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    delete?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    connect?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    update?: BlackoutUpdateWithWhereUniqueWithoutTenantInput | BlackoutUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BlackoutUpdateManyWithWhereWithoutTenantInput | BlackoutUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BlackoutScalarWhereInput | BlackoutScalarWhereInput[]
  }

  export type CashPaymentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CashPaymentCreateWithoutTenantInput, CashPaymentUncheckedCreateWithoutTenantInput> | CashPaymentCreateWithoutTenantInput[] | CashPaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashPaymentCreateOrConnectWithoutTenantInput | CashPaymentCreateOrConnectWithoutTenantInput[]
    upsert?: CashPaymentUpsertWithWhereUniqueWithoutTenantInput | CashPaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CashPaymentCreateManyTenantInputEnvelope
    set?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    disconnect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    delete?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    connect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    update?: CashPaymentUpdateWithWhereUniqueWithoutTenantInput | CashPaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CashPaymentUpdateManyWithWhereWithoutTenantInput | CashPaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CashPaymentScalarWhereInput | CashPaymentScalarWhereInput[]
  }

  export type CommissionRecordUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CommissionRecordCreateWithoutTenantInput, CommissionRecordUncheckedCreateWithoutTenantInput> | CommissionRecordCreateWithoutTenantInput[] | CommissionRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CommissionRecordCreateOrConnectWithoutTenantInput | CommissionRecordCreateOrConnectWithoutTenantInput[]
    upsert?: CommissionRecordUpsertWithWhereUniqueWithoutTenantInput | CommissionRecordUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CommissionRecordCreateManyTenantInputEnvelope
    set?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    disconnect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    delete?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    connect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    update?: CommissionRecordUpdateWithWhereUniqueWithoutTenantInput | CommissionRecordUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CommissionRecordUpdateManyWithWhereWithoutTenantInput | CommissionRecordUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CommissionRecordScalarWhereInput | CommissionRecordScalarWhereInput[]
  }

  export type CustomerPaymentPreferenceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CustomerPaymentPreferenceCreateWithoutTenantInput, CustomerPaymentPreferenceUncheckedCreateWithoutTenantInput> | CustomerPaymentPreferenceCreateWithoutTenantInput[] | CustomerPaymentPreferenceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerPaymentPreferenceCreateOrConnectWithoutTenantInput | CustomerPaymentPreferenceCreateOrConnectWithoutTenantInput[]
    upsert?: CustomerPaymentPreferenceUpsertWithWhereUniqueWithoutTenantInput | CustomerPaymentPreferenceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CustomerPaymentPreferenceCreateManyTenantInputEnvelope
    set?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    disconnect?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    delete?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    connect?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    update?: CustomerPaymentPreferenceUpdateWithWhereUniqueWithoutTenantInput | CustomerPaymentPreferenceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CustomerPaymentPreferenceUpdateManyWithWhereWithoutTenantInput | CustomerPaymentPreferenceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CustomerPaymentPreferenceScalarWhereInput | CustomerPaymentPreferenceScalarWhereInput[]
  }

  export type VenueOnboardingResponseUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VenueOnboardingResponseCreateWithoutTenantInput, VenueOnboardingResponseUncheckedCreateWithoutTenantInput> | VenueOnboardingResponseCreateWithoutTenantInput[] | VenueOnboardingResponseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VenueOnboardingResponseCreateOrConnectWithoutTenantInput | VenueOnboardingResponseCreateOrConnectWithoutTenantInput[]
    upsert?: VenueOnboardingResponseUpsertWithWhereUniqueWithoutTenantInput | VenueOnboardingResponseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VenueOnboardingResponseCreateManyTenantInputEnvelope
    set?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    disconnect?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    delete?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    connect?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    update?: VenueOnboardingResponseUpdateWithWhereUniqueWithoutTenantInput | VenueOnboardingResponseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VenueOnboardingResponseUpdateManyWithWhereWithoutTenantInput | VenueOnboardingResponseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VenueOnboardingResponseScalarWhereInput | VenueOnboardingResponseScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutVenuesInput = {
    create?: XOR<TenantCreateWithoutVenuesInput, TenantUncheckedCreateWithoutVenuesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVenuesInput
    connect?: TenantWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutVenueInput = {
    create?: XOR<BookingCreateWithoutVenueInput, BookingUncheckedCreateWithoutVenueInput> | BookingCreateWithoutVenueInput[] | BookingUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVenueInput | BookingCreateOrConnectWithoutVenueInput[]
    createMany?: BookingCreateManyVenueInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BlackoutCreateNestedManyWithoutVenueInput = {
    create?: XOR<BlackoutCreateWithoutVenueInput, BlackoutUncheckedCreateWithoutVenueInput> | BlackoutCreateWithoutVenueInput[] | BlackoutUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: BlackoutCreateOrConnectWithoutVenueInput | BlackoutCreateOrConnectWithoutVenueInput[]
    createMany?: BlackoutCreateManyVenueInputEnvelope
    connect?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
  }

  export type CommissionRecordCreateNestedManyWithoutVenueInput = {
    create?: XOR<CommissionRecordCreateWithoutVenueInput, CommissionRecordUncheckedCreateWithoutVenueInput> | CommissionRecordCreateWithoutVenueInput[] | CommissionRecordUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CommissionRecordCreateOrConnectWithoutVenueInput | CommissionRecordCreateOrConnectWithoutVenueInput[]
    createMany?: CommissionRecordCreateManyVenueInputEnvelope
    connect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
  }

  export type VenueOnboardingResponseCreateNestedManyWithoutVenueInput = {
    create?: XOR<VenueOnboardingResponseCreateWithoutVenueInput, VenueOnboardingResponseUncheckedCreateWithoutVenueInput> | VenueOnboardingResponseCreateWithoutVenueInput[] | VenueOnboardingResponseUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueOnboardingResponseCreateOrConnectWithoutVenueInput | VenueOnboardingResponseCreateOrConnectWithoutVenueInput[]
    createMany?: VenueOnboardingResponseCreateManyVenueInputEnvelope
    connect?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<BookingCreateWithoutVenueInput, BookingUncheckedCreateWithoutVenueInput> | BookingCreateWithoutVenueInput[] | BookingUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVenueInput | BookingCreateOrConnectWithoutVenueInput[]
    createMany?: BookingCreateManyVenueInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BlackoutUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<BlackoutCreateWithoutVenueInput, BlackoutUncheckedCreateWithoutVenueInput> | BlackoutCreateWithoutVenueInput[] | BlackoutUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: BlackoutCreateOrConnectWithoutVenueInput | BlackoutCreateOrConnectWithoutVenueInput[]
    createMany?: BlackoutCreateManyVenueInputEnvelope
    connect?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
  }

  export type CommissionRecordUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<CommissionRecordCreateWithoutVenueInput, CommissionRecordUncheckedCreateWithoutVenueInput> | CommissionRecordCreateWithoutVenueInput[] | CommissionRecordUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CommissionRecordCreateOrConnectWithoutVenueInput | CommissionRecordCreateOrConnectWithoutVenueInput[]
    createMany?: CommissionRecordCreateManyVenueInputEnvelope
    connect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
  }

  export type VenueOnboardingResponseUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<VenueOnboardingResponseCreateWithoutVenueInput, VenueOnboardingResponseUncheckedCreateWithoutVenueInput> | VenueOnboardingResponseCreateWithoutVenueInput[] | VenueOnboardingResponseUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueOnboardingResponseCreateOrConnectWithoutVenueInput | VenueOnboardingResponseCreateOrConnectWithoutVenueInput[]
    createMany?: VenueOnboardingResponseCreateManyVenueInputEnvelope
    connect?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TenantUpdateOneRequiredWithoutVenuesNestedInput = {
    create?: XOR<TenantCreateWithoutVenuesInput, TenantUncheckedCreateWithoutVenuesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVenuesInput
    upsert?: TenantUpsertWithoutVenuesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutVenuesInput, TenantUpdateWithoutVenuesInput>, TenantUncheckedUpdateWithoutVenuesInput>
  }

  export type BookingUpdateManyWithoutVenueNestedInput = {
    create?: XOR<BookingCreateWithoutVenueInput, BookingUncheckedCreateWithoutVenueInput> | BookingCreateWithoutVenueInput[] | BookingUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVenueInput | BookingCreateOrConnectWithoutVenueInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutVenueInput | BookingUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: BookingCreateManyVenueInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutVenueInput | BookingUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutVenueInput | BookingUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BlackoutUpdateManyWithoutVenueNestedInput = {
    create?: XOR<BlackoutCreateWithoutVenueInput, BlackoutUncheckedCreateWithoutVenueInput> | BlackoutCreateWithoutVenueInput[] | BlackoutUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: BlackoutCreateOrConnectWithoutVenueInput | BlackoutCreateOrConnectWithoutVenueInput[]
    upsert?: BlackoutUpsertWithWhereUniqueWithoutVenueInput | BlackoutUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: BlackoutCreateManyVenueInputEnvelope
    set?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    disconnect?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    delete?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    connect?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    update?: BlackoutUpdateWithWhereUniqueWithoutVenueInput | BlackoutUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: BlackoutUpdateManyWithWhereWithoutVenueInput | BlackoutUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: BlackoutScalarWhereInput | BlackoutScalarWhereInput[]
  }

  export type CommissionRecordUpdateManyWithoutVenueNestedInput = {
    create?: XOR<CommissionRecordCreateWithoutVenueInput, CommissionRecordUncheckedCreateWithoutVenueInput> | CommissionRecordCreateWithoutVenueInput[] | CommissionRecordUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CommissionRecordCreateOrConnectWithoutVenueInput | CommissionRecordCreateOrConnectWithoutVenueInput[]
    upsert?: CommissionRecordUpsertWithWhereUniqueWithoutVenueInput | CommissionRecordUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: CommissionRecordCreateManyVenueInputEnvelope
    set?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    disconnect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    delete?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    connect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    update?: CommissionRecordUpdateWithWhereUniqueWithoutVenueInput | CommissionRecordUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: CommissionRecordUpdateManyWithWhereWithoutVenueInput | CommissionRecordUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: CommissionRecordScalarWhereInput | CommissionRecordScalarWhereInput[]
  }

  export type VenueOnboardingResponseUpdateManyWithoutVenueNestedInput = {
    create?: XOR<VenueOnboardingResponseCreateWithoutVenueInput, VenueOnboardingResponseUncheckedCreateWithoutVenueInput> | VenueOnboardingResponseCreateWithoutVenueInput[] | VenueOnboardingResponseUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueOnboardingResponseCreateOrConnectWithoutVenueInput | VenueOnboardingResponseCreateOrConnectWithoutVenueInput[]
    upsert?: VenueOnboardingResponseUpsertWithWhereUniqueWithoutVenueInput | VenueOnboardingResponseUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: VenueOnboardingResponseCreateManyVenueInputEnvelope
    set?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    disconnect?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    delete?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    connect?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    update?: VenueOnboardingResponseUpdateWithWhereUniqueWithoutVenueInput | VenueOnboardingResponseUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: VenueOnboardingResponseUpdateManyWithWhereWithoutVenueInput | VenueOnboardingResponseUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: VenueOnboardingResponseScalarWhereInput | VenueOnboardingResponseScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<BookingCreateWithoutVenueInput, BookingUncheckedCreateWithoutVenueInput> | BookingCreateWithoutVenueInput[] | BookingUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVenueInput | BookingCreateOrConnectWithoutVenueInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutVenueInput | BookingUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: BookingCreateManyVenueInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutVenueInput | BookingUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutVenueInput | BookingUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BlackoutUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<BlackoutCreateWithoutVenueInput, BlackoutUncheckedCreateWithoutVenueInput> | BlackoutCreateWithoutVenueInput[] | BlackoutUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: BlackoutCreateOrConnectWithoutVenueInput | BlackoutCreateOrConnectWithoutVenueInput[]
    upsert?: BlackoutUpsertWithWhereUniqueWithoutVenueInput | BlackoutUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: BlackoutCreateManyVenueInputEnvelope
    set?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    disconnect?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    delete?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    connect?: BlackoutWhereUniqueInput | BlackoutWhereUniqueInput[]
    update?: BlackoutUpdateWithWhereUniqueWithoutVenueInput | BlackoutUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: BlackoutUpdateManyWithWhereWithoutVenueInput | BlackoutUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: BlackoutScalarWhereInput | BlackoutScalarWhereInput[]
  }

  export type CommissionRecordUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<CommissionRecordCreateWithoutVenueInput, CommissionRecordUncheckedCreateWithoutVenueInput> | CommissionRecordCreateWithoutVenueInput[] | CommissionRecordUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CommissionRecordCreateOrConnectWithoutVenueInput | CommissionRecordCreateOrConnectWithoutVenueInput[]
    upsert?: CommissionRecordUpsertWithWhereUniqueWithoutVenueInput | CommissionRecordUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: CommissionRecordCreateManyVenueInputEnvelope
    set?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    disconnect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    delete?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    connect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    update?: CommissionRecordUpdateWithWhereUniqueWithoutVenueInput | CommissionRecordUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: CommissionRecordUpdateManyWithWhereWithoutVenueInput | CommissionRecordUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: CommissionRecordScalarWhereInput | CommissionRecordScalarWhereInput[]
  }

  export type VenueOnboardingResponseUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<VenueOnboardingResponseCreateWithoutVenueInput, VenueOnboardingResponseUncheckedCreateWithoutVenueInput> | VenueOnboardingResponseCreateWithoutVenueInput[] | VenueOnboardingResponseUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueOnboardingResponseCreateOrConnectWithoutVenueInput | VenueOnboardingResponseCreateOrConnectWithoutVenueInput[]
    upsert?: VenueOnboardingResponseUpsertWithWhereUniqueWithoutVenueInput | VenueOnboardingResponseUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: VenueOnboardingResponseCreateManyVenueInputEnvelope
    set?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    disconnect?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    delete?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    connect?: VenueOnboardingResponseWhereUniqueInput | VenueOnboardingResponseWhereUniqueInput[]
    update?: VenueOnboardingResponseUpdateWithWhereUniqueWithoutVenueInput | VenueOnboardingResponseUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: VenueOnboardingResponseUpdateManyWithWhereWithoutVenueInput | VenueOnboardingResponseUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: VenueOnboardingResponseScalarWhereInput | VenueOnboardingResponseScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutConfirmedByUserInput = {
    create?: XOR<BookingCreateWithoutConfirmedByUserInput, BookingUncheckedCreateWithoutConfirmedByUserInput> | BookingCreateWithoutConfirmedByUserInput[] | BookingUncheckedCreateWithoutConfirmedByUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutConfirmedByUserInput | BookingCreateOrConnectWithoutConfirmedByUserInput[]
    createMany?: BookingCreateManyConfirmedByUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type CashPaymentCreateNestedManyWithoutRecordedByUserInput = {
    create?: XOR<CashPaymentCreateWithoutRecordedByUserInput, CashPaymentUncheckedCreateWithoutRecordedByUserInput> | CashPaymentCreateWithoutRecordedByUserInput[] | CashPaymentUncheckedCreateWithoutRecordedByUserInput[]
    connectOrCreate?: CashPaymentCreateOrConnectWithoutRecordedByUserInput | CashPaymentCreateOrConnectWithoutRecordedByUserInput[]
    createMany?: CashPaymentCreateManyRecordedByUserInputEnvelope
    connect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
  }

  export type CustomerPaymentPreferenceCreateNestedManyWithoutUserInput = {
    create?: XOR<CustomerPaymentPreferenceCreateWithoutUserInput, CustomerPaymentPreferenceUncheckedCreateWithoutUserInput> | CustomerPaymentPreferenceCreateWithoutUserInput[] | CustomerPaymentPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomerPaymentPreferenceCreateOrConnectWithoutUserInput | CustomerPaymentPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: CustomerPaymentPreferenceCreateManyUserInputEnvelope
    connect?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutConfirmedByUserInput = {
    create?: XOR<BookingCreateWithoutConfirmedByUserInput, BookingUncheckedCreateWithoutConfirmedByUserInput> | BookingCreateWithoutConfirmedByUserInput[] | BookingUncheckedCreateWithoutConfirmedByUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutConfirmedByUserInput | BookingCreateOrConnectWithoutConfirmedByUserInput[]
    createMany?: BookingCreateManyConfirmedByUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type CashPaymentUncheckedCreateNestedManyWithoutRecordedByUserInput = {
    create?: XOR<CashPaymentCreateWithoutRecordedByUserInput, CashPaymentUncheckedCreateWithoutRecordedByUserInput> | CashPaymentCreateWithoutRecordedByUserInput[] | CashPaymentUncheckedCreateWithoutRecordedByUserInput[]
    connectOrCreate?: CashPaymentCreateOrConnectWithoutRecordedByUserInput | CashPaymentCreateOrConnectWithoutRecordedByUserInput[]
    createMany?: CashPaymentCreateManyRecordedByUserInputEnvelope
    connect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
  }

  export type CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CustomerPaymentPreferenceCreateWithoutUserInput, CustomerPaymentPreferenceUncheckedCreateWithoutUserInput> | CustomerPaymentPreferenceCreateWithoutUserInput[] | CustomerPaymentPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomerPaymentPreferenceCreateOrConnectWithoutUserInput | CustomerPaymentPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: CustomerPaymentPreferenceCreateManyUserInputEnvelope
    connect?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutConfirmedByUserNestedInput = {
    create?: XOR<BookingCreateWithoutConfirmedByUserInput, BookingUncheckedCreateWithoutConfirmedByUserInput> | BookingCreateWithoutConfirmedByUserInput[] | BookingUncheckedCreateWithoutConfirmedByUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutConfirmedByUserInput | BookingCreateOrConnectWithoutConfirmedByUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutConfirmedByUserInput | BookingUpsertWithWhereUniqueWithoutConfirmedByUserInput[]
    createMany?: BookingCreateManyConfirmedByUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutConfirmedByUserInput | BookingUpdateWithWhereUniqueWithoutConfirmedByUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutConfirmedByUserInput | BookingUpdateManyWithWhereWithoutConfirmedByUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type CashPaymentUpdateManyWithoutRecordedByUserNestedInput = {
    create?: XOR<CashPaymentCreateWithoutRecordedByUserInput, CashPaymentUncheckedCreateWithoutRecordedByUserInput> | CashPaymentCreateWithoutRecordedByUserInput[] | CashPaymentUncheckedCreateWithoutRecordedByUserInput[]
    connectOrCreate?: CashPaymentCreateOrConnectWithoutRecordedByUserInput | CashPaymentCreateOrConnectWithoutRecordedByUserInput[]
    upsert?: CashPaymentUpsertWithWhereUniqueWithoutRecordedByUserInput | CashPaymentUpsertWithWhereUniqueWithoutRecordedByUserInput[]
    createMany?: CashPaymentCreateManyRecordedByUserInputEnvelope
    set?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    disconnect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    delete?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    connect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    update?: CashPaymentUpdateWithWhereUniqueWithoutRecordedByUserInput | CashPaymentUpdateWithWhereUniqueWithoutRecordedByUserInput[]
    updateMany?: CashPaymentUpdateManyWithWhereWithoutRecordedByUserInput | CashPaymentUpdateManyWithWhereWithoutRecordedByUserInput[]
    deleteMany?: CashPaymentScalarWhereInput | CashPaymentScalarWhereInput[]
  }

  export type CustomerPaymentPreferenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<CustomerPaymentPreferenceCreateWithoutUserInput, CustomerPaymentPreferenceUncheckedCreateWithoutUserInput> | CustomerPaymentPreferenceCreateWithoutUserInput[] | CustomerPaymentPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomerPaymentPreferenceCreateOrConnectWithoutUserInput | CustomerPaymentPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: CustomerPaymentPreferenceUpsertWithWhereUniqueWithoutUserInput | CustomerPaymentPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CustomerPaymentPreferenceCreateManyUserInputEnvelope
    set?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    disconnect?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    delete?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    connect?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    update?: CustomerPaymentPreferenceUpdateWithWhereUniqueWithoutUserInput | CustomerPaymentPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CustomerPaymentPreferenceUpdateManyWithWhereWithoutUserInput | CustomerPaymentPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CustomerPaymentPreferenceScalarWhereInput | CustomerPaymentPreferenceScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutConfirmedByUserNestedInput = {
    create?: XOR<BookingCreateWithoutConfirmedByUserInput, BookingUncheckedCreateWithoutConfirmedByUserInput> | BookingCreateWithoutConfirmedByUserInput[] | BookingUncheckedCreateWithoutConfirmedByUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutConfirmedByUserInput | BookingCreateOrConnectWithoutConfirmedByUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutConfirmedByUserInput | BookingUpsertWithWhereUniqueWithoutConfirmedByUserInput[]
    createMany?: BookingCreateManyConfirmedByUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutConfirmedByUserInput | BookingUpdateWithWhereUniqueWithoutConfirmedByUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutConfirmedByUserInput | BookingUpdateManyWithWhereWithoutConfirmedByUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type CashPaymentUncheckedUpdateManyWithoutRecordedByUserNestedInput = {
    create?: XOR<CashPaymentCreateWithoutRecordedByUserInput, CashPaymentUncheckedCreateWithoutRecordedByUserInput> | CashPaymentCreateWithoutRecordedByUserInput[] | CashPaymentUncheckedCreateWithoutRecordedByUserInput[]
    connectOrCreate?: CashPaymentCreateOrConnectWithoutRecordedByUserInput | CashPaymentCreateOrConnectWithoutRecordedByUserInput[]
    upsert?: CashPaymentUpsertWithWhereUniqueWithoutRecordedByUserInput | CashPaymentUpsertWithWhereUniqueWithoutRecordedByUserInput[]
    createMany?: CashPaymentCreateManyRecordedByUserInputEnvelope
    set?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    disconnect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    delete?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    connect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    update?: CashPaymentUpdateWithWhereUniqueWithoutRecordedByUserInput | CashPaymentUpdateWithWhereUniqueWithoutRecordedByUserInput[]
    updateMany?: CashPaymentUpdateManyWithWhereWithoutRecordedByUserInput | CashPaymentUpdateManyWithWhereWithoutRecordedByUserInput[]
    deleteMany?: CashPaymentScalarWhereInput | CashPaymentScalarWhereInput[]
  }

  export type CustomerPaymentPreferenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CustomerPaymentPreferenceCreateWithoutUserInput, CustomerPaymentPreferenceUncheckedCreateWithoutUserInput> | CustomerPaymentPreferenceCreateWithoutUserInput[] | CustomerPaymentPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomerPaymentPreferenceCreateOrConnectWithoutUserInput | CustomerPaymentPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: CustomerPaymentPreferenceUpsertWithWhereUniqueWithoutUserInput | CustomerPaymentPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CustomerPaymentPreferenceCreateManyUserInputEnvelope
    set?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    disconnect?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    delete?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    connect?: CustomerPaymentPreferenceWhereUniqueInput | CustomerPaymentPreferenceWhereUniqueInput[]
    update?: CustomerPaymentPreferenceUpdateWithWhereUniqueWithoutUserInput | CustomerPaymentPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CustomerPaymentPreferenceUpdateManyWithWhereWithoutUserInput | CustomerPaymentPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CustomerPaymentPreferenceScalarWhereInput | CustomerPaymentPreferenceScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutBookingsInput = {
    create?: XOR<TenantCreateWithoutBookingsInput, TenantUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBookingsInput
    connect?: TenantWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutBookingsInput = {
    create?: XOR<VenueCreateWithoutBookingsInput, VenueUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutBookingsInput
    connect?: VenueWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConfirmedBookingsInput = {
    create?: XOR<UserCreateWithoutConfirmedBookingsInput, UserUncheckedCreateWithoutConfirmedBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConfirmedBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CashPaymentCreateNestedManyWithoutBookingInput = {
    create?: XOR<CashPaymentCreateWithoutBookingInput, CashPaymentUncheckedCreateWithoutBookingInput> | CashPaymentCreateWithoutBookingInput[] | CashPaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CashPaymentCreateOrConnectWithoutBookingInput | CashPaymentCreateOrConnectWithoutBookingInput[]
    createMany?: CashPaymentCreateManyBookingInputEnvelope
    connect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
  }

  export type CommissionRecordCreateNestedManyWithoutBookingInput = {
    create?: XOR<CommissionRecordCreateWithoutBookingInput, CommissionRecordUncheckedCreateWithoutBookingInput> | CommissionRecordCreateWithoutBookingInput[] | CommissionRecordUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CommissionRecordCreateOrConnectWithoutBookingInput | CommissionRecordCreateOrConnectWithoutBookingInput[]
    createMany?: CommissionRecordCreateManyBookingInputEnvelope
    connect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CashPaymentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<CashPaymentCreateWithoutBookingInput, CashPaymentUncheckedCreateWithoutBookingInput> | CashPaymentCreateWithoutBookingInput[] | CashPaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CashPaymentCreateOrConnectWithoutBookingInput | CashPaymentCreateOrConnectWithoutBookingInput[]
    createMany?: CashPaymentCreateManyBookingInputEnvelope
    connect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
  }

  export type CommissionRecordUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<CommissionRecordCreateWithoutBookingInput, CommissionRecordUncheckedCreateWithoutBookingInput> | CommissionRecordCreateWithoutBookingInput[] | CommissionRecordUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CommissionRecordCreateOrConnectWithoutBookingInput | CommissionRecordCreateOrConnectWithoutBookingInput[]
    createMany?: CommissionRecordCreateManyBookingInputEnvelope
    connect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TenantUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<TenantCreateWithoutBookingsInput, TenantUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBookingsInput
    upsert?: TenantUpsertWithoutBookingsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBookingsInput, TenantUpdateWithoutBookingsInput>, TenantUncheckedUpdateWithoutBookingsInput>
  }

  export type VenueUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<VenueCreateWithoutBookingsInput, VenueUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutBookingsInput
    upsert?: VenueUpsertWithoutBookingsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutBookingsInput, VenueUpdateWithoutBookingsInput>, VenueUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneWithoutConfirmedBookingsNestedInput = {
    create?: XOR<UserCreateWithoutConfirmedBookingsInput, UserUncheckedCreateWithoutConfirmedBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConfirmedBookingsInput
    upsert?: UserUpsertWithoutConfirmedBookingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConfirmedBookingsInput, UserUpdateWithoutConfirmedBookingsInput>, UserUncheckedUpdateWithoutConfirmedBookingsInput>
  }

  export type PaymentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CashPaymentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<CashPaymentCreateWithoutBookingInput, CashPaymentUncheckedCreateWithoutBookingInput> | CashPaymentCreateWithoutBookingInput[] | CashPaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CashPaymentCreateOrConnectWithoutBookingInput | CashPaymentCreateOrConnectWithoutBookingInput[]
    upsert?: CashPaymentUpsertWithWhereUniqueWithoutBookingInput | CashPaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: CashPaymentCreateManyBookingInputEnvelope
    set?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    disconnect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    delete?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    connect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    update?: CashPaymentUpdateWithWhereUniqueWithoutBookingInput | CashPaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: CashPaymentUpdateManyWithWhereWithoutBookingInput | CashPaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: CashPaymentScalarWhereInput | CashPaymentScalarWhereInput[]
  }

  export type CommissionRecordUpdateManyWithoutBookingNestedInput = {
    create?: XOR<CommissionRecordCreateWithoutBookingInput, CommissionRecordUncheckedCreateWithoutBookingInput> | CommissionRecordCreateWithoutBookingInput[] | CommissionRecordUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CommissionRecordCreateOrConnectWithoutBookingInput | CommissionRecordCreateOrConnectWithoutBookingInput[]
    upsert?: CommissionRecordUpsertWithWhereUniqueWithoutBookingInput | CommissionRecordUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: CommissionRecordCreateManyBookingInputEnvelope
    set?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    disconnect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    delete?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    connect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    update?: CommissionRecordUpdateWithWhereUniqueWithoutBookingInput | CommissionRecordUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: CommissionRecordUpdateManyWithWhereWithoutBookingInput | CommissionRecordUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: CommissionRecordScalarWhereInput | CommissionRecordScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CashPaymentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<CashPaymentCreateWithoutBookingInput, CashPaymentUncheckedCreateWithoutBookingInput> | CashPaymentCreateWithoutBookingInput[] | CashPaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CashPaymentCreateOrConnectWithoutBookingInput | CashPaymentCreateOrConnectWithoutBookingInput[]
    upsert?: CashPaymentUpsertWithWhereUniqueWithoutBookingInput | CashPaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: CashPaymentCreateManyBookingInputEnvelope
    set?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    disconnect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    delete?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    connect?: CashPaymentWhereUniqueInput | CashPaymentWhereUniqueInput[]
    update?: CashPaymentUpdateWithWhereUniqueWithoutBookingInput | CashPaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: CashPaymentUpdateManyWithWhereWithoutBookingInput | CashPaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: CashPaymentScalarWhereInput | CashPaymentScalarWhereInput[]
  }

  export type CommissionRecordUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<CommissionRecordCreateWithoutBookingInput, CommissionRecordUncheckedCreateWithoutBookingInput> | CommissionRecordCreateWithoutBookingInput[] | CommissionRecordUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CommissionRecordCreateOrConnectWithoutBookingInput | CommissionRecordCreateOrConnectWithoutBookingInput[]
    upsert?: CommissionRecordUpsertWithWhereUniqueWithoutBookingInput | CommissionRecordUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: CommissionRecordCreateManyBookingInputEnvelope
    set?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    disconnect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    delete?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    connect?: CommissionRecordWhereUniqueInput | CommissionRecordWhereUniqueInput[]
    update?: CommissionRecordUpdateWithWhereUniqueWithoutBookingInput | CommissionRecordUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: CommissionRecordUpdateManyWithWhereWithoutBookingInput | CommissionRecordUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: CommissionRecordScalarWhereInput | CommissionRecordScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutBlackoutsInput = {
    create?: XOR<TenantCreateWithoutBlackoutsInput, TenantUncheckedCreateWithoutBlackoutsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBlackoutsInput
    connect?: TenantWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutBlackoutsInput = {
    create?: XOR<VenueCreateWithoutBlackoutsInput, VenueUncheckedCreateWithoutBlackoutsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutBlackoutsInput
    connect?: VenueWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutBlackoutsNestedInput = {
    create?: XOR<TenantCreateWithoutBlackoutsInput, TenantUncheckedCreateWithoutBlackoutsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBlackoutsInput
    upsert?: TenantUpsertWithoutBlackoutsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBlackoutsInput, TenantUpdateWithoutBlackoutsInput>, TenantUncheckedUpdateWithoutBlackoutsInput>
  }

  export type VenueUpdateOneRequiredWithoutBlackoutsNestedInput = {
    create?: XOR<VenueCreateWithoutBlackoutsInput, VenueUncheckedCreateWithoutBlackoutsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutBlackoutsInput
    upsert?: VenueUpsertWithoutBlackoutsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutBlackoutsInput, VenueUpdateWithoutBlackoutsInput>, VenueUncheckedUpdateWithoutBlackoutsInput>
  }

  export type TenantCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    upsert?: TenantUpsertWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPaymentsInput, TenantUpdateWithoutPaymentsInput>, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type BookingUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    upsert?: BookingUpsertWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentsInput, BookingUpdateWithoutPaymentsInput>, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantCreateNestedOneWithoutCashPaymentsInput = {
    create?: XOR<TenantCreateWithoutCashPaymentsInput, TenantUncheckedCreateWithoutCashPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCashPaymentsInput
    connect?: TenantWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutCashPaymentsInput = {
    create?: XOR<BookingCreateWithoutCashPaymentsInput, BookingUncheckedCreateWithoutCashPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCashPaymentsInput
    connect?: BookingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCashPaymentsRecordedInput = {
    create?: XOR<UserCreateWithoutCashPaymentsRecordedInput, UserUncheckedCreateWithoutCashPaymentsRecordedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashPaymentsRecordedInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutCashPaymentsNestedInput = {
    create?: XOR<TenantCreateWithoutCashPaymentsInput, TenantUncheckedCreateWithoutCashPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCashPaymentsInput
    upsert?: TenantUpsertWithoutCashPaymentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCashPaymentsInput, TenantUpdateWithoutCashPaymentsInput>, TenantUncheckedUpdateWithoutCashPaymentsInput>
  }

  export type BookingUpdateOneRequiredWithoutCashPaymentsNestedInput = {
    create?: XOR<BookingCreateWithoutCashPaymentsInput, BookingUncheckedCreateWithoutCashPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCashPaymentsInput
    upsert?: BookingUpsertWithoutCashPaymentsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutCashPaymentsInput, BookingUpdateWithoutCashPaymentsInput>, BookingUncheckedUpdateWithoutCashPaymentsInput>
  }

  export type UserUpdateOneWithoutCashPaymentsRecordedNestedInput = {
    create?: XOR<UserCreateWithoutCashPaymentsRecordedInput, UserUncheckedCreateWithoutCashPaymentsRecordedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashPaymentsRecordedInput
    upsert?: UserUpsertWithoutCashPaymentsRecordedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCashPaymentsRecordedInput, UserUpdateWithoutCashPaymentsRecordedInput>, UserUncheckedUpdateWithoutCashPaymentsRecordedInput>
  }

  export type TenantCreateNestedOneWithoutCommissionRecordsInput = {
    create?: XOR<TenantCreateWithoutCommissionRecordsInput, TenantUncheckedCreateWithoutCommissionRecordsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCommissionRecordsInput
    connect?: TenantWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutCommissionRecordInput = {
    create?: XOR<BookingCreateWithoutCommissionRecordInput, BookingUncheckedCreateWithoutCommissionRecordInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCommissionRecordInput
    connect?: BookingWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutCommissionRecordsInput = {
    create?: XOR<VenueCreateWithoutCommissionRecordsInput, VenueUncheckedCreateWithoutCommissionRecordsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutCommissionRecordsInput
    connect?: VenueWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutCommissionRecordsNestedInput = {
    create?: XOR<TenantCreateWithoutCommissionRecordsInput, TenantUncheckedCreateWithoutCommissionRecordsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCommissionRecordsInput
    upsert?: TenantUpsertWithoutCommissionRecordsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCommissionRecordsInput, TenantUpdateWithoutCommissionRecordsInput>, TenantUncheckedUpdateWithoutCommissionRecordsInput>
  }

  export type BookingUpdateOneRequiredWithoutCommissionRecordNestedInput = {
    create?: XOR<BookingCreateWithoutCommissionRecordInput, BookingUncheckedCreateWithoutCommissionRecordInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCommissionRecordInput
    upsert?: BookingUpsertWithoutCommissionRecordInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutCommissionRecordInput, BookingUpdateWithoutCommissionRecordInput>, BookingUncheckedUpdateWithoutCommissionRecordInput>
  }

  export type VenueUpdateOneRequiredWithoutCommissionRecordsNestedInput = {
    create?: XOR<VenueCreateWithoutCommissionRecordsInput, VenueUncheckedCreateWithoutCommissionRecordsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutCommissionRecordsInput
    upsert?: VenueUpsertWithoutCommissionRecordsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutCommissionRecordsInput, VenueUpdateWithoutCommissionRecordsInput>, VenueUncheckedUpdateWithoutCommissionRecordsInput>
  }

  export type TenantCreateNestedOneWithoutCustomerPaymentPreferencesInput = {
    create?: XOR<TenantCreateWithoutCustomerPaymentPreferencesInput, TenantUncheckedCreateWithoutCustomerPaymentPreferencesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCustomerPaymentPreferencesInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCustomerPaymentPreferencesInput = {
    create?: XOR<UserCreateWithoutCustomerPaymentPreferencesInput, UserUncheckedCreateWithoutCustomerPaymentPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerPaymentPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutCustomerPaymentPreferencesNestedInput = {
    create?: XOR<TenantCreateWithoutCustomerPaymentPreferencesInput, TenantUncheckedCreateWithoutCustomerPaymentPreferencesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCustomerPaymentPreferencesInput
    upsert?: TenantUpsertWithoutCustomerPaymentPreferencesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCustomerPaymentPreferencesInput, TenantUpdateWithoutCustomerPaymentPreferencesInput>, TenantUncheckedUpdateWithoutCustomerPaymentPreferencesInput>
  }

  export type UserUpdateOneRequiredWithoutCustomerPaymentPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutCustomerPaymentPreferencesInput, UserUncheckedCreateWithoutCustomerPaymentPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerPaymentPreferencesInput
    upsert?: UserUpsertWithoutCustomerPaymentPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomerPaymentPreferencesInput, UserUpdateWithoutCustomerPaymentPreferencesInput>, UserUncheckedUpdateWithoutCustomerPaymentPreferencesInput>
  }

  export type TenantCreateNestedOneWithoutVenueOnboardingResponsesInput = {
    create?: XOR<TenantCreateWithoutVenueOnboardingResponsesInput, TenantUncheckedCreateWithoutVenueOnboardingResponsesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVenueOnboardingResponsesInput
    connect?: TenantWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutVenueOnboardingResponsesInput = {
    create?: XOR<VenueCreateWithoutVenueOnboardingResponsesInput, VenueUncheckedCreateWithoutVenueOnboardingResponsesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutVenueOnboardingResponsesInput
    connect?: VenueWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutVenueOnboardingResponsesNestedInput = {
    create?: XOR<TenantCreateWithoutVenueOnboardingResponsesInput, TenantUncheckedCreateWithoutVenueOnboardingResponsesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVenueOnboardingResponsesInput
    upsert?: TenantUpsertWithoutVenueOnboardingResponsesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutVenueOnboardingResponsesInput, TenantUpdateWithoutVenueOnboardingResponsesInput>, TenantUncheckedUpdateWithoutVenueOnboardingResponsesInput>
  }

  export type VenueUpdateOneRequiredWithoutVenueOnboardingResponsesNestedInput = {
    create?: XOR<VenueCreateWithoutVenueOnboardingResponsesInput, VenueUncheckedCreateWithoutVenueOnboardingResponsesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutVenueOnboardingResponsesInput
    upsert?: VenueUpsertWithoutVenueOnboardingResponsesInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutVenueOnboardingResponsesInput, VenueUpdateWithoutVenueOnboardingResponsesInput>, VenueUncheckedUpdateWithoutVenueOnboardingResponsesInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type VenueCreateWithoutTenantInput = {
    id?: string
    name: string
    address?: string | null
    capacity?: number | null
    basePriceCents: number
    currency?: string
    timeZone?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    paymentProfile?: string
    allowCashPayments?: boolean
    cashDiscountPercentage?: Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: boolean
    depositType?: string
    depositAmount?: number
    hasRazorpayAccount?: boolean
    razorpayKeyId?: string | null
    razorpayKeySecretEncrypted?: string | null
    platformHandlesPayments?: boolean
    confirmationTrigger?: string
    platformCommissionPercentage?: Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: number
    autoExpireUnpaidBookings?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutVenueInput
    blackouts?: BlackoutCreateNestedManyWithoutVenueInput
    commissionRecords?: CommissionRecordCreateNestedManyWithoutVenueInput
    venueOnboardingResponses?: VenueOnboardingResponseCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    address?: string | null
    capacity?: number | null
    basePriceCents: number
    currency?: string
    timeZone?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    paymentProfile?: string
    allowCashPayments?: boolean
    cashDiscountPercentage?: Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: boolean
    depositType?: string
    depositAmount?: number
    hasRazorpayAccount?: boolean
    razorpayKeyId?: string | null
    razorpayKeySecretEncrypted?: string | null
    platformHandlesPayments?: boolean
    confirmationTrigger?: string
    platformCommissionPercentage?: Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: number
    autoExpireUnpaidBookings?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVenueInput
    blackouts?: BlackoutUncheckedCreateNestedManyWithoutVenueInput
    commissionRecords?: CommissionRecordUncheckedCreateNestedManyWithoutVenueInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutTenantInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutTenantInput, VenueUncheckedCreateWithoutTenantInput>
  }

  export type VenueCreateManyTenantInputEnvelope = {
    data: VenueCreateManyTenantInput | VenueCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutUserInput
    confirmedBookings?: BookingCreateNestedManyWithoutConfirmedByUserInput
    cashPaymentsRecorded?: CashPaymentCreateNestedManyWithoutRecordedByUserInput
    customerPaymentPreferences?: CustomerPaymentPreferenceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    confirmedBookings?: BookingUncheckedCreateNestedManyWithoutConfirmedByUserInput
    cashPaymentsRecorded?: CashPaymentUncheckedCreateNestedManyWithoutRecordedByUserInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutTenantInput = {
    id?: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    confirmedByUser?: UserCreateNestedOneWithoutConfirmedBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    cashPayments?: CashPaymentCreateNestedManyWithoutBookingInput
    commissionRecord?: CommissionRecordCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutTenantInput = {
    id?: string
    venueId: string
    userId: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: string | null
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutBookingInput
    commissionRecord?: CommissionRecordUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutTenantInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput>
  }

  export type BookingCreateManyTenantInputEnvelope = {
    data: BookingCreateManyTenantInput | BookingCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutTenantInput = {
    id?: string
    provider: string
    providerPaymentId?: string | null
    amountCents: number
    currency?: string
    status?: string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutTenantInput = {
    id?: string
    bookingId: string
    provider: string
    providerPaymentId?: string | null
    amountCents: number
    currency?: string
    status?: string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput>
  }

  export type PaymentCreateManyTenantInputEnvelope = {
    data: PaymentCreateManyTenantInput | PaymentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type BlackoutCreateWithoutTenantInput = {
    id?: string
    startTs: Date | string
    endTs: Date | string
    reason?: string | null
    isMaintenance?: boolean
    createdAt?: Date | string
    venue: VenueCreateNestedOneWithoutBlackoutsInput
  }

  export type BlackoutUncheckedCreateWithoutTenantInput = {
    id?: string
    venueId: string
    startTs: Date | string
    endTs: Date | string
    reason?: string | null
    isMaintenance?: boolean
    createdAt?: Date | string
  }

  export type BlackoutCreateOrConnectWithoutTenantInput = {
    where: BlackoutWhereUniqueInput
    create: XOR<BlackoutCreateWithoutTenantInput, BlackoutUncheckedCreateWithoutTenantInput>
  }

  export type BlackoutCreateManyTenantInputEnvelope = {
    data: BlackoutCreateManyTenantInput | BlackoutCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CashPaymentCreateWithoutTenantInput = {
    id?: string
    amountCents: number
    recordedAt?: Date | string
    paymentMethod?: string
    notes?: string | null
    receiptNumber?: string | null
    verificationStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutCashPaymentsInput
    recordedByUser?: UserCreateNestedOneWithoutCashPaymentsRecordedInput
  }

  export type CashPaymentUncheckedCreateWithoutTenantInput = {
    id?: string
    bookingId: string
    amountCents: number
    recordedBy?: string | null
    recordedAt?: Date | string
    paymentMethod?: string
    notes?: string | null
    receiptNumber?: string | null
    verificationStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashPaymentCreateOrConnectWithoutTenantInput = {
    where: CashPaymentWhereUniqueInput
    create: XOR<CashPaymentCreateWithoutTenantInput, CashPaymentUncheckedCreateWithoutTenantInput>
  }

  export type CashPaymentCreateManyTenantInputEnvelope = {
    data: CashPaymentCreateManyTenantInput | CashPaymentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CommissionRecordCreateWithoutTenantInput = {
    id?: string
    bookingAmountCents: number
    commissionPercentage: Decimal | DecimalJsLike | number | string
    commissionAmountCents: number
    commissionStatus?: string
    collectionMethod?: string | null
    collectedAt?: Date | string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutCommissionRecordInput
    venue: VenueCreateNestedOneWithoutCommissionRecordsInput
  }

  export type CommissionRecordUncheckedCreateWithoutTenantInput = {
    id?: string
    bookingId: string
    venueId: string
    bookingAmountCents: number
    commissionPercentage: Decimal | DecimalJsLike | number | string
    commissionAmountCents: number
    commissionStatus?: string
    collectionMethod?: string | null
    collectedAt?: Date | string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionRecordCreateOrConnectWithoutTenantInput = {
    where: CommissionRecordWhereUniqueInput
    create: XOR<CommissionRecordCreateWithoutTenantInput, CommissionRecordUncheckedCreateWithoutTenantInput>
  }

  export type CommissionRecordCreateManyTenantInputEnvelope = {
    data: CommissionRecordCreateManyTenantInput | CommissionRecordCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CustomerPaymentPreferenceCreateWithoutTenantInput = {
    id?: string
    preferredMethod?: string
    cityTier?: string | null
    lastPaymentMethod?: string | null
    totalBookings?: number
    totalOnlinePayments?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerPaymentPreferencesInput
  }

  export type CustomerPaymentPreferenceUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    preferredMethod?: string
    cityTier?: string | null
    lastPaymentMethod?: string | null
    totalBookings?: number
    totalOnlinePayments?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPaymentPreferenceCreateOrConnectWithoutTenantInput = {
    where: CustomerPaymentPreferenceWhereUniqueInput
    create: XOR<CustomerPaymentPreferenceCreateWithoutTenantInput, CustomerPaymentPreferenceUncheckedCreateWithoutTenantInput>
  }

  export type CustomerPaymentPreferenceCreateManyTenantInputEnvelope = {
    data: CustomerPaymentPreferenceCreateManyTenantInput | CustomerPaymentPreferenceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type VenueOnboardingResponseCreateWithoutTenantInput = {
    id?: string
    paymentPreference?: string | null
    techComfortLevel?: string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: number | null
    averageBookingValueCents?: number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    venue: VenueCreateNestedOneWithoutVenueOnboardingResponsesInput
  }

  export type VenueOnboardingResponseUncheckedCreateWithoutTenantInput = {
    id?: string
    venueId: string
    paymentPreference?: string | null
    techComfortLevel?: string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: number | null
    averageBookingValueCents?: number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VenueOnboardingResponseCreateOrConnectWithoutTenantInput = {
    where: VenueOnboardingResponseWhereUniqueInput
    create: XOR<VenueOnboardingResponseCreateWithoutTenantInput, VenueOnboardingResponseUncheckedCreateWithoutTenantInput>
  }

  export type VenueOnboardingResponseCreateManyTenantInputEnvelope = {
    data: VenueOnboardingResponseCreateManyTenantInput | VenueOnboardingResponseCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type VenueUpsertWithWhereUniqueWithoutTenantInput = {
    where: VenueWhereUniqueInput
    update: XOR<VenueUpdateWithoutTenantInput, VenueUncheckedUpdateWithoutTenantInput>
    create: XOR<VenueCreateWithoutTenantInput, VenueUncheckedCreateWithoutTenantInput>
  }

  export type VenueUpdateWithWhereUniqueWithoutTenantInput = {
    where: VenueWhereUniqueInput
    data: XOR<VenueUpdateWithoutTenantInput, VenueUncheckedUpdateWithoutTenantInput>
  }

  export type VenueUpdateManyWithWhereWithoutTenantInput = {
    where: VenueScalarWhereInput
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyWithoutTenantInput>
  }

  export type VenueScalarWhereInput = {
    AND?: VenueScalarWhereInput | VenueScalarWhereInput[]
    OR?: VenueScalarWhereInput[]
    NOT?: VenueScalarWhereInput | VenueScalarWhereInput[]
    id?: UuidFilter<"Venue"> | string
    tenantId?: UuidFilter<"Venue"> | string
    name?: StringFilter<"Venue"> | string
    address?: StringNullableFilter<"Venue"> | string | null
    capacity?: IntNullableFilter<"Venue"> | number | null
    basePriceCents?: IntFilter<"Venue"> | number
    currency?: StringFilter<"Venue"> | string
    timeZone?: StringFilter<"Venue"> | string
    settings?: JsonNullableFilter<"Venue">
    isActive?: BoolFilter<"Venue"> | boolean
    paymentProfile?: StringFilter<"Venue"> | string
    allowCashPayments?: BoolFilter<"Venue"> | boolean
    cashDiscountPercentage?: DecimalNullableFilter<"Venue"> | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFilter<"Venue"> | boolean
    depositType?: StringFilter<"Venue"> | string
    depositAmount?: IntFilter<"Venue"> | number
    hasRazorpayAccount?: BoolFilter<"Venue"> | boolean
    razorpayKeyId?: StringNullableFilter<"Venue"> | string | null
    razorpayKeySecretEncrypted?: StringNullableFilter<"Venue"> | string | null
    platformHandlesPayments?: BoolFilter<"Venue"> | boolean
    confirmationTrigger?: StringFilter<"Venue"> | string
    platformCommissionPercentage?: DecimalFilter<"Venue"> | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFilter<"Venue"> | number
    autoExpireUnpaidBookings?: BoolFilter<"Venue"> | boolean
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    updatedAt?: DateTimeFilter<"Venue"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: UuidFilter<"User"> | string
    tenantId?: UuidFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutTenantInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutTenantInput, BookingUncheckedUpdateWithoutTenantInput>
    create: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutTenantInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutTenantInput, BookingUncheckedUpdateWithoutTenantInput>
  }

  export type BookingUpdateManyWithWhereWithoutTenantInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutTenantInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: UuidFilter<"Booking"> | string
    tenantId?: UuidFilter<"Booking"> | string
    venueId?: UuidFilter<"Booking"> | string
    userId?: UuidFilter<"Booking"> | string
    bookingNumber?: StringFilter<"Booking"> | string
    startTs?: DateTimeFilter<"Booking"> | Date | string
    endTs?: DateTimeFilter<"Booking"> | Date | string
    status?: StringFilter<"Booking"> | string
    holdExpiresAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    totalAmountCents?: IntNullableFilter<"Booking"> | number | null
    currency?: StringFilter<"Booking"> | string
    paymentStatus?: StringFilter<"Booking"> | string
    paymentMethod?: StringNullableFilter<"Booking"> | string | null
    onlineAmountDue?: IntFilter<"Booking"> | number
    cashAmountDue?: IntFilter<"Booking"> | number
    cashDiscountApplied?: IntFilter<"Booking"> | number
    paymentDueDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    cashPaymentAcknowledged?: BoolFilter<"Booking"> | boolean
    requiresManualConfirmation?: BoolFilter<"Booking"> | boolean
    confirmedBy?: UuidNullableFilter<"Booking"> | string | null
    idempotencyKey?: StringNullableFilter<"Booking"> | string | null
    eventType?: StringNullableFilter<"Booking"> | string | null
    guestCount?: IntNullableFilter<"Booking"> | number | null
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    meta?: JsonNullableFilter<"Booking">
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutTenantInput, PaymentUncheckedUpdateWithoutTenantInput>
    create: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutTenantInput, PaymentUncheckedUpdateWithoutTenantInput>
  }

  export type PaymentUpdateManyWithWhereWithoutTenantInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutTenantInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: UuidFilter<"Payment"> | string
    tenantId?: UuidFilter<"Payment"> | string
    bookingId?: UuidFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    providerPaymentId?: StringNullableFilter<"Payment"> | string | null
    amountCents?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    gatewayResponse?: JsonNullableFilter<"Payment">
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type BlackoutUpsertWithWhereUniqueWithoutTenantInput = {
    where: BlackoutWhereUniqueInput
    update: XOR<BlackoutUpdateWithoutTenantInput, BlackoutUncheckedUpdateWithoutTenantInput>
    create: XOR<BlackoutCreateWithoutTenantInput, BlackoutUncheckedCreateWithoutTenantInput>
  }

  export type BlackoutUpdateWithWhereUniqueWithoutTenantInput = {
    where: BlackoutWhereUniqueInput
    data: XOR<BlackoutUpdateWithoutTenantInput, BlackoutUncheckedUpdateWithoutTenantInput>
  }

  export type BlackoutUpdateManyWithWhereWithoutTenantInput = {
    where: BlackoutScalarWhereInput
    data: XOR<BlackoutUpdateManyMutationInput, BlackoutUncheckedUpdateManyWithoutTenantInput>
  }

  export type BlackoutScalarWhereInput = {
    AND?: BlackoutScalarWhereInput | BlackoutScalarWhereInput[]
    OR?: BlackoutScalarWhereInput[]
    NOT?: BlackoutScalarWhereInput | BlackoutScalarWhereInput[]
    id?: UuidFilter<"Blackout"> | string
    tenantId?: UuidFilter<"Blackout"> | string
    venueId?: UuidFilter<"Blackout"> | string
    startTs?: DateTimeFilter<"Blackout"> | Date | string
    endTs?: DateTimeFilter<"Blackout"> | Date | string
    reason?: StringNullableFilter<"Blackout"> | string | null
    isMaintenance?: BoolFilter<"Blackout"> | boolean
    createdAt?: DateTimeFilter<"Blackout"> | Date | string
  }

  export type CashPaymentUpsertWithWhereUniqueWithoutTenantInput = {
    where: CashPaymentWhereUniqueInput
    update: XOR<CashPaymentUpdateWithoutTenantInput, CashPaymentUncheckedUpdateWithoutTenantInput>
    create: XOR<CashPaymentCreateWithoutTenantInput, CashPaymentUncheckedCreateWithoutTenantInput>
  }

  export type CashPaymentUpdateWithWhereUniqueWithoutTenantInput = {
    where: CashPaymentWhereUniqueInput
    data: XOR<CashPaymentUpdateWithoutTenantInput, CashPaymentUncheckedUpdateWithoutTenantInput>
  }

  export type CashPaymentUpdateManyWithWhereWithoutTenantInput = {
    where: CashPaymentScalarWhereInput
    data: XOR<CashPaymentUpdateManyMutationInput, CashPaymentUncheckedUpdateManyWithoutTenantInput>
  }

  export type CashPaymentScalarWhereInput = {
    AND?: CashPaymentScalarWhereInput | CashPaymentScalarWhereInput[]
    OR?: CashPaymentScalarWhereInput[]
    NOT?: CashPaymentScalarWhereInput | CashPaymentScalarWhereInput[]
    id?: UuidFilter<"CashPayment"> | string
    tenantId?: UuidFilter<"CashPayment"> | string
    bookingId?: UuidFilter<"CashPayment"> | string
    amountCents?: IntFilter<"CashPayment"> | number
    recordedBy?: UuidNullableFilter<"CashPayment"> | string | null
    recordedAt?: DateTimeFilter<"CashPayment"> | Date | string
    paymentMethod?: StringFilter<"CashPayment"> | string
    notes?: StringNullableFilter<"CashPayment"> | string | null
    receiptNumber?: StringNullableFilter<"CashPayment"> | string | null
    verificationStatus?: StringFilter<"CashPayment"> | string
    createdAt?: DateTimeFilter<"CashPayment"> | Date | string
    updatedAt?: DateTimeFilter<"CashPayment"> | Date | string
  }

  export type CommissionRecordUpsertWithWhereUniqueWithoutTenantInput = {
    where: CommissionRecordWhereUniqueInput
    update: XOR<CommissionRecordUpdateWithoutTenantInput, CommissionRecordUncheckedUpdateWithoutTenantInput>
    create: XOR<CommissionRecordCreateWithoutTenantInput, CommissionRecordUncheckedCreateWithoutTenantInput>
  }

  export type CommissionRecordUpdateWithWhereUniqueWithoutTenantInput = {
    where: CommissionRecordWhereUniqueInput
    data: XOR<CommissionRecordUpdateWithoutTenantInput, CommissionRecordUncheckedUpdateWithoutTenantInput>
  }

  export type CommissionRecordUpdateManyWithWhereWithoutTenantInput = {
    where: CommissionRecordScalarWhereInput
    data: XOR<CommissionRecordUpdateManyMutationInput, CommissionRecordUncheckedUpdateManyWithoutTenantInput>
  }

  export type CommissionRecordScalarWhereInput = {
    AND?: CommissionRecordScalarWhereInput | CommissionRecordScalarWhereInput[]
    OR?: CommissionRecordScalarWhereInput[]
    NOT?: CommissionRecordScalarWhereInput | CommissionRecordScalarWhereInput[]
    id?: UuidFilter<"CommissionRecord"> | string
    tenantId?: UuidFilter<"CommissionRecord"> | string
    bookingId?: UuidFilter<"CommissionRecord"> | string
    venueId?: UuidFilter<"CommissionRecord"> | string
    bookingAmountCents?: IntFilter<"CommissionRecord"> | number
    commissionPercentage?: DecimalFilter<"CommissionRecord"> | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFilter<"CommissionRecord"> | number
    commissionStatus?: StringFilter<"CommissionRecord"> | string
    collectionMethod?: StringNullableFilter<"CommissionRecord"> | string | null
    collectedAt?: DateTimeNullableFilter<"CommissionRecord"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"CommissionRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"CommissionRecord"> | Date | string
    updatedAt?: DateTimeFilter<"CommissionRecord"> | Date | string
  }

  export type CustomerPaymentPreferenceUpsertWithWhereUniqueWithoutTenantInput = {
    where: CustomerPaymentPreferenceWhereUniqueInput
    update: XOR<CustomerPaymentPreferenceUpdateWithoutTenantInput, CustomerPaymentPreferenceUncheckedUpdateWithoutTenantInput>
    create: XOR<CustomerPaymentPreferenceCreateWithoutTenantInput, CustomerPaymentPreferenceUncheckedCreateWithoutTenantInput>
  }

  export type CustomerPaymentPreferenceUpdateWithWhereUniqueWithoutTenantInput = {
    where: CustomerPaymentPreferenceWhereUniqueInput
    data: XOR<CustomerPaymentPreferenceUpdateWithoutTenantInput, CustomerPaymentPreferenceUncheckedUpdateWithoutTenantInput>
  }

  export type CustomerPaymentPreferenceUpdateManyWithWhereWithoutTenantInput = {
    where: CustomerPaymentPreferenceScalarWhereInput
    data: XOR<CustomerPaymentPreferenceUpdateManyMutationInput, CustomerPaymentPreferenceUncheckedUpdateManyWithoutTenantInput>
  }

  export type CustomerPaymentPreferenceScalarWhereInput = {
    AND?: CustomerPaymentPreferenceScalarWhereInput | CustomerPaymentPreferenceScalarWhereInput[]
    OR?: CustomerPaymentPreferenceScalarWhereInput[]
    NOT?: CustomerPaymentPreferenceScalarWhereInput | CustomerPaymentPreferenceScalarWhereInput[]
    id?: UuidFilter<"CustomerPaymentPreference"> | string
    tenantId?: UuidFilter<"CustomerPaymentPreference"> | string
    userId?: UuidFilter<"CustomerPaymentPreference"> | string
    preferredMethod?: StringFilter<"CustomerPaymentPreference"> | string
    cityTier?: StringNullableFilter<"CustomerPaymentPreference"> | string | null
    lastPaymentMethod?: StringNullableFilter<"CustomerPaymentPreference"> | string | null
    totalBookings?: IntFilter<"CustomerPaymentPreference"> | number
    totalOnlinePayments?: IntFilter<"CustomerPaymentPreference"> | number
    createdAt?: DateTimeFilter<"CustomerPaymentPreference"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPaymentPreference"> | Date | string
  }

  export type VenueOnboardingResponseUpsertWithWhereUniqueWithoutTenantInput = {
    where: VenueOnboardingResponseWhereUniqueInput
    update: XOR<VenueOnboardingResponseUpdateWithoutTenantInput, VenueOnboardingResponseUncheckedUpdateWithoutTenantInput>
    create: XOR<VenueOnboardingResponseCreateWithoutTenantInput, VenueOnboardingResponseUncheckedCreateWithoutTenantInput>
  }

  export type VenueOnboardingResponseUpdateWithWhereUniqueWithoutTenantInput = {
    where: VenueOnboardingResponseWhereUniqueInput
    data: XOR<VenueOnboardingResponseUpdateWithoutTenantInput, VenueOnboardingResponseUncheckedUpdateWithoutTenantInput>
  }

  export type VenueOnboardingResponseUpdateManyWithWhereWithoutTenantInput = {
    where: VenueOnboardingResponseScalarWhereInput
    data: XOR<VenueOnboardingResponseUpdateManyMutationInput, VenueOnboardingResponseUncheckedUpdateManyWithoutTenantInput>
  }

  export type VenueOnboardingResponseScalarWhereInput = {
    AND?: VenueOnboardingResponseScalarWhereInput | VenueOnboardingResponseScalarWhereInput[]
    OR?: VenueOnboardingResponseScalarWhereInput[]
    NOT?: VenueOnboardingResponseScalarWhereInput | VenueOnboardingResponseScalarWhereInput[]
    id?: UuidFilter<"VenueOnboardingResponse"> | string
    tenantId?: UuidFilter<"VenueOnboardingResponse"> | string
    venueId?: UuidFilter<"VenueOnboardingResponse"> | string
    paymentPreference?: StringNullableFilter<"VenueOnboardingResponse"> | string | null
    techComfortLevel?: StringNullableFilter<"VenueOnboardingResponse"> | string | null
    currentPaymentMethods?: JsonNullableFilter<"VenueOnboardingResponse">
    monthlyBookingVolume?: IntNullableFilter<"VenueOnboardingResponse"> | number | null
    averageBookingValueCents?: IntNullableFilter<"VenueOnboardingResponse"> | number | null
    responses?: JsonNullableFilter<"VenueOnboardingResponse">
    createdAt?: DateTimeFilter<"VenueOnboardingResponse"> | Date | string
  }

  export type TenantCreateWithoutVenuesInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutVenuesInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutUncheckedCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordUncheckedCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutVenuesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutVenuesInput, TenantUncheckedCreateWithoutVenuesInput>
  }

  export type BookingCreateWithoutVenueInput = {
    id?: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    confirmedByUser?: UserCreateNestedOneWithoutConfirmedBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    cashPayments?: CashPaymentCreateNestedManyWithoutBookingInput
    commissionRecord?: CommissionRecordCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutVenueInput = {
    id?: string
    tenantId: string
    userId: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: string | null
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutBookingInput
    commissionRecord?: CommissionRecordUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutVenueInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutVenueInput, BookingUncheckedCreateWithoutVenueInput>
  }

  export type BookingCreateManyVenueInputEnvelope = {
    data: BookingCreateManyVenueInput | BookingCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type BlackoutCreateWithoutVenueInput = {
    id?: string
    startTs: Date | string
    endTs: Date | string
    reason?: string | null
    isMaintenance?: boolean
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBlackoutsInput
  }

  export type BlackoutUncheckedCreateWithoutVenueInput = {
    id?: string
    tenantId: string
    startTs: Date | string
    endTs: Date | string
    reason?: string | null
    isMaintenance?: boolean
    createdAt?: Date | string
  }

  export type BlackoutCreateOrConnectWithoutVenueInput = {
    where: BlackoutWhereUniqueInput
    create: XOR<BlackoutCreateWithoutVenueInput, BlackoutUncheckedCreateWithoutVenueInput>
  }

  export type BlackoutCreateManyVenueInputEnvelope = {
    data: BlackoutCreateManyVenueInput | BlackoutCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type CommissionRecordCreateWithoutVenueInput = {
    id?: string
    bookingAmountCents: number
    commissionPercentage: Decimal | DecimalJsLike | number | string
    commissionAmountCents: number
    commissionStatus?: string
    collectionMethod?: string | null
    collectedAt?: Date | string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCommissionRecordsInput
    booking: BookingCreateNestedOneWithoutCommissionRecordInput
  }

  export type CommissionRecordUncheckedCreateWithoutVenueInput = {
    id?: string
    tenantId: string
    bookingId: string
    bookingAmountCents: number
    commissionPercentage: Decimal | DecimalJsLike | number | string
    commissionAmountCents: number
    commissionStatus?: string
    collectionMethod?: string | null
    collectedAt?: Date | string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionRecordCreateOrConnectWithoutVenueInput = {
    where: CommissionRecordWhereUniqueInput
    create: XOR<CommissionRecordCreateWithoutVenueInput, CommissionRecordUncheckedCreateWithoutVenueInput>
  }

  export type CommissionRecordCreateManyVenueInputEnvelope = {
    data: CommissionRecordCreateManyVenueInput | CommissionRecordCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type VenueOnboardingResponseCreateWithoutVenueInput = {
    id?: string
    paymentPreference?: string | null
    techComfortLevel?: string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: number | null
    averageBookingValueCents?: number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVenueOnboardingResponsesInput
  }

  export type VenueOnboardingResponseUncheckedCreateWithoutVenueInput = {
    id?: string
    tenantId: string
    paymentPreference?: string | null
    techComfortLevel?: string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: number | null
    averageBookingValueCents?: number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VenueOnboardingResponseCreateOrConnectWithoutVenueInput = {
    where: VenueOnboardingResponseWhereUniqueInput
    create: XOR<VenueOnboardingResponseCreateWithoutVenueInput, VenueOnboardingResponseUncheckedCreateWithoutVenueInput>
  }

  export type VenueOnboardingResponseCreateManyVenueInputEnvelope = {
    data: VenueOnboardingResponseCreateManyVenueInput | VenueOnboardingResponseCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutVenuesInput = {
    update: XOR<TenantUpdateWithoutVenuesInput, TenantUncheckedUpdateWithoutVenuesInput>
    create: XOR<TenantCreateWithoutVenuesInput, TenantUncheckedCreateWithoutVenuesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutVenuesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutVenuesInput, TenantUncheckedUpdateWithoutVenuesInput>
  }

  export type TenantUpdateWithoutVenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutVenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUncheckedUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUncheckedUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutVenueInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutVenueInput, BookingUncheckedUpdateWithoutVenueInput>
    create: XOR<BookingCreateWithoutVenueInput, BookingUncheckedCreateWithoutVenueInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutVenueInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutVenueInput, BookingUncheckedUpdateWithoutVenueInput>
  }

  export type BookingUpdateManyWithWhereWithoutVenueInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutVenueInput>
  }

  export type BlackoutUpsertWithWhereUniqueWithoutVenueInput = {
    where: BlackoutWhereUniqueInput
    update: XOR<BlackoutUpdateWithoutVenueInput, BlackoutUncheckedUpdateWithoutVenueInput>
    create: XOR<BlackoutCreateWithoutVenueInput, BlackoutUncheckedCreateWithoutVenueInput>
  }

  export type BlackoutUpdateWithWhereUniqueWithoutVenueInput = {
    where: BlackoutWhereUniqueInput
    data: XOR<BlackoutUpdateWithoutVenueInput, BlackoutUncheckedUpdateWithoutVenueInput>
  }

  export type BlackoutUpdateManyWithWhereWithoutVenueInput = {
    where: BlackoutScalarWhereInput
    data: XOR<BlackoutUpdateManyMutationInput, BlackoutUncheckedUpdateManyWithoutVenueInput>
  }

  export type CommissionRecordUpsertWithWhereUniqueWithoutVenueInput = {
    where: CommissionRecordWhereUniqueInput
    update: XOR<CommissionRecordUpdateWithoutVenueInput, CommissionRecordUncheckedUpdateWithoutVenueInput>
    create: XOR<CommissionRecordCreateWithoutVenueInput, CommissionRecordUncheckedCreateWithoutVenueInput>
  }

  export type CommissionRecordUpdateWithWhereUniqueWithoutVenueInput = {
    where: CommissionRecordWhereUniqueInput
    data: XOR<CommissionRecordUpdateWithoutVenueInput, CommissionRecordUncheckedUpdateWithoutVenueInput>
  }

  export type CommissionRecordUpdateManyWithWhereWithoutVenueInput = {
    where: CommissionRecordScalarWhereInput
    data: XOR<CommissionRecordUpdateManyMutationInput, CommissionRecordUncheckedUpdateManyWithoutVenueInput>
  }

  export type VenueOnboardingResponseUpsertWithWhereUniqueWithoutVenueInput = {
    where: VenueOnboardingResponseWhereUniqueInput
    update: XOR<VenueOnboardingResponseUpdateWithoutVenueInput, VenueOnboardingResponseUncheckedUpdateWithoutVenueInput>
    create: XOR<VenueOnboardingResponseCreateWithoutVenueInput, VenueOnboardingResponseUncheckedCreateWithoutVenueInput>
  }

  export type VenueOnboardingResponseUpdateWithWhereUniqueWithoutVenueInput = {
    where: VenueOnboardingResponseWhereUniqueInput
    data: XOR<VenueOnboardingResponseUpdateWithoutVenueInput, VenueOnboardingResponseUncheckedUpdateWithoutVenueInput>
  }

  export type VenueOnboardingResponseUpdateManyWithWhereWithoutVenueInput = {
    where: VenueOnboardingResponseScalarWhereInput
    data: XOR<VenueOnboardingResponseUpdateManyMutationInput, VenueOnboardingResponseUncheckedUpdateManyWithoutVenueInput>
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutUncheckedCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordUncheckedCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type BookingCreateWithoutUserInput = {
    id?: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBookingsInput
    venue: VenueCreateNestedOneWithoutBookingsInput
    confirmedByUser?: UserCreateNestedOneWithoutConfirmedBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    cashPayments?: CashPaymentCreateNestedManyWithoutBookingInput
    commissionRecord?: CommissionRecordCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    venueId: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: string | null
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutBookingInput
    commissionRecord?: CommissionRecordUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: BookingCreateManyUserInput | BookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutConfirmedByUserInput = {
    id?: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBookingsInput
    venue: VenueCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    cashPayments?: CashPaymentCreateNestedManyWithoutBookingInput
    commissionRecord?: CommissionRecordCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutConfirmedByUserInput = {
    id?: string
    tenantId: string
    venueId: string
    userId: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutBookingInput
    commissionRecord?: CommissionRecordUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutConfirmedByUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutConfirmedByUserInput, BookingUncheckedCreateWithoutConfirmedByUserInput>
  }

  export type BookingCreateManyConfirmedByUserInputEnvelope = {
    data: BookingCreateManyConfirmedByUserInput | BookingCreateManyConfirmedByUserInput[]
    skipDuplicates?: boolean
  }

  export type CashPaymentCreateWithoutRecordedByUserInput = {
    id?: string
    amountCents: number
    recordedAt?: Date | string
    paymentMethod?: string
    notes?: string | null
    receiptNumber?: string | null
    verificationStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCashPaymentsInput
    booking: BookingCreateNestedOneWithoutCashPaymentsInput
  }

  export type CashPaymentUncheckedCreateWithoutRecordedByUserInput = {
    id?: string
    tenantId: string
    bookingId: string
    amountCents: number
    recordedAt?: Date | string
    paymentMethod?: string
    notes?: string | null
    receiptNumber?: string | null
    verificationStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashPaymentCreateOrConnectWithoutRecordedByUserInput = {
    where: CashPaymentWhereUniqueInput
    create: XOR<CashPaymentCreateWithoutRecordedByUserInput, CashPaymentUncheckedCreateWithoutRecordedByUserInput>
  }

  export type CashPaymentCreateManyRecordedByUserInputEnvelope = {
    data: CashPaymentCreateManyRecordedByUserInput | CashPaymentCreateManyRecordedByUserInput[]
    skipDuplicates?: boolean
  }

  export type CustomerPaymentPreferenceCreateWithoutUserInput = {
    id?: string
    preferredMethod?: string
    cityTier?: string | null
    lastPaymentMethod?: string | null
    totalBookings?: number
    totalOnlinePayments?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCustomerPaymentPreferencesInput
  }

  export type CustomerPaymentPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    preferredMethod?: string
    cityTier?: string | null
    lastPaymentMethod?: string | null
    totalBookings?: number
    totalOnlinePayments?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPaymentPreferenceCreateOrConnectWithoutUserInput = {
    where: CustomerPaymentPreferenceWhereUniqueInput
    create: XOR<CustomerPaymentPreferenceCreateWithoutUserInput, CustomerPaymentPreferenceUncheckedCreateWithoutUserInput>
  }

  export type CustomerPaymentPreferenceCreateManyUserInputEnvelope = {
    data: CustomerPaymentPreferenceCreateManyUserInput | CustomerPaymentPreferenceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUncheckedUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUncheckedUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutConfirmedByUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutConfirmedByUserInput, BookingUncheckedUpdateWithoutConfirmedByUserInput>
    create: XOR<BookingCreateWithoutConfirmedByUserInput, BookingUncheckedCreateWithoutConfirmedByUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutConfirmedByUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutConfirmedByUserInput, BookingUncheckedUpdateWithoutConfirmedByUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutConfirmedByUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutConfirmedByUserInput>
  }

  export type CashPaymentUpsertWithWhereUniqueWithoutRecordedByUserInput = {
    where: CashPaymentWhereUniqueInput
    update: XOR<CashPaymentUpdateWithoutRecordedByUserInput, CashPaymentUncheckedUpdateWithoutRecordedByUserInput>
    create: XOR<CashPaymentCreateWithoutRecordedByUserInput, CashPaymentUncheckedCreateWithoutRecordedByUserInput>
  }

  export type CashPaymentUpdateWithWhereUniqueWithoutRecordedByUserInput = {
    where: CashPaymentWhereUniqueInput
    data: XOR<CashPaymentUpdateWithoutRecordedByUserInput, CashPaymentUncheckedUpdateWithoutRecordedByUserInput>
  }

  export type CashPaymentUpdateManyWithWhereWithoutRecordedByUserInput = {
    where: CashPaymentScalarWhereInput
    data: XOR<CashPaymentUpdateManyMutationInput, CashPaymentUncheckedUpdateManyWithoutRecordedByUserInput>
  }

  export type CustomerPaymentPreferenceUpsertWithWhereUniqueWithoutUserInput = {
    where: CustomerPaymentPreferenceWhereUniqueInput
    update: XOR<CustomerPaymentPreferenceUpdateWithoutUserInput, CustomerPaymentPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<CustomerPaymentPreferenceCreateWithoutUserInput, CustomerPaymentPreferenceUncheckedCreateWithoutUserInput>
  }

  export type CustomerPaymentPreferenceUpdateWithWhereUniqueWithoutUserInput = {
    where: CustomerPaymentPreferenceWhereUniqueInput
    data: XOR<CustomerPaymentPreferenceUpdateWithoutUserInput, CustomerPaymentPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type CustomerPaymentPreferenceUpdateManyWithWhereWithoutUserInput = {
    where: CustomerPaymentPreferenceScalarWhereInput
    data: XOR<CustomerPaymentPreferenceUpdateManyMutationInput, CustomerPaymentPreferenceUncheckedUpdateManyWithoutUserInput>
  }

  export type TenantCreateWithoutBookingsInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutUncheckedCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordUncheckedCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBookingsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBookingsInput, TenantUncheckedCreateWithoutBookingsInput>
  }

  export type VenueCreateWithoutBookingsInput = {
    id?: string
    name: string
    address?: string | null
    capacity?: number | null
    basePriceCents: number
    currency?: string
    timeZone?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    paymentProfile?: string
    allowCashPayments?: boolean
    cashDiscountPercentage?: Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: boolean
    depositType?: string
    depositAmount?: number
    hasRazorpayAccount?: boolean
    razorpayKeyId?: string | null
    razorpayKeySecretEncrypted?: string | null
    platformHandlesPayments?: boolean
    confirmationTrigger?: string
    platformCommissionPercentage?: Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: number
    autoExpireUnpaidBookings?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVenuesInput
    blackouts?: BlackoutCreateNestedManyWithoutVenueInput
    commissionRecords?: CommissionRecordCreateNestedManyWithoutVenueInput
    venueOnboardingResponses?: VenueOnboardingResponseCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutBookingsInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    capacity?: number | null
    basePriceCents: number
    currency?: string
    timeZone?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    paymentProfile?: string
    allowCashPayments?: boolean
    cashDiscountPercentage?: Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: boolean
    depositType?: string
    depositAmount?: number
    hasRazorpayAccount?: boolean
    razorpayKeyId?: string | null
    razorpayKeySecretEncrypted?: string | null
    platformHandlesPayments?: boolean
    confirmationTrigger?: string
    platformCommissionPercentage?: Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: number
    autoExpireUnpaidBookings?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blackouts?: BlackoutUncheckedCreateNestedManyWithoutVenueInput
    commissionRecords?: CommissionRecordUncheckedCreateNestedManyWithoutVenueInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutBookingsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutBookingsInput, VenueUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutBookingsInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    confirmedBookings?: BookingCreateNestedManyWithoutConfirmedByUserInput
    cashPaymentsRecorded?: CashPaymentCreateNestedManyWithoutRecordedByUserInput
    customerPaymentPreferences?: CustomerPaymentPreferenceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: string
    tenantId: string
    name: string
    phone: string
    email?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedBookings?: BookingUncheckedCreateNestedManyWithoutConfirmedByUserInput
    cashPaymentsRecorded?: CashPaymentUncheckedCreateNestedManyWithoutRecordedByUserInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutConfirmedBookingsInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    cashPaymentsRecorded?: CashPaymentCreateNestedManyWithoutRecordedByUserInput
    customerPaymentPreferences?: CustomerPaymentPreferenceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConfirmedBookingsInput = {
    id?: string
    tenantId: string
    name: string
    phone: string
    email?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    cashPaymentsRecorded?: CashPaymentUncheckedCreateNestedManyWithoutRecordedByUserInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConfirmedBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConfirmedBookingsInput, UserUncheckedCreateWithoutConfirmedBookingsInput>
  }

  export type PaymentCreateWithoutBookingInput = {
    id?: string
    provider: string
    providerPaymentId?: string | null
    amountCents: number
    currency?: string
    status?: string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    id?: string
    tenantId: string
    provider: string
    providerPaymentId?: string | null
    amountCents: number
    currency?: string
    status?: string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentCreateManyBookingInputEnvelope = {
    data: PaymentCreateManyBookingInput | PaymentCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type CashPaymentCreateWithoutBookingInput = {
    id?: string
    amountCents: number
    recordedAt?: Date | string
    paymentMethod?: string
    notes?: string | null
    receiptNumber?: string | null
    verificationStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCashPaymentsInput
    recordedByUser?: UserCreateNestedOneWithoutCashPaymentsRecordedInput
  }

  export type CashPaymentUncheckedCreateWithoutBookingInput = {
    id?: string
    tenantId: string
    amountCents: number
    recordedBy?: string | null
    recordedAt?: Date | string
    paymentMethod?: string
    notes?: string | null
    receiptNumber?: string | null
    verificationStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashPaymentCreateOrConnectWithoutBookingInput = {
    where: CashPaymentWhereUniqueInput
    create: XOR<CashPaymentCreateWithoutBookingInput, CashPaymentUncheckedCreateWithoutBookingInput>
  }

  export type CashPaymentCreateManyBookingInputEnvelope = {
    data: CashPaymentCreateManyBookingInput | CashPaymentCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type CommissionRecordCreateWithoutBookingInput = {
    id?: string
    bookingAmountCents: number
    commissionPercentage: Decimal | DecimalJsLike | number | string
    commissionAmountCents: number
    commissionStatus?: string
    collectionMethod?: string | null
    collectedAt?: Date | string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCommissionRecordsInput
    venue: VenueCreateNestedOneWithoutCommissionRecordsInput
  }

  export type CommissionRecordUncheckedCreateWithoutBookingInput = {
    id?: string
    tenantId: string
    venueId: string
    bookingAmountCents: number
    commissionPercentage: Decimal | DecimalJsLike | number | string
    commissionAmountCents: number
    commissionStatus?: string
    collectionMethod?: string | null
    collectedAt?: Date | string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionRecordCreateOrConnectWithoutBookingInput = {
    where: CommissionRecordWhereUniqueInput
    create: XOR<CommissionRecordCreateWithoutBookingInput, CommissionRecordUncheckedCreateWithoutBookingInput>
  }

  export type CommissionRecordCreateManyBookingInputEnvelope = {
    data: CommissionRecordCreateManyBookingInput | CommissionRecordCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutBookingsInput = {
    update: XOR<TenantUpdateWithoutBookingsInput, TenantUncheckedUpdateWithoutBookingsInput>
    create: XOR<TenantCreateWithoutBookingsInput, TenantUncheckedCreateWithoutBookingsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBookingsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBookingsInput, TenantUncheckedUpdateWithoutBookingsInput>
  }

  export type TenantUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUncheckedUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUncheckedUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type VenueUpsertWithoutBookingsInput = {
    update: XOR<VenueUpdateWithoutBookingsInput, VenueUncheckedUpdateWithoutBookingsInput>
    create: XOR<VenueCreateWithoutBookingsInput, VenueUncheckedCreateWithoutBookingsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutBookingsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutBookingsInput, VenueUncheckedUpdateWithoutBookingsInput>
  }

  export type VenueUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVenuesNestedInput
    blackouts?: BlackoutUpdateManyWithoutVenueNestedInput
    commissionRecords?: CommissionRecordUpdateManyWithoutVenueNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blackouts?: BlackoutUncheckedUpdateManyWithoutVenueNestedInput
    commissionRecords?: CommissionRecordUncheckedUpdateManyWithoutVenueNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    confirmedBookings?: BookingUpdateManyWithoutConfirmedByUserNestedInput
    cashPaymentsRecorded?: CashPaymentUpdateManyWithoutRecordedByUserNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedBookings?: BookingUncheckedUpdateManyWithoutConfirmedByUserNestedInput
    cashPaymentsRecorded?: CashPaymentUncheckedUpdateManyWithoutRecordedByUserNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutConfirmedBookingsInput = {
    update: XOR<UserUpdateWithoutConfirmedBookingsInput, UserUncheckedUpdateWithoutConfirmedBookingsInput>
    create: XOR<UserCreateWithoutConfirmedBookingsInput, UserUncheckedCreateWithoutConfirmedBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConfirmedBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConfirmedBookingsInput, UserUncheckedUpdateWithoutConfirmedBookingsInput>
  }

  export type UserUpdateWithoutConfirmedBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    cashPaymentsRecorded?: CashPaymentUpdateManyWithoutRecordedByUserNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConfirmedBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    cashPaymentsRecorded?: CashPaymentUncheckedUpdateManyWithoutRecordedByUserNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBookingInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutBookingInput>
  }

  export type CashPaymentUpsertWithWhereUniqueWithoutBookingInput = {
    where: CashPaymentWhereUniqueInput
    update: XOR<CashPaymentUpdateWithoutBookingInput, CashPaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<CashPaymentCreateWithoutBookingInput, CashPaymentUncheckedCreateWithoutBookingInput>
  }

  export type CashPaymentUpdateWithWhereUniqueWithoutBookingInput = {
    where: CashPaymentWhereUniqueInput
    data: XOR<CashPaymentUpdateWithoutBookingInput, CashPaymentUncheckedUpdateWithoutBookingInput>
  }

  export type CashPaymentUpdateManyWithWhereWithoutBookingInput = {
    where: CashPaymentScalarWhereInput
    data: XOR<CashPaymentUpdateManyMutationInput, CashPaymentUncheckedUpdateManyWithoutBookingInput>
  }

  export type CommissionRecordUpsertWithWhereUniqueWithoutBookingInput = {
    where: CommissionRecordWhereUniqueInput
    update: XOR<CommissionRecordUpdateWithoutBookingInput, CommissionRecordUncheckedUpdateWithoutBookingInput>
    create: XOR<CommissionRecordCreateWithoutBookingInput, CommissionRecordUncheckedCreateWithoutBookingInput>
  }

  export type CommissionRecordUpdateWithWhereUniqueWithoutBookingInput = {
    where: CommissionRecordWhereUniqueInput
    data: XOR<CommissionRecordUpdateWithoutBookingInput, CommissionRecordUncheckedUpdateWithoutBookingInput>
  }

  export type CommissionRecordUpdateManyWithWhereWithoutBookingInput = {
    where: CommissionRecordScalarWhereInput
    data: XOR<CommissionRecordUpdateManyMutationInput, CommissionRecordUncheckedUpdateManyWithoutBookingInput>
  }

  export type TenantCreateWithoutBlackoutsInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBlackoutsInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordUncheckedCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBlackoutsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBlackoutsInput, TenantUncheckedCreateWithoutBlackoutsInput>
  }

  export type VenueCreateWithoutBlackoutsInput = {
    id?: string
    name: string
    address?: string | null
    capacity?: number | null
    basePriceCents: number
    currency?: string
    timeZone?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    paymentProfile?: string
    allowCashPayments?: boolean
    cashDiscountPercentage?: Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: boolean
    depositType?: string
    depositAmount?: number
    hasRazorpayAccount?: boolean
    razorpayKeyId?: string | null
    razorpayKeySecretEncrypted?: string | null
    platformHandlesPayments?: boolean
    confirmationTrigger?: string
    platformCommissionPercentage?: Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: number
    autoExpireUnpaidBookings?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVenuesInput
    bookings?: BookingCreateNestedManyWithoutVenueInput
    commissionRecords?: CommissionRecordCreateNestedManyWithoutVenueInput
    venueOnboardingResponses?: VenueOnboardingResponseCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutBlackoutsInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    capacity?: number | null
    basePriceCents: number
    currency?: string
    timeZone?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    paymentProfile?: string
    allowCashPayments?: boolean
    cashDiscountPercentage?: Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: boolean
    depositType?: string
    depositAmount?: number
    hasRazorpayAccount?: boolean
    razorpayKeyId?: string | null
    razorpayKeySecretEncrypted?: string | null
    platformHandlesPayments?: boolean
    confirmationTrigger?: string
    platformCommissionPercentage?: Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: number
    autoExpireUnpaidBookings?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVenueInput
    commissionRecords?: CommissionRecordUncheckedCreateNestedManyWithoutVenueInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutBlackoutsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutBlackoutsInput, VenueUncheckedCreateWithoutBlackoutsInput>
  }

  export type TenantUpsertWithoutBlackoutsInput = {
    update: XOR<TenantUpdateWithoutBlackoutsInput, TenantUncheckedUpdateWithoutBlackoutsInput>
    create: XOR<TenantCreateWithoutBlackoutsInput, TenantUncheckedCreateWithoutBlackoutsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBlackoutsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBlackoutsInput, TenantUncheckedUpdateWithoutBlackoutsInput>
  }

  export type TenantUpdateWithoutBlackoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBlackoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUncheckedUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type VenueUpsertWithoutBlackoutsInput = {
    update: XOR<VenueUpdateWithoutBlackoutsInput, VenueUncheckedUpdateWithoutBlackoutsInput>
    create: XOR<VenueCreateWithoutBlackoutsInput, VenueUncheckedCreateWithoutBlackoutsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutBlackoutsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutBlackoutsInput, VenueUncheckedUpdateWithoutBlackoutsInput>
  }

  export type VenueUpdateWithoutBlackoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVenuesNestedInput
    bookings?: BookingUpdateManyWithoutVenueNestedInput
    commissionRecords?: CommissionRecordUpdateManyWithoutVenueNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutBlackoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVenueNestedInput
    commissionRecords?: CommissionRecordUncheckedUpdateManyWithoutVenueNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type TenantCreateWithoutPaymentsInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutUncheckedCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordUncheckedCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPaymentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
  }

  export type BookingCreateWithoutPaymentsInput = {
    id?: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBookingsInput
    venue: VenueCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    confirmedByUser?: UserCreateNestedOneWithoutConfirmedBookingsInput
    cashPayments?: CashPaymentCreateNestedManyWithoutBookingInput
    commissionRecord?: CommissionRecordCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    venueId: string
    userId: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: string | null
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutBookingInput
    commissionRecord?: CommissionRecordUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPaymentsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
  }

  export type TenantUpsertWithoutPaymentsInput = {
    update: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUncheckedUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUncheckedUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type BookingUpsertWithoutPaymentsInput = {
    update: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type BookingUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBookingsNestedInput
    venue?: VenueUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    confirmedByUser?: UserUpdateOneWithoutConfirmedBookingsNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutBookingNestedInput
    commissionRecord?: CommissionRecordUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutBookingNestedInput
    commissionRecord?: CommissionRecordUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type TenantCreateWithoutCashPaymentsInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCashPaymentsInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutUncheckedCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordUncheckedCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCashPaymentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCashPaymentsInput, TenantUncheckedCreateWithoutCashPaymentsInput>
  }

  export type BookingCreateWithoutCashPaymentsInput = {
    id?: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBookingsInput
    venue: VenueCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    confirmedByUser?: UserCreateNestedOneWithoutConfirmedBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    commissionRecord?: CommissionRecordCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCashPaymentsInput = {
    id?: string
    tenantId: string
    venueId: string
    userId: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: string | null
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    commissionRecord?: CommissionRecordUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCashPaymentsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCashPaymentsInput, BookingUncheckedCreateWithoutCashPaymentsInput>
  }

  export type UserCreateWithoutCashPaymentsRecordedInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    confirmedBookings?: BookingCreateNestedManyWithoutConfirmedByUserInput
    customerPaymentPreferences?: CustomerPaymentPreferenceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCashPaymentsRecordedInput = {
    id?: string
    tenantId: string
    name: string
    phone: string
    email?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    confirmedBookings?: BookingUncheckedCreateNestedManyWithoutConfirmedByUserInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCashPaymentsRecordedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashPaymentsRecordedInput, UserUncheckedCreateWithoutCashPaymentsRecordedInput>
  }

  export type TenantUpsertWithoutCashPaymentsInput = {
    update: XOR<TenantUpdateWithoutCashPaymentsInput, TenantUncheckedUpdateWithoutCashPaymentsInput>
    create: XOR<TenantCreateWithoutCashPaymentsInput, TenantUncheckedCreateWithoutCashPaymentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCashPaymentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCashPaymentsInput, TenantUncheckedUpdateWithoutCashPaymentsInput>
  }

  export type TenantUpdateWithoutCashPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCashPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUncheckedUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUncheckedUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type BookingUpsertWithoutCashPaymentsInput = {
    update: XOR<BookingUpdateWithoutCashPaymentsInput, BookingUncheckedUpdateWithoutCashPaymentsInput>
    create: XOR<BookingCreateWithoutCashPaymentsInput, BookingUncheckedCreateWithoutCashPaymentsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutCashPaymentsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutCashPaymentsInput, BookingUncheckedUpdateWithoutCashPaymentsInput>
  }

  export type BookingUpdateWithoutCashPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBookingsNestedInput
    venue?: VenueUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    confirmedByUser?: UserUpdateOneWithoutConfirmedBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    commissionRecord?: CommissionRecordUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCashPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    commissionRecord?: CommissionRecordUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type UserUpsertWithoutCashPaymentsRecordedInput = {
    update: XOR<UserUpdateWithoutCashPaymentsRecordedInput, UserUncheckedUpdateWithoutCashPaymentsRecordedInput>
    create: XOR<UserCreateWithoutCashPaymentsRecordedInput, UserUncheckedCreateWithoutCashPaymentsRecordedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCashPaymentsRecordedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCashPaymentsRecordedInput, UserUncheckedUpdateWithoutCashPaymentsRecordedInput>
  }

  export type UserUpdateWithoutCashPaymentsRecordedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    confirmedBookings?: BookingUpdateManyWithoutConfirmedByUserNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCashPaymentsRecordedInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    confirmedBookings?: BookingUncheckedUpdateManyWithoutConfirmedByUserNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutCommissionRecordsInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCommissionRecordsInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutUncheckedCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCommissionRecordsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCommissionRecordsInput, TenantUncheckedCreateWithoutCommissionRecordsInput>
  }

  export type BookingCreateWithoutCommissionRecordInput = {
    id?: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBookingsInput
    venue: VenueCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    confirmedByUser?: UserCreateNestedOneWithoutConfirmedBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    cashPayments?: CashPaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCommissionRecordInput = {
    id?: string
    tenantId: string
    venueId: string
    userId: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: string | null
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCommissionRecordInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCommissionRecordInput, BookingUncheckedCreateWithoutCommissionRecordInput>
  }

  export type VenueCreateWithoutCommissionRecordsInput = {
    id?: string
    name: string
    address?: string | null
    capacity?: number | null
    basePriceCents: number
    currency?: string
    timeZone?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    paymentProfile?: string
    allowCashPayments?: boolean
    cashDiscountPercentage?: Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: boolean
    depositType?: string
    depositAmount?: number
    hasRazorpayAccount?: boolean
    razorpayKeyId?: string | null
    razorpayKeySecretEncrypted?: string | null
    platformHandlesPayments?: boolean
    confirmationTrigger?: string
    platformCommissionPercentage?: Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: number
    autoExpireUnpaidBookings?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVenuesInput
    bookings?: BookingCreateNestedManyWithoutVenueInput
    blackouts?: BlackoutCreateNestedManyWithoutVenueInput
    venueOnboardingResponses?: VenueOnboardingResponseCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutCommissionRecordsInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    capacity?: number | null
    basePriceCents: number
    currency?: string
    timeZone?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    paymentProfile?: string
    allowCashPayments?: boolean
    cashDiscountPercentage?: Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: boolean
    depositType?: string
    depositAmount?: number
    hasRazorpayAccount?: boolean
    razorpayKeyId?: string | null
    razorpayKeySecretEncrypted?: string | null
    platformHandlesPayments?: boolean
    confirmationTrigger?: string
    platformCommissionPercentage?: Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: number
    autoExpireUnpaidBookings?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVenueInput
    blackouts?: BlackoutUncheckedCreateNestedManyWithoutVenueInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutCommissionRecordsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutCommissionRecordsInput, VenueUncheckedCreateWithoutCommissionRecordsInput>
  }

  export type TenantUpsertWithoutCommissionRecordsInput = {
    update: XOR<TenantUpdateWithoutCommissionRecordsInput, TenantUncheckedUpdateWithoutCommissionRecordsInput>
    create: XOR<TenantCreateWithoutCommissionRecordsInput, TenantUncheckedCreateWithoutCommissionRecordsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCommissionRecordsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCommissionRecordsInput, TenantUncheckedUpdateWithoutCommissionRecordsInput>
  }

  export type TenantUpdateWithoutCommissionRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCommissionRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUncheckedUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type BookingUpsertWithoutCommissionRecordInput = {
    update: XOR<BookingUpdateWithoutCommissionRecordInput, BookingUncheckedUpdateWithoutCommissionRecordInput>
    create: XOR<BookingCreateWithoutCommissionRecordInput, BookingUncheckedCreateWithoutCommissionRecordInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutCommissionRecordInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutCommissionRecordInput, BookingUncheckedUpdateWithoutCommissionRecordInput>
  }

  export type BookingUpdateWithoutCommissionRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBookingsNestedInput
    venue?: VenueUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    confirmedByUser?: UserUpdateOneWithoutConfirmedBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCommissionRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type VenueUpsertWithoutCommissionRecordsInput = {
    update: XOR<VenueUpdateWithoutCommissionRecordsInput, VenueUncheckedUpdateWithoutCommissionRecordsInput>
    create: XOR<VenueCreateWithoutCommissionRecordsInput, VenueUncheckedCreateWithoutCommissionRecordsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutCommissionRecordsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutCommissionRecordsInput, VenueUncheckedUpdateWithoutCommissionRecordsInput>
  }

  export type VenueUpdateWithoutCommissionRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVenuesNestedInput
    bookings?: BookingUpdateManyWithoutVenueNestedInput
    blackouts?: BlackoutUpdateManyWithoutVenueNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutCommissionRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVenueNestedInput
    blackouts?: BlackoutUncheckedUpdateManyWithoutVenueNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type TenantCreateWithoutCustomerPaymentPreferencesInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCustomerPaymentPreferencesInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutUncheckedCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordUncheckedCreateNestedManyWithoutTenantInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCustomerPaymentPreferencesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCustomerPaymentPreferencesInput, TenantUncheckedCreateWithoutCustomerPaymentPreferencesInput>
  }

  export type UserCreateWithoutCustomerPaymentPreferencesInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    confirmedBookings?: BookingCreateNestedManyWithoutConfirmedByUserInput
    cashPaymentsRecorded?: CashPaymentCreateNestedManyWithoutRecordedByUserInput
  }

  export type UserUncheckedCreateWithoutCustomerPaymentPreferencesInput = {
    id?: string
    tenantId: string
    name: string
    phone: string
    email?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    confirmedBookings?: BookingUncheckedCreateNestedManyWithoutConfirmedByUserInput
    cashPaymentsRecorded?: CashPaymentUncheckedCreateNestedManyWithoutRecordedByUserInput
  }

  export type UserCreateOrConnectWithoutCustomerPaymentPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomerPaymentPreferencesInput, UserUncheckedCreateWithoutCustomerPaymentPreferencesInput>
  }

  export type TenantUpsertWithoutCustomerPaymentPreferencesInput = {
    update: XOR<TenantUpdateWithoutCustomerPaymentPreferencesInput, TenantUncheckedUpdateWithoutCustomerPaymentPreferencesInput>
    create: XOR<TenantCreateWithoutCustomerPaymentPreferencesInput, TenantUncheckedCreateWithoutCustomerPaymentPreferencesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCustomerPaymentPreferencesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCustomerPaymentPreferencesInput, TenantUncheckedUpdateWithoutCustomerPaymentPreferencesInput>
  }

  export type TenantUpdateWithoutCustomerPaymentPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCustomerPaymentPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUncheckedUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUncheckedUpdateManyWithoutTenantNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutCustomerPaymentPreferencesInput = {
    update: XOR<UserUpdateWithoutCustomerPaymentPreferencesInput, UserUncheckedUpdateWithoutCustomerPaymentPreferencesInput>
    create: XOR<UserCreateWithoutCustomerPaymentPreferencesInput, UserUncheckedCreateWithoutCustomerPaymentPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomerPaymentPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomerPaymentPreferencesInput, UserUncheckedUpdateWithoutCustomerPaymentPreferencesInput>
  }

  export type UserUpdateWithoutCustomerPaymentPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    confirmedBookings?: BookingUpdateManyWithoutConfirmedByUserNestedInput
    cashPaymentsRecorded?: CashPaymentUpdateManyWithoutRecordedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomerPaymentPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    confirmedBookings?: BookingUncheckedUpdateManyWithoutConfirmedByUserNestedInput
    cashPaymentsRecorded?: CashPaymentUncheckedUpdateManyWithoutRecordedByUserNestedInput
  }

  export type TenantCreateWithoutVenueOnboardingResponsesInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutVenueOnboardingResponsesInput = {
    id?: string
    name: string
    slug: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    blackouts?: BlackoutUncheckedCreateNestedManyWithoutTenantInput
    cashPayments?: CashPaymentUncheckedCreateNestedManyWithoutTenantInput
    commissionRecords?: CommissionRecordUncheckedCreateNestedManyWithoutTenantInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutVenueOnboardingResponsesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutVenueOnboardingResponsesInput, TenantUncheckedCreateWithoutVenueOnboardingResponsesInput>
  }

  export type VenueCreateWithoutVenueOnboardingResponsesInput = {
    id?: string
    name: string
    address?: string | null
    capacity?: number | null
    basePriceCents: number
    currency?: string
    timeZone?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    paymentProfile?: string
    allowCashPayments?: boolean
    cashDiscountPercentage?: Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: boolean
    depositType?: string
    depositAmount?: number
    hasRazorpayAccount?: boolean
    razorpayKeyId?: string | null
    razorpayKeySecretEncrypted?: string | null
    platformHandlesPayments?: boolean
    confirmationTrigger?: string
    platformCommissionPercentage?: Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: number
    autoExpireUnpaidBookings?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVenuesInput
    bookings?: BookingCreateNestedManyWithoutVenueInput
    blackouts?: BlackoutCreateNestedManyWithoutVenueInput
    commissionRecords?: CommissionRecordCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutVenueOnboardingResponsesInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    capacity?: number | null
    basePriceCents: number
    currency?: string
    timeZone?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    paymentProfile?: string
    allowCashPayments?: boolean
    cashDiscountPercentage?: Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: boolean
    depositType?: string
    depositAmount?: number
    hasRazorpayAccount?: boolean
    razorpayKeyId?: string | null
    razorpayKeySecretEncrypted?: string | null
    platformHandlesPayments?: boolean
    confirmationTrigger?: string
    platformCommissionPercentage?: Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: number
    autoExpireUnpaidBookings?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVenueInput
    blackouts?: BlackoutUncheckedCreateNestedManyWithoutVenueInput
    commissionRecords?: CommissionRecordUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutVenueOnboardingResponsesInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutVenueOnboardingResponsesInput, VenueUncheckedCreateWithoutVenueOnboardingResponsesInput>
  }

  export type TenantUpsertWithoutVenueOnboardingResponsesInput = {
    update: XOR<TenantUpdateWithoutVenueOnboardingResponsesInput, TenantUncheckedUpdateWithoutVenueOnboardingResponsesInput>
    create: XOR<TenantCreateWithoutVenueOnboardingResponsesInput, TenantUncheckedCreateWithoutVenueOnboardingResponsesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutVenueOnboardingResponsesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutVenueOnboardingResponsesInput, TenantUncheckedUpdateWithoutVenueOnboardingResponsesInput>
  }

  export type TenantUpdateWithoutVenueOnboardingResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutVenueOnboardingResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    blackouts?: BlackoutUncheckedUpdateManyWithoutTenantNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutTenantNestedInput
    commissionRecords?: CommissionRecordUncheckedUpdateManyWithoutTenantNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type VenueUpsertWithoutVenueOnboardingResponsesInput = {
    update: XOR<VenueUpdateWithoutVenueOnboardingResponsesInput, VenueUncheckedUpdateWithoutVenueOnboardingResponsesInput>
    create: XOR<VenueCreateWithoutVenueOnboardingResponsesInput, VenueUncheckedCreateWithoutVenueOnboardingResponsesInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutVenueOnboardingResponsesInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutVenueOnboardingResponsesInput, VenueUncheckedUpdateWithoutVenueOnboardingResponsesInput>
  }

  export type VenueUpdateWithoutVenueOnboardingResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVenuesNestedInput
    bookings?: BookingUpdateManyWithoutVenueNestedInput
    blackouts?: BlackoutUpdateManyWithoutVenueNestedInput
    commissionRecords?: CommissionRecordUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutVenueOnboardingResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVenueNestedInput
    blackouts?: BlackoutUncheckedUpdateManyWithoutVenueNestedInput
    commissionRecords?: CommissionRecordUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateManyTenantInput = {
    id?: string
    name: string
    address?: string | null
    capacity?: number | null
    basePriceCents: number
    currency?: string
    timeZone?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    paymentProfile?: string
    allowCashPayments?: boolean
    cashDiscountPercentage?: Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: boolean
    depositType?: string
    depositAmount?: number
    hasRazorpayAccount?: boolean
    razorpayKeyId?: string | null
    razorpayKeySecretEncrypted?: string | null
    platformHandlesPayments?: boolean
    confirmationTrigger?: string
    platformCommissionPercentage?: Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: number
    autoExpireUnpaidBookings?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyTenantInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyTenantInput = {
    id?: string
    venueId: string
    userId: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: string | null
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyTenantInput = {
    id?: string
    bookingId: string
    provider: string
    providerPaymentId?: string | null
    amountCents: number
    currency?: string
    status?: string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BlackoutCreateManyTenantInput = {
    id?: string
    venueId: string
    startTs: Date | string
    endTs: Date | string
    reason?: string | null
    isMaintenance?: boolean
    createdAt?: Date | string
  }

  export type CashPaymentCreateManyTenantInput = {
    id?: string
    bookingId: string
    amountCents: number
    recordedBy?: string | null
    recordedAt?: Date | string
    paymentMethod?: string
    notes?: string | null
    receiptNumber?: string | null
    verificationStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionRecordCreateManyTenantInput = {
    id?: string
    bookingId: string
    venueId: string
    bookingAmountCents: number
    commissionPercentage: Decimal | DecimalJsLike | number | string
    commissionAmountCents: number
    commissionStatus?: string
    collectionMethod?: string | null
    collectedAt?: Date | string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPaymentPreferenceCreateManyTenantInput = {
    id?: string
    userId: string
    preferredMethod?: string
    cityTier?: string | null
    lastPaymentMethod?: string | null
    totalBookings?: number
    totalOnlinePayments?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueOnboardingResponseCreateManyTenantInput = {
    id?: string
    venueId: string
    paymentPreference?: string | null
    techComfortLevel?: string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: number | null
    averageBookingValueCents?: number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VenueUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutVenueNestedInput
    blackouts?: BlackoutUpdateManyWithoutVenueNestedInput
    commissionRecords?: CommissionRecordUpdateManyWithoutVenueNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVenueNestedInput
    blackouts?: BlackoutUncheckedUpdateManyWithoutVenueNestedInput
    commissionRecords?: CommissionRecordUncheckedUpdateManyWithoutVenueNestedInput
    venueOnboardingResponses?: VenueOnboardingResponseUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentProfile?: StringFieldUpdateOperationsInput | string
    allowCashPayments?: BoolFieldUpdateOperationsInput | boolean
    cashDiscountPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresOnlineDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositType?: StringFieldUpdateOperationsInput | string
    depositAmount?: IntFieldUpdateOperationsInput | number
    hasRazorpayAccount?: BoolFieldUpdateOperationsInput | boolean
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecretEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    platformHandlesPayments?: BoolFieldUpdateOperationsInput | boolean
    confirmationTrigger?: StringFieldUpdateOperationsInput | string
    platformCommissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDueDaysBeforeEvent?: IntFieldUpdateOperationsInput | number
    autoExpireUnpaidBookings?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutUserNestedInput
    confirmedBookings?: BookingUpdateManyWithoutConfirmedByUserNestedInput
    cashPaymentsRecorded?: CashPaymentUpdateManyWithoutRecordedByUserNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    confirmedBookings?: BookingUncheckedUpdateManyWithoutConfirmedByUserNestedInput
    cashPaymentsRecorded?: CashPaymentUncheckedUpdateManyWithoutRecordedByUserNestedInput
    customerPaymentPreferences?: CustomerPaymentPreferenceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    confirmedByUser?: UserUpdateOneWithoutConfirmedBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutBookingNestedInput
    commissionRecord?: CommissionRecordUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutBookingNestedInput
    commissionRecord?: CommissionRecordUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlackoutUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isMaintenance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutBlackoutsNestedInput
  }

  export type BlackoutUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isMaintenance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlackoutUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isMaintenance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashPaymentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutCashPaymentsNestedInput
    recordedByUser?: UserUpdateOneWithoutCashPaymentsRecordedNestedInput
  }

  export type CashPaymentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashPaymentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionRecordUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingAmountCents?: IntFieldUpdateOperationsInput | number
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFieldUpdateOperationsInput | number
    commissionStatus?: StringFieldUpdateOperationsInput | string
    collectionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutCommissionRecordNestedInput
    venue?: VenueUpdateOneRequiredWithoutCommissionRecordsNestedInput
  }

  export type CommissionRecordUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    bookingAmountCents?: IntFieldUpdateOperationsInput | number
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFieldUpdateOperationsInput | number
    commissionStatus?: StringFieldUpdateOperationsInput | string
    collectionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionRecordUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    bookingAmountCents?: IntFieldUpdateOperationsInput | number
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFieldUpdateOperationsInput | number
    commissionStatus?: StringFieldUpdateOperationsInput | string
    collectionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPaymentPreferenceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferredMethod?: StringFieldUpdateOperationsInput | string
    cityTier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    totalBookings?: IntFieldUpdateOperationsInput | number
    totalOnlinePayments?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerPaymentPreferencesNestedInput
  }

  export type CustomerPaymentPreferenceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredMethod?: StringFieldUpdateOperationsInput | string
    cityTier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    totalBookings?: IntFieldUpdateOperationsInput | number
    totalOnlinePayments?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPaymentPreferenceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredMethod?: StringFieldUpdateOperationsInput | string
    cityTier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    totalBookings?: IntFieldUpdateOperationsInput | number
    totalOnlinePayments?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueOnboardingResponseUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentPreference?: NullableStringFieldUpdateOperationsInput | string | null
    techComfortLevel?: NullableStringFieldUpdateOperationsInput | string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: NullableIntFieldUpdateOperationsInput | number | null
    averageBookingValueCents?: NullableIntFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutVenueOnboardingResponsesNestedInput
  }

  export type VenueOnboardingResponseUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    paymentPreference?: NullableStringFieldUpdateOperationsInput | string | null
    techComfortLevel?: NullableStringFieldUpdateOperationsInput | string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: NullableIntFieldUpdateOperationsInput | number | null
    averageBookingValueCents?: NullableIntFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueOnboardingResponseUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    paymentPreference?: NullableStringFieldUpdateOperationsInput | string | null
    techComfortLevel?: NullableStringFieldUpdateOperationsInput | string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: NullableIntFieldUpdateOperationsInput | number | null
    averageBookingValueCents?: NullableIntFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyVenueInput = {
    id?: string
    tenantId: string
    userId: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: string | null
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlackoutCreateManyVenueInput = {
    id?: string
    tenantId: string
    startTs: Date | string
    endTs: Date | string
    reason?: string | null
    isMaintenance?: boolean
    createdAt?: Date | string
  }

  export type CommissionRecordCreateManyVenueInput = {
    id?: string
    tenantId: string
    bookingId: string
    bookingAmountCents: number
    commissionPercentage: Decimal | DecimalJsLike | number | string
    commissionAmountCents: number
    commissionStatus?: string
    collectionMethod?: string | null
    collectedAt?: Date | string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueOnboardingResponseCreateManyVenueInput = {
    id?: string
    tenantId: string
    paymentPreference?: string | null
    techComfortLevel?: string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: number | null
    averageBookingValueCents?: number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BookingUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    confirmedByUser?: UserUpdateOneWithoutConfirmedBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutBookingNestedInput
    commissionRecord?: CommissionRecordUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutBookingNestedInput
    commissionRecord?: CommissionRecordUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlackoutUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isMaintenance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBlackoutsNestedInput
  }

  export type BlackoutUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isMaintenance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlackoutUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isMaintenance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionRecordUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingAmountCents?: IntFieldUpdateOperationsInput | number
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFieldUpdateOperationsInput | number
    commissionStatus?: StringFieldUpdateOperationsInput | string
    collectionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCommissionRecordsNestedInput
    booking?: BookingUpdateOneRequiredWithoutCommissionRecordNestedInput
  }

  export type CommissionRecordUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingAmountCents?: IntFieldUpdateOperationsInput | number
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFieldUpdateOperationsInput | number
    commissionStatus?: StringFieldUpdateOperationsInput | string
    collectionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionRecordUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingAmountCents?: IntFieldUpdateOperationsInput | number
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFieldUpdateOperationsInput | number
    commissionStatus?: StringFieldUpdateOperationsInput | string
    collectionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueOnboardingResponseUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentPreference?: NullableStringFieldUpdateOperationsInput | string | null
    techComfortLevel?: NullableStringFieldUpdateOperationsInput | string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: NullableIntFieldUpdateOperationsInput | number | null
    averageBookingValueCents?: NullableIntFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVenueOnboardingResponsesNestedInput
  }

  export type VenueOnboardingResponseUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentPreference?: NullableStringFieldUpdateOperationsInput | string | null
    techComfortLevel?: NullableStringFieldUpdateOperationsInput | string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: NullableIntFieldUpdateOperationsInput | number | null
    averageBookingValueCents?: NullableIntFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueOnboardingResponseUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentPreference?: NullableStringFieldUpdateOperationsInput | string | null
    techComfortLevel?: NullableStringFieldUpdateOperationsInput | string | null
    currentPaymentMethods?: NullableJsonNullValueInput | InputJsonValue
    monthlyBookingVolume?: NullableIntFieldUpdateOperationsInput | number | null
    averageBookingValueCents?: NullableIntFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyUserInput = {
    id?: string
    tenantId: string
    venueId: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    confirmedBy?: string | null
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyConfirmedByUserInput = {
    id?: string
    tenantId: string
    venueId: string
    userId: string
    bookingNumber: string
    startTs: Date | string
    endTs: Date | string
    status?: string
    holdExpiresAt?: Date | string | null
    totalAmountCents?: number | null
    currency?: string
    paymentStatus?: string
    paymentMethod?: string | null
    onlineAmountDue?: number
    cashAmountDue?: number
    cashDiscountApplied?: number
    paymentDueDate?: Date | string | null
    cashPaymentAcknowledged?: boolean
    requiresManualConfirmation?: boolean
    idempotencyKey?: string | null
    eventType?: string | null
    guestCount?: number | null
    specialRequests?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashPaymentCreateManyRecordedByUserInput = {
    id?: string
    tenantId: string
    bookingId: string
    amountCents: number
    recordedAt?: Date | string
    paymentMethod?: string
    notes?: string | null
    receiptNumber?: string | null
    verificationStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPaymentPreferenceCreateManyUserInput = {
    id?: string
    tenantId: string
    preferredMethod?: string
    cityTier?: string | null
    lastPaymentMethod?: string | null
    totalBookings?: number
    totalOnlinePayments?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBookingsNestedInput
    venue?: VenueUpdateOneRequiredWithoutBookingsNestedInput
    confirmedByUser?: UserUpdateOneWithoutConfirmedBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutBookingNestedInput
    commissionRecord?: CommissionRecordUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutBookingNestedInput
    commissionRecord?: CommissionRecordUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutConfirmedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBookingsNestedInput
    venue?: VenueUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    cashPayments?: CashPaymentUpdateManyWithoutBookingNestedInput
    commissionRecord?: CommissionRecordUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutConfirmedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    cashPayments?: CashPaymentUncheckedUpdateManyWithoutBookingNestedInput
    commissionRecord?: CommissionRecordUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutConfirmedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    startTs?: DateTimeFieldUpdateOperationsInput | Date | string
    endTs?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmountCents?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    onlineAmountDue?: IntFieldUpdateOperationsInput | number
    cashAmountDue?: IntFieldUpdateOperationsInput | number
    cashDiscountApplied?: IntFieldUpdateOperationsInput | number
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashPaymentAcknowledged?: BoolFieldUpdateOperationsInput | boolean
    requiresManualConfirmation?: BoolFieldUpdateOperationsInput | boolean
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: NullableIntFieldUpdateOperationsInput | number | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashPaymentUpdateWithoutRecordedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCashPaymentsNestedInput
    booking?: BookingUpdateOneRequiredWithoutCashPaymentsNestedInput
  }

  export type CashPaymentUncheckedUpdateWithoutRecordedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashPaymentUncheckedUpdateManyWithoutRecordedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPaymentPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferredMethod?: StringFieldUpdateOperationsInput | string
    cityTier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    totalBookings?: IntFieldUpdateOperationsInput | number
    totalOnlinePayments?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCustomerPaymentPreferencesNestedInput
  }

  export type CustomerPaymentPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    preferredMethod?: StringFieldUpdateOperationsInput | string
    cityTier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    totalBookings?: IntFieldUpdateOperationsInput | number
    totalOnlinePayments?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPaymentPreferenceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    preferredMethod?: StringFieldUpdateOperationsInput | string
    cityTier?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    totalBookings?: IntFieldUpdateOperationsInput | number
    totalOnlinePayments?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyBookingInput = {
    id?: string
    tenantId: string
    provider: string
    providerPaymentId?: string | null
    amountCents: number
    currency?: string
    status?: string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CashPaymentCreateManyBookingInput = {
    id?: string
    tenantId: string
    amountCents: number
    recordedBy?: string | null
    recordedAt?: Date | string
    paymentMethod?: string
    notes?: string | null
    receiptNumber?: string | null
    verificationStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionRecordCreateManyBookingInput = {
    id?: string
    tenantId: string
    venueId: string
    bookingAmountCents: number
    commissionPercentage: Decimal | DecimalJsLike | number | string
    commissionAmountCents: number
    commissionStatus?: string
    collectionMethod?: string | null
    collectedAt?: Date | string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashPaymentUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCashPaymentsNestedInput
    recordedByUser?: UserUpdateOneWithoutCashPaymentsRecordedNestedInput
  }

  export type CashPaymentUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashPaymentUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionRecordUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingAmountCents?: IntFieldUpdateOperationsInput | number
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFieldUpdateOperationsInput | number
    commissionStatus?: StringFieldUpdateOperationsInput | string
    collectionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCommissionRecordsNestedInput
    venue?: VenueUpdateOneRequiredWithoutCommissionRecordsNestedInput
  }

  export type CommissionRecordUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    bookingAmountCents?: IntFieldUpdateOperationsInput | number
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFieldUpdateOperationsInput | number
    commissionStatus?: StringFieldUpdateOperationsInput | string
    collectionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionRecordUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    bookingAmountCents?: IntFieldUpdateOperationsInput | number
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmountCents?: IntFieldUpdateOperationsInput | number
    commissionStatus?: StringFieldUpdateOperationsInput | string
    collectionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    collectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}