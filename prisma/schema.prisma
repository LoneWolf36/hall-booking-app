// Prisma schema for Parbhani Hall Booking MVP
// Notes:
// - Prisma does not natively support Postgres range types (e.g., tstzrange).
//   Industry-standard practice is to store the range in a normal column via
//   a raw SQL migration and access it via prisma.$queryRaw for reads/writes,
//   while keeping a shadow JSON representation or start/end columns if needed.
// - Here we model startTs/endTs as ISO timestamps for Prisma convenience,
//   and we enforce overlap prevention at the database level using an
//   exclusion constraint on a native Postgres column `ts_range TSTZRANGE`.
// - Prisma models include tenant_id for future multi-tenant use (row-based).

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Tenant represents a logical customer (single hall now, multi-tenant later)
model Tenant {
  id        String   @id @default(uuid())
  name      String
  slug      String   @unique
  settings  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  venues   Venue[]
  users    User[]
  bookings Booking[]
  payments Payment[]
  Blackout Blackout[]

  @@map("tenants")
}

/// Venue is the hall to be booked. MVP uses one venue.
model Venue {
  id             String   @id @default(uuid())
  tenantId       String
  name           String
  address        String?
  capacity       Int?
  basePriceCents Int
  currency       String   @default("INR")
  timeZone       String   @default("Asia/Kolkata")
  settings       Json?
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  tenant    Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  bookings  Booking[]
  blackouts Blackout[]

  @@unique([tenantId, name])
  @@map("venues")
}

/// Users include customers and admins (role-based)
model User {
  id        String   @id @default(uuid())
  tenantId  String
  name      String
  phone     String
  email     String?
  role      String   @default("customer")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  bookings Booking[]

  @@unique([tenantId, phone])
  @@map("users")
}

/// Booking stores startTs/endTs for Prisma convenience, while actual overlap
/// prevention is enforced by a native Postgres `ts_range TSTZRANGE` column
/// added via SQL migration + GIST exclusion constraint.
model Booking {
  id               String    @id @default(uuid())
  tenantId         String
  venueId          String
  userId           String
  bookingNumber    String
  // Prisma-level timestamps for app logic, always UTC in DB
  startTs          DateTime
  endTs            DateTime
  status           String    @default("temp_hold") // temp_hold|pending|confirmed|cancelled|expired
  holdExpiresAt    DateTime?
  totalAmountCents Int?
  currency         String    @default("INR")
  paymentStatus    String    @default("pending") // pending|partial|paid|refunded
  idempotencyKey   String?
  eventType        String?
  guestCount       Int?
  specialRequests  String?
  meta             Json?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  venue    Venue     @relation(fields: [venueId], references: [id], onDelete: Cascade)
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  payments Payment[]

  @@unique([tenantId, bookingNumber])
  @@unique([tenantId, idempotencyKey])
  @@index([tenantId, venueId, startTs, endTs])
  @@index([status, holdExpiresAt])
  @@map("bookings")
}

/// Blackout periods where the venue is unavailable.
model Blackout {
  id            String   @id @default(uuid())
  tenantId      String
  venueId       String
  // Prisma-level timestamps; DB also keeps native ts_range
  startTs       DateTime
  endTs         DateTime
  reason        String?
  isMaintenance Boolean  @default(false)
  createdAt     DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  venue  Venue  @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@index([tenantId, venueId, startTs, endTs])
  @@map("availability_blackouts")
}

/// Payments linked to bookings and processed via Razorpay or cash
model Payment {
  id                String    @id @default(uuid())
  tenantId          String
  bookingId         String
  provider          String // razorpay|cash|...
  providerPaymentId String?
  amountCents       Int
  currency          String    @default("INR")
  status            String    @default("pending") // pending|success|failed|refunded
  gatewayResponse   Json?
  processedAt       DateTime?
  createdAt         DateTime  @default(now())

  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([tenantId, bookingId, status])
  @@map("payments")
}
